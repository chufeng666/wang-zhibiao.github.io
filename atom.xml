<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wang-zhibiao&#39;blog</title>
  
  <subtitle>I am is a boy</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wang-zhibiao.github.io/"/>
  <updated>2019-07-25T02:00:33.243Z</updated>
  <id>http://wang-zhibiao.github.io/</id>
  
  <author>
    <name>wangzhibiao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>高德地图与vue的使用</title>
    <link href="http://wang-zhibiao.github.io/2019/06/26/%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE/"/>
    <id>http://wang-zhibiao.github.io/2019/06/26/高德地图/</id>
    <published>2019-06-26T02:00:56.000Z</published>
    <updated>2019-07-25T02:00:33.243Z</updated>
    
    <content type="html"><![CDATA[<h4 id="首先介绍一下vue与高德-之间的联系"><a href="#首先介绍一下vue与高德-之间的联系" class="headerlink" title="首先介绍一下vue与高德 之间的联系"></a>首先介绍一下vue与高德 之间的联系</h4><p>vue与数据息息相关，而且，vue的数据使用是通过this来调用</p><p>也是把数据挂载到了vm实例身上，调用时，使用this调用vm实例上挂载的数据及其方便，所以在vue的使用时我们偶尔也会碰到this指向不明，指向的不是vm实例导致  数据输出undefined</p><p>高德的API使用简单，我们可以思考：与vue的this的挂载使用</p><h4 id="初始化地图"><a href="#初始化地图" class="headerlink" title="初始化地图"></a>初始化地图</h4><h5 id="调用地图接口-同步"><a href="#调用地图接口-同步" class="headerlink" title="调用地图接口-同步"></a>调用地图接口-同步</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script</span><br><span class="line">      type=<span class="string">"text/javascript"</span></span><br><span class="line">      src=<span class="string">"https://webapi.amap.com/maps?v=1.4.15&amp;key=你个人的key，下面有高德与百度的链接"</span></span><br><span class="line">    &gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><a href="https://lbs.amap.com/api/javascript-api/guide/abc/prepare" target="_blank" rel="noopener">高德地图</a>            <a href="https://lbsyun.baidu.com/index.php?title=jspopular3.0/guide/getkey" target="_blank" rel="noopener">百度地图</a></p><h5 id="调用接口-异步"><a href="#调用接口-异步" class="headerlink" title="调用接口-异步"></a>调用接口-异步</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onLoad  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> map = <span class="keyword">new</span> AMap.Map(<span class="string">'container'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">'https://webapi.amap.com/maps?v=1.4.15&amp;key=您申请的key值&amp;callback=onLoad'</span>;</span><br><span class="line"><span class="keyword">var</span> jsapi = doc.createElement(<span class="string">'script'</span>);</span><br><span class="line">jsapi.charset = <span class="string">'utf-8'</span>;</span><br><span class="line">jsapi.src = url;</span><br><span class="line"><span class="built_in">document</span>.head.appendChild(jsapi);</span><br></pre></td></tr></table></figure><p>两者各有优缺，看场景使用</p><h6 id="官方的使用"><a href="#官方的使用" class="headerlink" title="官方的使用"></a>官方的使用</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> AMap.Map(<span class="string">'container'</span>, &#123;</span><br><span class="line">       zoom:<span class="number">11</span>,<span class="comment">//级别</span></span><br><span class="line">       center: [<span class="number">116.397428</span>, <span class="number">39.90923</span>],<span class="comment">//中心点坐标</span></span><br><span class="line">       viewMode:<span class="string">'3D'</span><span class="comment">//使用3D视图</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h6 id="与vue结合使用"><a href="#与vue结合使用" class="headerlink" title="与vue结合使用"></a>与vue结合使用</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">          map:<span class="literal">null</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.map = <span class="keyword">new</span> AMap.Map(<span class="string">"hotelMap"</span>, &#123;</span><br><span class="line">        zoom: <span class="number">11</span>, <span class="comment">//级别</span></span><br><span class="line">        center: [<span class="number">116.397428</span>, <span class="number">39.90923</span>], <span class="comment">//中心点坐标</span></span><br><span class="line">        viewMode: <span class="string">"3D"</span> <span class="comment">//使用3D视图</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>两者的区别只是this与var的不同，但是实际上var 是定义一个全局的map变量让我们使用，我们在哪个函数都能使用map  因为他是全局的变量  </p><p>this却是让map这个变量挂载到vm实例身上，所以你需要在data里初始化map</p><h4 id="你的地图需要描点与打开信息窗体时"><a href="#你的地图需要描点与打开信息窗体时" class="headerlink" title="你的地图需要描点与打开信息窗体时"></a>你的地图需要描点与打开信息窗体时</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">       MapData:[],  <span class="comment">// 后台数据初始化</span></span><br><span class="line">      map: <span class="literal">null</span>,  <span class="comment">//地图初始化</span></span><br><span class="line">      infoWindow  <span class="comment">// 信息窗体</span></span><br><span class="line">      markers: <span class="literal">null</span>, <span class="comment">// 点的数据</span></span><br><span class="line">      center: [<span class="number">118.796623</span>, <span class="number">32.059352</span>]  <span class="comment">// 地图中心点</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>在vue调用地图时最好使用定时器调用，因为地图加载需要时间</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">this</span>.setMapInfo();</span><br><span class="line"> &#125;, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>生成多个描点 需要后台返回经纬度信息，下面使用的数据已经是后台返回的带有经纬度信息location：{ longitude：经度 ，latitude：纬度}</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    setMapInfo() &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;location&#125; = <span class="keyword">this</span>.MapData[<span class="number">3</span>]  <span class="comment">//数据的第三条数据当地图中心</span></span><br><span class="line">      <span class="comment">//设置地图中心点</span></span><br><span class="line">      <span class="keyword">this</span>.center = [location.longitude,location.latitude]</span><br><span class="line">      <span class="keyword">this</span>.map = <span class="keyword">new</span> AMap.Map(<span class="string">"hotelMap"</span>, &#123;   <span class="comment">//初始化地图</span></span><br><span class="line">        zoom: <span class="number">10</span>, <span class="comment">//级别</span></span><br><span class="line">        center: <span class="keyword">this</span>.center, <span class="comment">//中心点坐标</span></span><br><span class="line">        viewMode: <span class="string">"3D"</span> <span class="comment">//使用3D视图</span></span><br><span class="line">      &#125;);</span><br><span class="line">        <span class="comment">//数据的循环  让点循环生成</span></span><br><span class="line">      <span class="keyword">this</span>.MapData.forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//生成多个坐标点</span></span><br><span class="line">        <span class="keyword">this</span>.setMarker(v.area, [v.location.longitude, v.location.latitude], v);  <span class="comment">//第一个v.area  是点的标识，第二个是一个经纬度数据，第三个是v 后台的其他信息  ==》可以直接写参数v  其他的在setMarker</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//添加点标记</span></span><br><span class="line">    setMarker(markers, position, data) &#123;</span><br><span class="line">        <span class="comment">//点的设置</span></span><br><span class="line">      <span class="keyword">this</span>.markers = <span class="keyword">new</span> AMap.Marker(&#123;</span><br><span class="line">          <span class="comment">//点的内容，也是你在地图中显示的点的样式 你可以是一张图片 可以是圆，多边形</span></span><br><span class="line">        content: <span class="string">`&lt;div style="width:20px;height:28px;text-align:center;" class="el-icon-location"&gt;&lt;/div&gt;`</span>,</span><br><span class="line">        <span class="comment">//点的经纬度  也是位置</span></span><br><span class="line">        position: position,</span><br><span class="line">          <span class="comment">///点也有偏移</span></span><br><span class="line">        offset: <span class="keyword">new</span> AMap.Pixel(<span class="number">-17</span>, <span class="number">-42</span>), <span class="comment">// 相对于基点的偏移位置</span></span><br><span class="line">         <span class="comment">//地图一定要绑定在你想使用的地图上 也就是说在一个页面不一定只有一个地图</span></span><br><span class="line">        map: <span class="keyword">this</span>.map <span class="comment">//把点标记绑在前面初始化的 map_ 上，否则不显示</span></span><br><span class="line">      &#125;);</span><br><span class="line">        <span class="comment">//注册点的触发事件，触发信息窗体</span></span><br><span class="line">      <span class="keyword">this</span>.markers.on(<span class="string">"mousemove"</span>, () =&gt; &#123;</span><br><span class="line">          <span class="comment">//定义信息窗体的div内容</span></span><br><span class="line">        <span class="keyword">this</span>.content =  </span><br><span class="line">    <span class="string">`&lt;div&gt;&lt;img src="<span class="subst">$&#123;data.photos&#125;</span>" style="width:100px; height:50px;margin:0 auto"&gt; </span></span><br><span class="line"><span class="string">    &lt;div&gt;&lt;b style="color:#666"&gt;<span class="subst">$&#123;data.name&#125;</span>&lt;/b&gt;`</span></span><br><span class="line">        <span class="comment">//重新设置信息窗体</span></span><br><span class="line">        <span class="keyword">this</span>.infoWindow = <span class="keyword">new</span> AMap.InfoWindow(&#123;</span><br><span class="line">            <span class="comment">//信息窗体相对于基点=》也就是经纬度的点 偏移的xy轴量</span></span><br><span class="line">          offset: <span class="keyword">new</span> AMap.Pixel(<span class="number">-5</span>, <span class="number">-50</span>),</span><br><span class="line">          content: <span class="keyword">this</span>.content <span class="comment">//传入 dom 对象，或者 html 字符串</span></span><br><span class="line">        &#125;);</span><br><span class="line">          <span class="comment">//设置信息窗体需要打开 ，参数是  这个地图this.map  和  position  打开的位置</span></span><br><span class="line">        <span class="keyword">this</span>.infoWindow.open(<span class="keyword">this</span>.map, position);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实际效果"><a href="#实际效果" class="headerlink" title="实际效果"></a>实际效果</h5><p><img src="https://raw.githubusercontent.com/wang-zhibiao/wang-zhibiao.github.io/master/img/%E5%9C%B0%E5%9B%BE.png" alt="地图"></p><h4 id="当你想要在地图外响应地图时"><a href="#当你想要在地图外响应地图时" class="headerlink" title="当你想要在地图外响应地图时"></a>当你想要在地图外响应地图时</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">     &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"traffic"</span>&gt;</span><br><span class="line">          &lt;ul&gt;</span><br><span class="line">         &lt;li v-<span class="keyword">for</span>=<span class="string">"(item,index) in sceneryMapdata"</span> :key=<span class="string">"index"</span> style=<span class="string">"cursor:pointer;"</span></span><br><span class="line">@mousemove=<span class="string">"choose(item)"</span>&gt;</span><br><span class="line">             &lt;span&gt;&#123;&#123;item.name&#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;span&gt;&#123;&#123;item.biz_ext.rating&#125;&#125;公里&lt;/</span>span&gt;</span><br><span class="line">&lt;<span class="regexp">/li&gt;     </span></span><br><span class="line"><span class="regexp">         &lt;/u</span>l&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">//地图的标签</span></span><br><span class="line">      activeName:<span class="string">"first"</span>,</span><br><span class="line">      <span class="comment">// 地图的数据</span></span><br><span class="line">      sceneryMapdata:<span class="literal">null</span>,</span><br><span class="line">       <span class="comment">//地图加载时间</span></span><br><span class="line">      loading:<span class="literal">true</span>,</span><br><span class="line">      <span class="comment">//地图窗体信息</span></span><br><span class="line">      content: <span class="string">"高级酒店"</span>,</span><br><span class="line">      map: <span class="literal">null</span>,</span><br><span class="line">      markers: <span class="literal">null</span>,</span><br><span class="line">      infoWindow: <span class="literal">null</span>,</span><br><span class="line">      center: [<span class="number">118.796623</span>, <span class="number">32.059352</span>]</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    <span class="comment">//触发地图的点</span></span><br><span class="line">    choose(data)&#123;</span><br><span class="line">       <span class="keyword">let</span> temp = data.location.split(<span class="string">","</span>);</span><br><span class="line">        temp = [temp[<span class="number">0</span>]<span class="number">-0</span>,temp[<span class="number">1</span>]<span class="number">-0</span>]</span><br><span class="line">        <span class="keyword">this</span>.content = data.name</span><br><span class="line">         <span class="keyword">this</span>.infoWindow = <span class="keyword">new</span> AMap.InfoWindow(&#123;</span><br><span class="line">          offset: <span class="keyword">new</span> AMap.Pixel(<span class="number">-5</span>, <span class="number">-50</span>),</span><br><span class="line">          content: <span class="keyword">this</span>.content <span class="comment">//传入 dom 对象，或者 html 字符串</span></span><br><span class="line">        &#125;);</span><br><span class="line">       <span class="keyword">this</span>.infoWindow.open(<span class="keyword">this</span>.map, temp);</span><br><span class="line">    </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//添加点标记</span></span><br><span class="line">    setMarker(markers, position, data) &#123;</span><br><span class="line">      <span class="keyword">this</span>.markers = <span class="keyword">new</span> AMap.Marker(&#123;</span><br><span class="line">        content: <span class="string">`&lt;div style="width:20px;height:28px;text-align:center;" class="el-icon-location"&gt;&lt;/div&gt;`</span>,</span><br><span class="line">        position: position,</span><br><span class="line">        offset: <span class="keyword">new</span> AMap.Pixel(<span class="number">-17</span>, <span class="number">-42</span>), <span class="comment">// 相对于基点的偏移位置</span></span><br><span class="line">        map: <span class="keyword">this</span>.map <span class="comment">//把点标记绑在前面初始化的 map_ 上，否则不显示</span></span><br><span class="line">      &#125;);</span><br><span class="line">       AMap.event.addListener(<span class="keyword">this</span>.markers,<span class="string">"mousemove"</span>, ()=&gt;&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = data.name;</span><br><span class="line">        <span class="keyword">this</span>.infoWindow = <span class="keyword">new</span> AMap.InfoWindow(&#123;</span><br><span class="line">          offset: <span class="keyword">new</span> AMap.Pixel(<span class="number">-5</span>, <span class="number">-50</span>),</span><br><span class="line">          content: <span class="keyword">this</span>.content <span class="comment">//传入 dom 对象，或者 html 字符串</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.infoWindow.open(<span class="keyword">this</span>.map, position);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    setMapInfo() &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;location&#125; = <span class="keyword">this</span>.sceneryMapdata[<span class="number">3</span>]</span><br><span class="line">      <span class="comment">//重新设置地图中心点</span></span><br><span class="line">      <span class="keyword">const</span> temp = location.split(<span class="string">","</span>);</span><br><span class="line">      <span class="keyword">this</span>.center = [temp[<span class="number">0</span>]<span class="number">-0</span>,temp[<span class="number">1</span>]<span class="number">-0</span>]</span><br><span class="line">      <span class="keyword">this</span>.map = <span class="keyword">new</span> AMap.Map(<span class="string">"detailMap"</span>, &#123;</span><br><span class="line">        zoom: <span class="number">14</span>, <span class="comment">//级别</span></span><br><span class="line">        center: <span class="keyword">this</span>.center, <span class="comment">//中心点坐标</span></span><br><span class="line">        viewMode: <span class="string">"3D"</span> <span class="comment">//使用3D视图</span></span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">this</span>.sceneryMapdata.forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//生成多个坐标点</span></span><br><span class="line">        <span class="keyword">let</span> str = v.location.split(<span class="string">","</span>);</span><br><span class="line">        <span class="keyword">this</span>.setMarker(v.name, [str[<span class="number">0</span>]<span class="number">-0</span>,str[<span class="number">1</span>]<span class="number">-0</span>], v);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//请求数据</span></span><br><span class="line">    getMapdata()&#123;</span><br><span class="line">      <span class="keyword">this</span>.$axios(&#123;</span><br><span class="line">      url:<span class="string">`https://restapi.amap.com/v3/place/text`</span>,</span><br><span class="line">      params:&#123;</span><br><span class="line">        keyword:<span class="string">''</span>,</span><br><span class="line">        location:<span class="string">"118.732841,32.077242"</span>,</span><br><span class="line">        city:<span class="string">"南京市"</span>,</span><br><span class="line">        types:<span class="string">"风景名胜"</span>,</span><br><span class="line">        output:<span class="string">'json'</span>,</span><br><span class="line">        page:<span class="number">1</span>,</span><br><span class="line">        offset:<span class="number">10</span>,</span><br><span class="line">        key:<span class="string">'key私人定制'</span>  <span class="comment">//=》 这个key是一个web服务 当你创建key可以选择</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.sceneryMapdata = res.data.pois</span><br><span class="line">    &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"> mounted() &#123;</span><br><span class="line">     setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setMapInfo();</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">    <span class="comment">//请求数据</span></span><br><span class="line">    <span class="keyword">this</span>.getMapdata()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;首先介绍一下vue与高德-之间的联系&quot;&gt;&lt;a href=&quot;#首先介绍一下vue与高德-之间的联系&quot; class=&quot;headerlink&quot; title=&quot;首先介绍一下vue与高德 之间的联系&quot;&gt;&lt;/a&gt;首先介绍一下vue与高德 之间的联系&lt;/h4&gt;&lt;p&gt;vue与数据
      
    
    </summary>
    
      <category term="vue-高德地图" scheme="http://wang-zhibiao.github.io/categories/vue-%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE/"/>
    
    
      <category term="javascript" scheme="http://wang-zhibiao.github.io/tags/javascript/"/>
    
      <category term="vue高德地图" scheme="http://wang-zhibiao.github.io/tags/vue%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>JS执行上下文</title>
    <link href="http://wang-zhibiao.github.io/2019/06/25/js%E4%B8%8A%E4%B8%8B%E6%96%87%E6%89%A7%E8%A1%8C/"/>
    <id>http://wang-zhibiao.github.io/2019/06/25/js上下文执行/</id>
    <published>2019-06-24T19:10:56.000Z</published>
    <updated>2019-07-24T09:55:58.262Z</updated>
    
    <content type="html"><![CDATA[<p>在开始说明JS上下文栈和作用域之前，我们先说明下JS上下文以及作用域的概念。<br>执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。<br>执行上下文类型分为：<br>全局执行上下文<br>函数执行上下文<br>执行上下文创建过程中，需要做以下几件事:<br>创建变量对象：首先初始化函数的参数arguments，提升函数声明和变量声明。<br>创建作用域链（Scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。<br>确定this的值，即 ResolveThisBinding<br>作用域<br><strong>作用域</strong>负责收集和维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。—— 摘录自《你不知道的JavaScript》(上卷)<br>作用域有两种工作模型：词法作用域和动态作用域，JS采用的是<strong>词法作用域</strong>工作模型，词法作用域意味着作用域是由书写代码时变量和函数声明的位置决定的。(<code>with</code> 和 <code>eval</code> 能够修改词法作用域，但是不推荐使用，对此不做特别说明)<br>作用域分为：<br>全局作用域<br>函数作用域<br>块级作用域<br>JS执行上下文栈(后面简称执行栈)<br>执行栈，也叫做调用栈，具有 <strong>LIFO</strong> (后进先出) 结构，用于存储在代码执行期间创建的所有执行上下文。<br>规则如下：<br>首次运行JavaScript代码的时候,会创建一个全局执行的上下文并Push到当前的执行栈中，每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push当前执行栈的栈顶。<br>当栈顶的函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文的控制权将移动到当前执行栈的下一个执行上下文。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">first()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'first'</span>)</span><br><span class="line">&#125;</span><br><span class="line">second()&#123;</span><br><span class="line">    first()</span><br><span class="line">&#125;</span><br><span class="line">third()&#123;</span><br><span class="line">    second()</span><br><span class="line">&#125;</span><br><span class="line">third()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在开始说明JS上下文栈和作用域之前，我们先说明下JS上下文以及作用域的概念。&lt;br&gt;执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。&lt;br&gt;执行上下文类型分为：&lt;br&gt;全局执行上
      
    
    </summary>
    
      <category term="知识" scheme="http://wang-zhibiao.github.io/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="javascript" scheme="http://wang-zhibiao.github.io/tags/javascript/"/>
    
      <category term="function" scheme="http://wang-zhibiao.github.io/tags/function/"/>
    
  </entry>
  
  <entry>
    <title>JS全局污染</title>
    <link href="http://wang-zhibiao.github.io/2019/06/20/JS%E5%85%A8%E5%B1%80%E6%B1%A1%E6%9F%93/"/>
    <id>http://wang-zhibiao.github.io/2019/06/20/JS全局污染/</id>
    <published>2019-06-20T11:50:59.000Z</published>
    <updated>2019-07-01T01:20:12.648Z</updated>
    
    <content type="html"><![CDATA[<p>所谓全局变量污染 ：定义多个全局变量，函数，对象挂载在window上，如果重复使用则造成变量冲突</p><p>如果定义一个全局变量则会在window上挂载这个变量，所有的函数，对象，引用此js文件的都可以使用，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/输出</span></span><br><span class="line"><span class="regexp">Window</span></span><br><span class="line"><span class="regexp">a: 10</span></span><br><span class="line"><span class="regexp">alert: ƒ alert()</span></span><br><span class="line"><span class="regexp">applicationCache: ApplicationCache &#123;status: 0, oncached: null, onchecking: null, ondownloading: null, onerror: null, …&#125;</span></span><br><span class="line"><span class="regexp">。。。。。。。</span></span><br></pre></td></tr></table></figure><h3 id="污染"><a href="#污染" class="headerlink" title="污染"></a>污染</h3><p>如同衣物沾上污渍，笔墨落入清水。</p><p>全局window是大家都能使用，如果在全局挂载变量太多，难免会调用重复的变量，改变其属性或值。</p><p>在开发中，多人共同开发，每个人的代码习惯不同，命名方法不同，如果其他人命名一个变量ID，那么，在调用ID时会改变上一个人的ID导致不是自己想要的ID。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//developer_first.js</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> ID = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(ID);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/developer_second.js</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    var ID = 2;</span></span><br><span class="line"><span class="regexp">console.log(ID);</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line"><span class="comment">//developer_thirdly.js</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> ID = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(ID);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/在主文件中调用</span></span><br><span class="line"><span class="regexp">&lt;head&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="developer_first.js"&gt;&lt;/</span>script&gt;</span><br><span class="line">&lt;script src=<span class="string">"developer_second.js"</span>&gt;&lt;/script&gt;  </span><br><span class="line">&lt;script src=<span class="string">"developer_thirdly.js"</span>&gt;&lt;/script&gt;   <span class="comment">//最后的</span></span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/=&gt;输出  4 4 4</span></span><br></pre></td></tr></table></figure><p>ID会使用最后调用的js文件</p><p>为了避免全局污染，应慎重使用全局变量。了解模块化，或者let 定义的let不在window里 在script内有效</p><p>或者函数{}内有效，形成块级作用域</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;所谓全局变量污染 ：定义多个全局变量，函数，对象挂载在window上，如果重复使用则造成变量冲突&lt;/p&gt;
&lt;p&gt;如果定义一个全局变量则会在window上挂载这个变量，所有的函数，对象，引用此js文件的都可以使用，&lt;/p&gt;
&lt;figure class=&quot;highlight j
      
    
    </summary>
    
      <category term="javascript" scheme="http://wang-zhibiao.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://wang-zhibiao.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>js常见的继承方式</title>
    <link href="http://wang-zhibiao.github.io/2019/06/20/js%E7%9A%84%E5%85%AD%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/"/>
    <id>http://wang-zhibiao.github.io/2019/06/20/js的六种继承方式/</id>
    <published>2019-06-20T01:10:56.000Z</published>
    <updated>2019-07-14T01:29:05.728Z</updated>
    
    <content type="html"><![CDATA[<p>js中的继承：在js中的继承只是属性和方法的继承 一般没有所谓的多态性，js的继承只是为了使代码的复用性更高。</p><h3 id="js的继承是通过prototype来继承的"><a href="#js的继承是通过prototype来继承的" class="headerlink" title="js的继承是通过prototype来继承的"></a>js的继承是通过prototype来继承的</h3><h4 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1 原型链继承"></a>1 原型链继承</h4><p>这种方式关键在于:**子类型的原型为父类型的一个实例对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//父类型</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name,</span><br><span class="line">    <span class="keyword">this</span>.age = age,</span><br><span class="line">    <span class="keyword">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Person.prototype.setAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="comment">//子类型</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.price = price</span><br><span class="line">    <span class="keyword">this</span>.setScore = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// Student.prototype.sayHello = function () &#123; &#125;//在这里写子类的原型方法和属性是无效的，</span></span><br><span class="line"><span class="comment">//因为会改变原型的指向，所以应该放到重新指定之后</span></span><br><span class="line">  Student.prototype = <span class="keyword">new</span> Person() <span class="comment">// 子类型的原型为父类型的一个实例对象</span></span><br><span class="line">  <span class="keyword">var</span> s1 = <span class="keyword">new</span> Student(<span class="number">15000</span>)</span><br><span class="line">  <span class="keyword">var</span> s2 = <span class="keyword">new</span> Student(<span class="number">14000</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(s1,s2)</span><br></pre></td></tr></table></figure><p>说明：定义一个Person父类型拥有对象和方法   <code>Person.prototype.setAge = function () {}</code> 这是一种在外部定义的一个在prototype原型上的方法 原理：每个function身上都有一个原型 在原型身上可以挂载方法和属性</p><p><code>Student.prototype = new Person()</code>  Student原型指向Person的实例对象，所以<strong>子类的实例就可以通过proto__访问到 Student.prototype 也就是Person的实例，这样就可以访问到父类的私有方法，然后再通过__proto指向父类的prototype就可以获得到父类原型上的方法</strong>。于是做到了将父类的私有、公有方法和属性都当做子类的公有属性</p><p>弊端：<strong>子类继承父类的属性和方法是将父类的私有属性和公有方法都作为自己的公有属性和方法</strong> 如果父类的私有属性有引用类型，子类继承的是这个父类的引用地址 如果子类操作父类的引用类型就会导致引用类型改变详情请看 <a href="[https://wang-zhibiao.github.io/2019/06/09/%E5%8F%98%E9%87%8F%E5%92%8Cjs%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3/](https://wang-zhibiao.github.io/2019/06/09/%E5%8F%98%E9%87%8F%E5%92%8Cjs%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3/)**">js数据类型</a></p><p><strong>我们需要在子类中添加新的方法或者是重写父类的方法时候，切记一定要放到替换原型的语句之后</strong></p><h4 id="2-借用构造函数继承"><a href="#2-借用构造函数继承" class="headerlink" title="2  借用构造函数继承"></a>2  借用构造函数继承</h4><p>这种方式关键在于:<strong>在子类型构造函数中通用call()调用父类型构造函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name,</span><br><span class="line">  <span class="keyword">this</span>.age = age,</span><br><span class="line">  <span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, price</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, name, age)  <span class="comment">// 相当于: this.Person(name, age)</span></span><br><span class="line">  <span class="comment">/*this.name = name</span></span><br><span class="line"><span class="comment">  this.age = age*/</span></span><br><span class="line">  <span class="keyword">this</span>.price = price</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Student(<span class="string">'Tom'</span>, <span class="number">20</span>, <span class="number">15000</span>)</span><br></pre></td></tr></table></figure><p>说明：在Student中构造Person的属性和方法，但是只是实现部分继承，如果父类的属性和方法太多，继承麻烦。但是解决了引用类型的问题因为这个构造函数是再次创建实例</p><p>弊端：子类的实例是根据父类的实例重新构造的，<strong>只能继承父类的实例属性和方法，不能继承原型属性和方法</strong> 代码复用性弱，每个子类都是父类的实例函数副本，影响性能</p><h4 id="3-原型链-借用构造函数的组合继承"><a href="#3-原型链-借用构造函数的组合继承" class="headerlink" title="3 原型链+借用构造函数的组合继承"></a>3 原型链+借用构造函数的组合继承</h4><p>这种方式关键在于:<strong>通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</strong> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name,</span><br><span class="line">  <span class="keyword">this</span>.age = age,</span><br><span class="line">  <span class="keyword">this</span>.setAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"111"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span> (<span class="params">name, age, price</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//第一次调用构造函数</span></span><br><span class="line">  Person.call(<span class="keyword">this</span>, name, age)</span><br><span class="line">  <span class="keyword">this</span>.price = price</span><br><span class="line">  <span class="keyword">this</span>.setScore = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 令Student的原型指向Person的实例</span></span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person()</span><br><span class="line">Student.prototype.constructor = Student<span class="comment">//组合继承也是需要修复构造函数指向的</span></span><br><span class="line">Student.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Student(<span class="string">'Tom'</span>, <span class="number">20</span>, <span class="number">15000</span>)</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> Student(<span class="string">'Jack'</span>, <span class="number">22</span>, <span class="number">14000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1)</span><br><span class="line"><span class="built_in">console</span>.log(s1.constructor) <span class="comment">//Student</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.constructor) <span class="comment">//Person</span></span><br></pre></td></tr></table></figure><p>说明：在子类中调用构造函数生成实例对象但是只是包含属性，在子类的原型链上继承Person的实例，再次使用构造函数，是刚继承的实例构造成一个新的实例赋值 这个实例属于Student  构造函数（constructor） –字面意思，能构造一个实例的函数 </p><p>弊端：无论如何都会调用两次构造函数，创建子类的原型和子类构造函数内部</p><h4 id="4-组合继承的优化-原型指向"><a href="#4-组合继承的优化-原型指向" class="headerlink" title="4 组合继承的优化-原型指向"></a>4 组合继承的优化-原型指向</h4><p>这种方式关键在于 <strong>通过父类原型和子类原型指向同一对象，子类可以继承到父类的公有方法当做自己的公有方法，而且不会初始化两次实例方法/属性，避免的组合继承的缺点</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name,</span><br><span class="line">  <span class="keyword">this</span>.age = age,</span><br><span class="line">  <span class="keyword">this</span>.setAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"111"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span> (<span class="params">name, age, price</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  Person.call(<span class="keyword">this</span>, name, age)</span><br><span class="line">  <span class="keyword">this</span>.price = price</span><br><span class="line">  <span class="keyword">this</span>.setScore = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原型的赋值</span></span><br><span class="line">Student.prototype = Person.prototype</span><br><span class="line">Student.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Student(<span class="string">'Tom'</span>, <span class="number">20</span>, <span class="number">15000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1)</span><br></pre></td></tr></table></figure><p>说明：原型的赋值会让两个类指向同一个对象 ，与上面的区别在于一个是构造函数的赋值 这是原型的赋值，不会生成两次实例</p><p>弊端：父类指向不明，都是原型的赋值 同一个对象，没有父子关系，引用类型问题，</p><h4 id="5-组合继承的优化-创建对象"><a href="#5-组合继承的优化-创建对象" class="headerlink" title="5 组合继承的优化-创建对象"></a>5 组合继承的优化-创建对象</h4><p>这种方式关键在于 <strong>借助原型可以基于已有的对象来创建对象，var B = Object.create(A)以A对象为原型，生成了B对象。B继承了A的所有属性和方法</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name,</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"111"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span> (<span class="params">name, age, price</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  Person.call(<span class="keyword">this</span>, name, age)</span><br><span class="line">  <span class="keyword">this</span>.price = price</span><br><span class="line">  <span class="keyword">this</span>.setScore = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = <span class="built_in">Object</span>.create(Person.prototype)<span class="comment">//核心代码</span></span><br><span class="line">Student.prototype.constructor = Student<span class="comment">//核心代码</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Student(<span class="string">'Tom'</span>, <span class="number">20</span>, <span class="number">15000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1 <span class="keyword">instanceof</span> Student, s1 <span class="keyword">instanceof</span> Person) <span class="comment">// true true</span></span><br><span class="line"><span class="built_in">console</span>.log(s1.constructor) <span class="comment">//Student</span></span><br><span class="line"><span class="built_in">console</span>.log(s1)</span><br></pre></td></tr></table></figure><p>说明：<code>Student.prototype = Object.create(Person.prototype)</code> 创建一个基于Person的的prototype创建一个新的对象给Student，继承Person 的所有的属性和方法 （Object.create）Object身上挂载create这个方法可以创建新的对象</p><p>目前来说，使用缺点都解决了，但是还未趋近完美</p><h4 id="6-Es6的class继承"><a href="#6-Es6的class继承" class="headerlink" title="6 Es6的class继承"></a>6 Es6的class继承</h4><p>ES6中引入了class关键字，class可以通过extends关键字实现继承，还可以通过static关键字定义类的静态方法,这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p><p>ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。</p><p><strong>需要注意的是，class关键字只是原型的语法糖，JavaScript继承仍然是基于原型实现的</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">//调用类的构造方法</span></span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//定义一般的方法</span></span><br><span class="line">  showName () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"调用父类的方法"</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person(<span class="string">'kobe'</span>, <span class="number">39</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1)</span><br><span class="line"><span class="comment">//定义一个子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age, salary) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name, age)<span class="comment">//通过super调用父类的构造方法</span></span><br><span class="line">    <span class="keyword">this</span>.salary = salary</span><br><span class="line">  &#125;</span><br><span class="line">  showName () &#123;<span class="comment">//在子类自身定义方法</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"调用子类的方法"</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age, <span class="keyword">this</span>.salary);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> Student(<span class="string">'wade'</span>, <span class="number">38</span>, <span class="number">1000000000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1)</span><br><span class="line">s1.showName()</span><br></pre></td></tr></table></figure><p>说明：本质上原型和class没有区别，但是代码的整洁可读性更高 ，super相当于原型继承的 <code>Person.call(this, name, age)</code> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;js中的继承：在js中的继承只是属性和方法的继承 一般没有所谓的多态性，js的继承只是为了使代码的复用性更高。&lt;/p&gt;
&lt;h3 id=&quot;js的继承是通过prototype来继承的&quot;&gt;&lt;a href=&quot;#js的继承是通过prototype来继承的&quot; class=&quot;header
      
    
    </summary>
    
      <category term="js高级" scheme="http://wang-zhibiao.github.io/categories/js%E9%AB%98%E7%BA%A7/"/>
    
    
      <category term="javascript" scheme="http://wang-zhibiao.github.io/tags/javascript/"/>
    
      <category term="function" scheme="http://wang-zhibiao.github.io/tags/function/"/>
    
  </entry>
  
  <entry>
    <title>vue组件传值</title>
    <link href="http://wang-zhibiao.github.io/2019/06/15/vue%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/"/>
    <id>http://wang-zhibiao.github.io/2019/06/15/vue组件传值/</id>
    <published>2019-06-15T04:10:56.000Z</published>
    <updated>2019-07-24T09:57:14.861Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1父传子"><a href="#1父传子" class="headerlink" title="1父传子"></a>1父传子</h3><p>通过父组件定义动态绑定一个数据来给子组件传递数据  ，子组件通过props来接受数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:data=<span class="string">"data"</span>  =&gt;&gt; props:&#123;data&#125;  &gt;&gt;&gt;&gt;直接在template中使用data</span><br></pre></td></tr></table></figure><h4 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">father</span>&gt;</span><span class="tag">&lt;/<span class="name">father</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">'father'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"father"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是父组件&#123;&#123;fname&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>我要告诉我儿子其实他是&#123;&#123;type&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">son</span> <span class="attr">:mytype</span>=<span class="string">"type"</span>&gt;</span><span class="tag">&lt;/<span class="name">son</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">'son'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"son"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是子组件&#123;&#123;sname&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>我的老爸告诉我我其实是&#123;&#123;mytype&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 创建父组件</span></span></span><br><span class="line"><span class="javascript">        Vue.component(<span class="string">'father'</span>, &#123;</span></span><br><span class="line"><span class="javascript">            template: <span class="string">'#father'</span>,</span></span><br><span class="line">            data() &#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                    fname:<span class="string">'老爸'</span>,</span></span><br><span class="line"><span class="javascript">                    type:<span class="string">'穷二代'</span></span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            <span class="comment">// 通过components来创建子组件,可以创建多个</span></span></span><br><span class="line">            components: &#123;</span><br><span class="line"><span class="javascript">                <span class="string">'son'</span>: &#123;</span></span><br><span class="line"><span class="javascript">                    template: <span class="string">'#son'</span>,</span></span><br><span class="line"><span class="javascript">                    props:[<span class="string">'mytype'</span>],</span></span><br><span class="line">                    data() &#123;</span><br><span class="line"><span class="javascript">                        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                            sname:<span class="string">'小明'</span>,</span></span><br><span class="line"><span class="javascript">                            <span class="comment">// mytype:'??'</span></span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#app'</span>,</span></span><br><span class="line">            data: &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2子传父"><a href="#2子传父" class="headerlink" title="2子传父"></a>2子传父</h3><p>通过子组件发射（$emit）数据 父组件接受数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$emit(事件名称,你想传递的数据) =&gt;&gt;父组件监听这个事件（@/v-on）  @事件名称=“方法（参数）” =&gt;&gt;这个方法默认参数就是传递的数据</span><br></pre></td></tr></table></figure><h4 id="具体例子-1"><a href="#具体例子-1" class="headerlink" title="具体例子"></a>具体例子</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">father</span>&gt;</span> <span class="tag">&lt;/<span class="name">father</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">'father'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"father"</span> <span class="attr">style</span>=<span class="string">'border:solid 1px'</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是父组件&#123;&#123;fname&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>我的儿子告诉我他的女朋友的名字叫&#123;&#123;erxifu&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- &lt;son v-on:getname='ok'&gt;&lt;/son&gt; --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">son</span> @<span class="attr">getname</span>=<span class="string">'ok'</span>&gt;</span><span class="tag">&lt;/<span class="name">son</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">'son'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"son"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是子组件&#123;&#123;sname&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">'tellname'</span>&gt;</span>点击告诉我老爸我的女朋友叫&#123;&#123;mygfname&#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 创建父组件</span></span></span><br><span class="line"><span class="javascript">        Vue.component(<span class="string">'father'</span>, &#123;</span></span><br><span class="line"><span class="javascript">            template: <span class="string">'#father'</span>,</span></span><br><span class="line">            data() &#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                    fname:<span class="string">'老爸'</span>,</span></span><br><span class="line"><span class="javascript">                    erxifu:<span class="string">'??'</span></span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line"><span class="javascript">                <span class="comment">// 这个事件处理函数默认有一个参数,这个参数就是之前事件传递的数据</span></span></span><br><span class="line">                ok(data)&#123;</span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(data)</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">this</span>.erxifu = data</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            <span class="comment">// 通过components来创建子组件,可以创建多个</span></span></span><br><span class="line">            components: &#123;</span><br><span class="line"><span class="javascript">                <span class="string">'son'</span>: &#123;</span></span><br><span class="line"><span class="javascript">                    template: <span class="string">'#son'</span>,</span></span><br><span class="line">                    data() &#123;</span><br><span class="line"><span class="javascript">                        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                            sname:<span class="string">'小明'</span>,</span></span><br><span class="line"><span class="javascript">                            mygfname:<span class="string">'小红'</span></span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    methods:&#123;</span><br><span class="line">                        tellname()&#123;</span><br><span class="line"><span class="javascript">                            <span class="comment">// 发射一个事件</span></span></span><br><span class="line"><span class="javascript">                            <span class="comment">// this.$emit(事件名称,你想传递的数据)</span></span></span><br><span class="line"><span class="javascript">                            <span class="comment">// 数据可以是任意数据</span></span></span><br><span class="line"><span class="javascript">                            <span class="keyword">this</span>.$emit(<span class="string">'getname'</span>,<span class="keyword">this</span>.mygfname)</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#app'</span>,</span></span><br><span class="line">            data: &#123;</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            mounted()&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span></span></span><br></pre></td></tr></table></figure><h3 id="3子传子"><a href="#3子传子" class="headerlink" title="3子传子"></a>3子传子</h3><p>通过事件总线传值，子组件通过事件总线对象发射数据，父组件接受数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bus = <span class="keyword">new</span> Vue() = <span class="string">"创建vue事件总线"</span> =&gt;&gt; 子组件通过bus.$emit(事件名称,你想传递的数据) ==&gt;&gt;兄弟组件通过bus.$on(事件名称,(传递过来的数据)=&gt;&#123;</span><br><span class="line">  处理逻辑</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="具体例子-2"><a href="#具体例子-2" class="headerlink" title="具体例子"></a>具体例子</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">father</span>&gt;</span>  <span class="tag">&lt;/<span class="name">father</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">'father'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"father"</span> <span class="attr">style</span>=<span class="string">'border:solid 1px'</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是父组件&#123;&#123;fname&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">son</span>&gt;</span><span class="tag">&lt;/<span class="name">son</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dauther</span>&gt;</span><span class="tag">&lt;/<span class="name">dauther</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">'son'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"son"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是儿子组件&#123;&#123;sname&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>我的妹妹回来了,跟我说她的男朋友叫:&#123;&#123;meifu&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">'dauther'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dauther"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是女儿组件&#123;&#123;dname&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">'tellname'</span>&gt;</span>点击向我哥哥炫耀我的男朋友的名字叫&#123;&#123;mybfname&#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 创建一个事件总线</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> bus = <span class="keyword">new</span> Vue()</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 创建父组件</span></span></span><br><span class="line"><span class="javascript">        Vue.component(<span class="string">'father'</span>, &#123;</span></span><br><span class="line"><span class="javascript">            template: <span class="string">'#father'</span>,</span></span><br><span class="line">            data() &#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                    fname: <span class="string">'老爸'</span></span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            <span class="comment">// 通过components来创建子组件,可以创建多个</span></span></span><br><span class="line">            components: &#123;</span><br><span class="line"><span class="javascript">                <span class="string">'son'</span>: &#123;</span></span><br><span class="line"><span class="javascript">                    template: <span class="string">'#son'</span>,</span></span><br><span class="line">                    data() &#123;</span><br><span class="line"><span class="javascript">                        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                            sname: <span class="string">'小明'</span>,</span></span><br><span class="line"><span class="javascript">                            meifu:<span class="string">'??'</span></span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line"><span class="javascript">                    <span class="comment">// 在mounTed钩子函数中进行事件的监听</span></span></span><br><span class="line">                    mounted()&#123;</span><br><span class="line"><span class="javascript">                        <span class="comment">// 通过事件总线的$on进行事件的监听</span></span></span><br><span class="line"><span class="javascript">                        <span class="comment">// 事件处理函数默认有一个参数,就是传递的数据</span></span></span><br><span class="line"><span class="javascript">                        bus.$on(<span class="string">'getname'</span>,(data) =&gt;　&#123;</span></span><br><span class="line"><span class="javascript">                            <span class="built_in">console</span>.log(data) </span></span><br><span class="line"><span class="javascript">                            <span class="keyword">this</span>.meifu = data</span></span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line"><span class="javascript">                <span class="string">'dauther'</span>: &#123;</span></span><br><span class="line"><span class="javascript">                    template: <span class="string">'#dauther'</span>,</span></span><br><span class="line">                    data() &#123;</span><br><span class="line"><span class="javascript">                        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                            dname: <span class="string">'小红'</span>,</span></span><br><span class="line"><span class="javascript">                            mybfname:<span class="string">'狗蛋'</span></span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    methods:&#123;</span><br><span class="line"><span class="javascript">                        <span class="comment">// 通过事件总线发射一个事件</span></span></span><br><span class="line">                        tellname()&#123;</span><br><span class="line"><span class="javascript">                            bus.$emit(<span class="string">'getname'</span>,<span class="keyword">this</span>.mybfname)</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#app'</span>,</span></span><br><span class="line">            data: &#123;</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            mounted() &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1父传子&quot;&gt;&lt;a href=&quot;#1父传子&quot; class=&quot;headerlink&quot; title=&quot;1父传子&quot;&gt;&lt;/a&gt;1父传子&lt;/h3&gt;&lt;p&gt;通过父组件定义动态绑定一个数据来给子组件传递数据  ，子组件通过props来接受数据&lt;/p&gt;
&lt;figure class=&quot;
      
    
    </summary>
    
      <category term="vue基础" scheme="http://wang-zhibiao.github.io/categories/vue%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="javascript" scheme="http://wang-zhibiao.github.io/tags/javascript/"/>
    
      <category term="vue" scheme="http://wang-zhibiao.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>来自平时的笔记</title>
    <link href="http://wang-zhibiao.github.io/2019/06/12/%E6%9D%A5%E8%87%AA%E5%B9%B3%E6%97%B6%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
    <id>http://wang-zhibiao.github.io/2019/06/12/来自平时的笔记/</id>
    <published>2019-06-11T16:00:00.000Z</published>
    <updated>2019-07-24T09:57:47.299Z</updated>
    
    <content type="html"><![CDATA[<h4 id="隐藏元素："><a href="#隐藏元素：" class="headerlink" title="隐藏元素："></a>隐藏元素：</h4><p>（1）visibility: hidden;   隐藏元素，占位置<br>（2）display: none;        隐藏元素，不占位置<br>（3）宽高设为0</p><h4 id="显示元素："><a href="#显示元素：" class="headerlink" title="显示元素："></a>显示元素：</h4><p> 与对应的隐藏属性用相同的属性，只不过值不同<br>（1）visibility: visible    将隐藏的元素显示<br>（2）display:   block     将隐藏的元素显示，并能改变元素的显示方式</p><h4 id="鼠标样式："><a href="#鼠标样式：" class="headerlink" title="鼠标样式："></a>鼠标样式：</h4><p>cursor: pointer;     /<em>鼠标小手</em>/cursor: text;          /<em>文本光标</em>/cursor: move;      /<em>移动光标</em>/cursor: help;        /<em>鼠标小手</em>/    </p><h4 id="溢出文本处理"><a href="#溢出文本处理" class="headerlink" title="溢出文本处理"></a>溢出文本处理</h4><p>overflow: hidden;<br>overflow: visible;<br>overflow: auto;<br>overflow: scroll;</p><h4 id="使用省略号替代溢出文本"><a href="#使用省略号替代溢出文本" class="headerlink" title="使用省略号替代溢出文本"></a>使用省略号替代溢出文本</h4><p>*必须让文本在一行显示，不能换行：<br>white-space: nowrap;<br>*溢出隐藏：<br>overflow: hidden;<br>*使用省略号替代文本：<br>text-overflow: ellipsis;</p><h4 id="设置文本间距："><a href="#设置文本间距：" class="headerlink" title="设置文本间距："></a>设置文本间距：</h4><p>letter-spacing: 10px;     设置文字之间的间距<br>word-spacing: 10px;     设置每个单词之间的间距</p><h4 id="外轮廓线：outline-不占外边距位置-不影响盒子大小和距离"><a href="#外轮廓线：outline-不占外边距位置-不影响盒子大小和距离" class="headerlink" title="外轮廓线：outline(不占外边距位置)不影响盒子大小和距离"></a>外轮廓线：outline(不占外边距位置)不影响盒子大小和距离</h4><p>outline: none;<br>outline: 1px  solid  #fff;</p><h4 id="防止文本域（textarea）拖拽改变大小："><a href="#防止文本域（textarea）拖拽改变大小：" class="headerlink" title="防止文本域（textarea）拖拽改变大小："></a>防止文本域（textarea）拖拽改变大小：</h4><p>textarea {<br>    resize: none;<br>}</p><h4 id="垂直对齐方式：（只对行内元素和行内块级元素有效）"><a href="#垂直对齐方式：（只对行内元素和行内块级元素有效）" class="headerlink" title="垂直对齐方式：（只对行内元素和行内块级元素有效）"></a>垂直对齐方式：（只对行内元素和行内块级元素有效）</h4><p>verical-algin: middle;      ***设置图片、input按钮与输入框等和文本的垂直对齐<br>verical-algin: top;                设置顶线对齐</p><p>固定定位：*****注意:对于脱标的元素宽不会在和父元素一行宽，我们需要设置宽度或者有内容撑出来宽度</p><p>透明属性值：transparent</p><h4 id="Html5新增的标签："><a href="#Html5新增的标签：" class="headerlink" title="Html5新增的标签："></a>Html5新增的标签：</h4><p>​     audio:      音频标签：     <audio src="./images/1.mp3" controls autoplay loop></audio><br>​                        属性值：  controls控件，autoplay自动播放，loop循环播放可以设置循环次数</p><h4 id="Html5中新增的标签属性："><a href="#Html5中新增的标签属性：" class="headerlink" title="Html5中新增的标签属性："></a>Html5中新增的标签属性：</h4><p>​        placeholder=””<br>​         multiple<br>​         required<br>​    autofocus  自动聚焦，文本光标停留位置</p><h4 id="Html5中新增的input属性的值："><a href="#Html5中新增的input属性的值：" class="headerlink" title="Html5中新增的input属性的值："></a>Html5中新增的input属性的值：</h4><p>​    搜索：type=”search”   移动端下面的键盘ENTER自动变成搜索<br>​    电话：type=”tel”         移动端下的键盘自动切换数字键盘<br>​    日期：type=”datetime”移动端显示日期滑动条</p><h4 id="文字阴影属性："><a href="#文字阴影属性：" class="headerlink" title="文字阴影属性："></a>文字阴影属性：</h4><p>​    text-shadow:1px 2px 5px color；   text-shadow:水平阴影，垂直阴影，阴影模糊度，阴影颜色<br>​    </p><h4 id="开发项目流程："><a href="#开发项目流程：" class="headerlink" title="开发项目流程："></a>开发项目流程：</h4><p>​    1.项目立项：产品的需求文档（产品经理）<br>​    2.产品原型图——UI针对其出设计稿<br>​       ***我们这边会做项目结构搭建——开会：技术选型（确定项目中使用的主要技术点——项目的规范文档（例如：京东：jd_xxx）——项目任务分配——项目开发ing（多交流，多沟通）——测试（功能，代码）——上线——后期的维护，版本更新，迭代<br>合资（外资企业）：<br>​    日资：<br>​        看着文档翻译<br>​    德资：<br>​    美资：</p><h4 id="属性书写顺序："><a href="#属性书写顺序：" class="headerlink" title="属性书写顺序："></a>属性书写顺序：</h4><p>​    1.布局定位属性：display / position / float / clear(建议display第一个写，毕竟关系到模式)<br>​    2.自身属性：<br>​    3.文本属性：<br>​    4.其他属性（CSS3）：content</p><h4 id="引入外部样式顺序：兼容CSS——初始化CSS——公共CSS——当前页面CSS"><a href="#引入外部样式顺序：兼容CSS——初始化CSS——公共CSS——当前页面CSS" class="headerlink" title="引入外部样式顺序：兼容CSS——初始化CSS——公共CSS——当前页面CSS"></a>引入外部样式顺序：兼容CSS——初始化CSS——公共CSS——当前页面CSS</h4><p>字体图标：一种字体类型（我们自己定义的）——主要针对于手机端<br>    开发：让设计做一些这样的图标——前端开发将这样的图标通过工具生成一种字体——打包上传到服务器——下载<br>现成字体图标网址：<a href="http://www.iconfont.cn" target="_blank" rel="noopener">www.iconfont.cn</a></p><h4 id="文本修饰："><a href="#文本修饰：" class="headerlink" title="文本修饰："></a>文本修饰：</h4><p>​    水平位置设置： text-align： left   center  right        对于独占一行的元素，设置文本水平居中，将text-align属性设置给元素本身就行了<br>​                                  如果是一行可以显示多个的这样的元素，我们要设置文本水平居中，我们需要给这个元素的父元素设置text-align属性<br>​    垂直位置设置：行高    line-height: 300px;            当盒子高度等于行高的时候，盒子中的单行文本垂直居中<br>​    文本首行缩进：  text-indent：<br>​                   注意：em单位   相对长度单位。  相对的元素本身的字体大小<br>​    文本修饰线： text-decoration：  none  去除默认的修饰线<br>​                        underline下划线        overline上划线    line-through中划线</p><h4 id="修改定位元素的层级："><a href="#修改定位元素的层级：" class="headerlink" title="修改定位元素的层级："></a>修改定位元素的层级：</h4><p>​    所有元素默认层级属性值是1<br>​    z-index: 1;<br>​    **1.层级只对非静态定位有效<br>​        2.如果都是非静态定位的元素，后面的元素的层级默认比前面的元素的层级高</p><h4 id="做项目遵循单一性原则："><a href="#做项目遵循单一性原则：" class="headerlink" title="做项目遵循单一性原则："></a>做项目遵循单一性原则：</h4><p>​    在项目中尽可能的让每一块的功能单一——为了程序的可拓展性和代码的复用；</p><p>在页面title处引入icon图标：<br>icon图标:网页head里的title显示<br>    截取网页的icon图标，在网页后面加上/favicon.ico<br>    引入页面的title部分的icon图标：<br>        &lt;link rel=”shortcut icon” href=”./favicon.ico”</p><h4 id="在线制作icon图标"><a href="#在线制作icon图标" class="headerlink" title="在线制作icon图标"></a>在线制作icon图标</h4><p>​        网址：比特虫  <a href="http://www.bitbug.net" target="_blank" rel="noopener">www.bitbug.net</a></p><h4 id="结构伪类选择器："><a href="#结构伪类选择器：" class="headerlink" title="结构伪类选择器："></a>结构伪类选择器：</h4><p>​    ：nth-child（n）<strong>***</strong>n=odd基数  n=even偶数<br>​    ：nth-child（-n+几）   前几个<br>​    ：nth-last-child（-n+几）后几个</p><p>outline: 外边框线不占位置，商品hover时显示边框可用</p><p><strong>p标签里面不能嵌套ul标签</strong></p><p>怎么修改placeholder默认颜色？</p><p>  input::placeholder{<em>/\</em> 去掉私有前缀，谷歌和火狐有效；IE和edge无效 */*color: orchid;<br>opacity:1;<br>font-size: 15px;<br>}</p><p><strong><strong>****</strong></strong>盒子模型分为几个部分：3个！！！！！！！外边距不算！！！<br>    1.旧的盒子模型——计算宽度<br>        width = 边框 + 内边距 + 内容<br>    2.新的盒子模型——   box-sizing:border-box;(内减模式)<br>        改变边框和改变内边距都不会导致盒子的宽度发生改变<br>        width = 边框 + 内边距 + 内容<br>        内减模式——内容减少的模式<br>        以后再写任何页面除非是ie8及以下，  都可以使用内减模式<br>        * ***** {<br>            margin: 0;<br>            padding: 0;<br>            box-sizing: border-box;<br>            快捷写法：  bz<br>        }</p><h4 id="3种改变元素坐标的技术有哪些："><a href="#3种改变元素坐标的技术有哪些：" class="headerlink" title="3种改变元素坐标的技术有哪些："></a>3种改变元素坐标的技术有哪些：</h4><p>​    1.定位——绝对定位——top left<br>​    2.外边距——margin<br>​    3.平移——translate<br><strong>*****</strong>区别：<br>​    1.margin和定位加的长度单位——px<br>​    2.margin和定位也可以用百分比单位——%<br>​        百分比相对于父元素的宽度计算<br>​    3.平移也可以用百分比单位——%<br>​        百分比相对于自身的宽度或者高度<br><strong>*****</strong>后期盒子中的盒子水平垂直居中显示可以用定位position的%和平移translate的%一起用来实现<br><strong><strong>**</strong></strong>布局的时候，属性的使用顺序：<br>​        1.大的布局，先用定位<br>​        2.微调的效果：（1）margin——挤压相邻的元素<br>​                  （2）平移——类似绝对定位，覆盖，不会挤压！不是脱标（导致父元素没有高度）。<br>​        3.平移的百分比单位——相对于自身的高度和宽度</p><p>容器开启3D效果：   transform-style: preserve-3d;</p><h4 id="less-CSS预处理器"><a href="#less-CSS预处理器" class="headerlink" title="less:CSS预处理器"></a>less:CSS预处理器</h4><p>注释：<br>    // 不会被编译到CSS<br>    /* 会被编译到CSS*/</p><p><strong><strong>***</strong></strong>换行和flex属性的有冲突，会重叠，如果想要前面的元素平分行，后面的元素换行显示，则可以用换行和width：百分比；来实现！！</p><p>盒子透明度设置：opacity：.5；取值再0~1</p><p>合理设置版心宽度，使页面无论使用端的分辨率都不会出现横向滚动条<br>    1.块级元素宽度默认100%；<br>    2.当屏幕大于540px，块级元素的宽度最大就是540px；<br>    3。当屏幕的宽小于540px时，块级元素的宽度=屏幕的宽度<br><strong><strong>***</strong></strong>max-width：540px；</p><p>在不同像素比的手机端显示不同倍清晰的图片：<br>    1.市场上的手机全部都是高清晰度的手机2倍3倍<br>    2.主流做法  美工只做一张高清的图片—2倍或者3倍<br>    3.写代码的时候 直接使用这一张图片就OK，不用再去处理 不同屏幕不同的图片</p><p>弹性头部：<br>    flex:1，将父项除去其他定宽高的子顶剩余的宽度分成一等份，这一部分子项则可以随屏幕的变化来实现伸缩。</p><p>伪元素：<br>    1.伪元素可以用来清除浮动：after<br>    2.伪元素经常会被用来做字体图标或者小精灵图<br><strong>*****</strong>单标签不能加伪元素！！！</p><p>设置a标签的样式可以继承父元素的样式：<br>    a{<br>      color：inherit；<br>    }</p><h4 id="颜色渐变："><a href="#颜色渐变：" class="headerlink" title="颜色渐变："></a>颜色渐变：</h4><p>​     div{<br>​      width: 200px;<br>​      height: 200px;<br>​      margin: 100px auto;<br>​      border: 1px solid #000;<br>​      /* ​      1 渐变不是一种单纯的颜色 而是多种颜色<br>​      2 渐变要添加给标签的 background-image<br>​      3 线性渐变  radial 径向渐变  重复线性渐变 重复径向渐变<br>​       <em>/​       /</em> background-image: linear-gradient(to right,red,pink,yellow ,black,blue); <em>/​       /</em> background-image: linear-gradient(0deg,red 20%,pink 50%,yellow ,black,blue); <em>/​       /</em> background-image: radial-gradient(red,black); <em>/​       /</em> background-image: repeating-linear-gradient() <em>/​       /</em> css.chm  网上 都ok  */<br>​    }</p><p>两列的等高实现的方式：修改display属性值<br>    1.父盒子 display：table-row；<br>    2.子元素 display：table-cell；（cell单元格的意思）</p><h4 id="清除浮动的写法2："><a href="#清除浮动的写法2：" class="headerlink" title="清除浮动的写法2："></a>清除浮动的写法2：</h4><p>​    display：table；<br>​    content：“”；</p><h4 id="相对长度单位：-rem"><a href="#相对长度单位：-rem" class="headerlink" title="相对长度单位： rem"></a>相对长度单位： rem</h4><p>​    css3才有，相对于页面根标签html的字体大小</p><p>rem和px和em的区别<br>    1.px绝对长度单位大小是固定<br>    2.em是相对长度单位，相对于自身的字体大小<br>    3.rem相对长度单位html标签的字体大小<br>字体知识：<br>    谷歌浏览器中默认字体大小是  16px；<br>    谷歌浏览器中默认最小字体是  12px；<br>    在普通的标签中字体大小会被继承——除h1~h6标签外</p><h4 id="浮动：float"><a href="#浮动：float" class="headerlink" title="浮动：float"></a>浮动：float</h4><p>​    float-left：给了元素此属性值，则若该元素的前面有向左浮动的元素则换行<br>​    float-right：若该元素的前面的元素有向右浮动的元素则换行<br><strong><strong><em>不关后面的元素事<br>​    float-both<br><strong>***</strong></em></strong></strong>浮动BUG：1.给元素添加clear：both；清除浮动，强制换行；2.增加间距填补空间</p><h4 id="内减模式："><a href="#内减模式：" class="headerlink" title="内减模式："></a>内减模式：</h4><p>​    box-sizing: border-box;“给div 自己加宽度和高度，自己再增大padding的时候，不会增大盒子大小”</p><p>js里面的事件派发：  –  js里面触发addEventListener注册的事件  –  使用的技术：事件派发<br>    作用：让某个元素的事件被手动的触发</p><h4 id="事件派发的三步"><a href="#事件派发的三步" class="headerlink" title="事件派发的三步:"></a>事件派发的三步:</h4><p>​    1.先new一个事件对象  – 鼠标事件对象<br>​    var 事件对象=new Event（事件的大类型）  –  鼠标事件的大类型—MouseEvent<br>​        var event=new Event(‘MouseEvents’)；<br>​    2.初始化事件对象<br>​    事件对象.initEvent（具体的事件类型，是否可以冒泡，是否可以阻止冒泡）<br>​        event.initEvent(事件类型，是否冒泡，是否可以阻止)；<br>​    3.把事件对象派发除去<br>​    事件源.dispatchEvent（事件对象）；<br>​        box.dispatchEvent（event）；<br>​    ​    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;隐藏元素：&quot;&gt;&lt;a href=&quot;#隐藏元素：&quot; class=&quot;headerlink&quot; title=&quot;隐藏元素：&quot;&gt;&lt;/a&gt;隐藏元素：&lt;/h4&gt;&lt;p&gt;（1）visibility: hidden;   隐藏元素，占位置&lt;br&gt;（2）display: none;    
      
    
    </summary>
    
      <category term="基础" scheme="http://wang-zhibiao.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="javascript" scheme="http://wang-zhibiao.github.io/tags/javascript/"/>
    
      <category term="function" scheme="http://wang-zhibiao.github.io/tags/function/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript的变量以及数据类型</title>
    <link href="http://wang-zhibiao.github.io/2019/06/09/%E5%8F%98%E9%87%8F%E5%92%8Cjs%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://wang-zhibiao.github.io/2019/06/09/变量和js类型的理解/</id>
    <published>2019-06-09T01:24:56.000Z</published>
    <updated>2019-07-14T01:27:28.709Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、JavaScript数据类型"><a href="#一、JavaScript数据类型" class="headerlink" title="一、JavaScript数据类型"></a>一、JavaScript数据类型</h2><p>ECMAScript标准规定了<code>7</code>种数据类型，其把这<code>7</code>种数据类型又分为两种：原始类型和对象类型。</p><h3 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a><strong>原始类型</strong></h3><ul><li><code>Null</code>：只包含一个值：<code>null</code></li><li><code>Undefined</code>：只包含一个值：<code>undefined</code></li><li><code>Boolean</code>：包含两个值：<code>true</code>和<code>false</code></li><li><code>Number</code>：整数或浮点数，还有一些特殊值（<code>-Infinity</code>、<code>+Infinity</code>、<code>NaN</code>）</li><li><code>String</code>：一串表示文本值的字符序列</li><li><code>Symbol</code>：一种实例是唯一且不可改变的数据类型</li></ul><p>(在<code>es10</code>中加入了第七种原始类型<code>BigInt</code>，现已被最新<code>Chrome</code>支持)</p><h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a><strong>对象类型</strong></h3><ul><li><p><code>Object</code>：自己分一类丝毫不过分，除了常用的<code>Object</code>，<code>Array</code>、<code>Function</code>等都属于特殊的对象</p><blockquote><p>区分原始类型和对象类型 - 不可变性</p></blockquote></li></ul><p>原始类型存放在栈空间中，而复杂类型存放在堆空间中</p><h3 id="栈内存："><a href="#栈内存：" class="headerlink" title="栈内存："></a>栈内存：</h3><ul><li>存储的值大小固定</li><li>空间较小</li><li>可以直接操作其保存的变量，运行效率高</li><li>由系统自动分配存储空间</li></ul><h3 id="堆内存："><a href="#堆内存：" class="headerlink" title="堆内存："></a>堆内存：</h3><ul><li>存储的值大小不定，可动态调整</li><li>空间较大，运行效率低</li><li>无法直接操作其内部存储，使用引用地址读取</li><li>通过代码进行分配空间</li></ul><h4 id="字符串-具备不可变性"><a href="#字符串-具备不可变性" class="headerlink" title="字符串 具备不可变性"></a><code>字符串 具备不可变性</code></h4><p>不管是字符串的裁切splice 还是 toLowerCase 都是在原有的基础上产生新的字符串</p><p><code>JavaScript</code>中的原始类型的值被直接存储在栈中，在变量定义时，栈就为其分配好了内存空间。</p><p>由于栈中的内存空间的大小是固定的，那么注定了存储在栈中的变量就是不可变的</p><h4 id="对象-具备可变性"><a href="#对象-具备可变性" class="headerlink" title="对象 具备可变性"></a><code>对象 具备可变性</code></h4><p>引用类型的值实际存储在堆内存中，它在栈中只存储了一个固定长度的地址，这个地址指向堆内存中的值。</p><p>数组  是一个复杂（引用）类型</p><h4 id="通过一些api可以改变数组"><a href="#通过一些api可以改变数组" class="headerlink" title="通过一些api可以改变数组"></a>通过一些api可以改变数组</h4><ul><li><code>pop()</code> 删除数组最后一个元素，如果数组为空，则不改变数组，返回undefined，改变原数组，返回被删除的元素</li><li><code>push()</code>向数组末尾添加一个或多个元素，改变原数组，返回新数组的长度</li><li><code>shift()</code>把数组的第一个元素删除，若空数组，不进行任何操作，返回undefined,改变原数组，返回第一个元素的值</li><li><code>unshift()</code>向数组的开头添加一个或多个元素，改变原数组，返回新数组的长度</li><li><code>reverse()</code>颠倒数组中元素的顺序，改变原数组，返回该数组</li><li><code>sort()</code>对数组元素进行排序，改变原数组，返回该数组</li><li><code>splice()</code>从数组中添加/删除项目，改变原数组，返回被删除的元素</li></ul><p>当我们进行复制时两者有着本质的区别</p><p>这里涉及到浅拷贝和深拷贝—本质是复制时是否改变复制的对象的数值或属性或方法</p><h4 id="原始类型-1"><a href="#原始类型-1" class="headerlink" title="原始类型"></a>原始类型</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'wang'</span>;</span><br><span class="line"><span class="keyword">var</span> newName = name;</span><br><span class="line">newName = <span class="string">'Mr.wang'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// =&gt;wang</span></span><br><span class="line"><span class="built_in">console</span>.log(newName) <span class="comment">// =&gt;Mr.wang</span></span><br></pre></td></tr></table></figure><p>内存中有一个变量<code>name</code>，值为<code>wang</code>。我们从变量<code>name</code>复制出一个变量<code>newName</code>，此时在内存中创建了一个块新的空间用于存储<code>wang</code>，虽然两者值是相同的，但是两者指向的内存空间完全不同，这两个变量参与任何操作都互不影响。</p><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">'wang'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> newObj = obj;</span><br><span class="line">newObj.name = <span class="string">'Mr.wang'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name) <span class="comment">//=&gt; Mr.wang</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.name)<span class="comment">//=&gt; Mr.wang</span></span><br></pre></td></tr></table></figure><p>当我们复制引用类型的变量时，实际上复制的是栈中存储的地址，所以复制出来的<code>newObj</code>实际上和<code>obj</code>指向的堆中同一个对象。因此，我们改变其中任何一个变量的值，另一个变量都会受到影响，这就是为什么会有深拷贝和浅拷贝的原因。</p><h3 id="原始类型和引用类型的比较"><a href="#原始类型和引用类型的比较" class="headerlink" title="原始类型和引用类型的比较"></a>原始类型和引用类型的比较</h3><p>原始类型，比较时会直接比较它们的值，如果值相等，即返回<code>true</code>。</p><p>引用类型，比较时会比较它们的引用地址，虽然两个变量在堆中存储的对象具有的属性值都是相等的，但是它们被存储在了不同的存储空间，因此比较值为<code>false</code>。</p><h4 id="区分null和undefined"><a href="#区分null和undefined" class="headerlink" title="区分null和undefined"></a>区分null和undefined</h4><p><strong>null</strong></p><p>表示被赋值过的对象，刻意把一个对象赋值为<code>null</code>，故意表示其为空，不应有值。</p><p>所以对象的某个属性值为<code>null</code>是正常的，<code>null</code>转换为数值时值为<code>0</code>。</p><p><strong>undefined</strong></p><p>表示“缺少值”，即此处应有一个值，但还没有定义，</p><p>如果一个对象的某个属性值为<code>undefined</code>，这是不正常的，如<code>obj.name=undefined</code>，我们不应该这样写，应该直接<code>delete obj.name</code>。</p><p><code>undefined</code>转为数值时为<code>NaN</code>(非数字值的特殊值)<img src="https://raw.githubusercontent.com/wang-zhibiao/wang-zhibiao.github.io/master/img/nullAndundefined.png" alt="nullAndundefined.png"></p><p><code>JavaScript</code>是一门动态类型语言，成员除了表示存在的空值外，还有可能根本就不存在（因为存不存在只在运行期才知道），这就是<code>undefined</code>的意义所在。对于<code>JAVA</code>这种强类型语言，如果有<code>&quot;undefined&quot;</code>这种情况，就会直接编译失败，所以在它不需要一个这样的类型。</p><h4 id="你想不到的0-1-0-2≠0-3"><a href="#你想不到的0-1-0-2≠0-3" class="headerlink" title="你想不到的0.1+0.2≠0.3"></a>你想不到的0.1+0.2≠0.3</h4><blockquote><p>本质是：由于数字在js中的计算是先转换为二进制在进行计算的，然后以十进制输出</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">judgeFloat</span>(<span class="params">n, m</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> binaryN = n.toString(<span class="number">2</span>);</span><br><span class="line">      <span class="keyword">const</span> binaryM = m.toString(<span class="number">2</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;n&#125;</span>的二进制是    <span class="subst">$&#123;binaryN&#125;</span>`</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;m&#125;</span>的二进制是    <span class="subst">$&#123;binaryM&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">const</span> MN = m + n;</span><br><span class="line">      <span class="keyword">const</span> accuracyMN = (m * <span class="number">100</span> + n * <span class="number">100</span>) / <span class="number">100</span>;</span><br><span class="line">      <span class="keyword">const</span> binaryMN = MN.toString(<span class="number">2</span>);</span><br><span class="line">      <span class="keyword">const</span> accuracyBinaryMN = accuracyMN.toString(<span class="number">2</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;n&#125;</span>+<span class="subst">$&#123;m&#125;</span>的二进制是<span class="subst">$&#123;binaryMN&#125;</span>`</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;accuracyMN&#125;</span>的二进制是    <span class="subst">$&#123;accuracyBinaryMN&#125;</span>`</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;n&#125;</span>+<span class="subst">$&#123;m&#125;</span>的二进制再转成十进制是<span class="subst">$&#123;to10(binaryMN)&#125;</span>`</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;accuracyMN&#125;</span>的二进制是再转成十进制是<span class="subst">$&#123;to10(accuracyBinaryMN)&#125;</span>`</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;n&#125;</span>+<span class="subst">$&#123;m&#125;</span>在js中计算是<span class="subst">$&#123;(to10(binaryMN) === to10(accuracyBinaryMN)) ? <span class="string">''</span> : <span class="string">'不'</span>&#125;</span>准确的`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">to10</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> pre = (n.split(<span class="string">'.'</span>)[<span class="number">0</span>] - <span class="number">0</span>).toString(<span class="number">2</span>);</span><br><span class="line">      <span class="keyword">const</span> arr = n.split(<span class="string">'.'</span>)[<span class="number">1</span>].split(<span class="string">''</span>);</span><br><span class="line">      <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (i &lt; arr.length) &#123;</span><br><span class="line">        result += arr[i] * <span class="built_in">Math</span>.pow(<span class="number">2</span>, -(i + <span class="number">1</span>));</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    judgeFloat(<span class="number">0.1</span>, <span class="number">0.2</span>);</span><br><span class="line">    judgeFloat(<span class="number">0.6</span>, <span class="number">0.7</span>);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wang-zhibiao/wang-zhibiao.github.io/master/img/0.1+0.2.jpg" alt="0.1+0.2"></p><p>计算机中所有的数据都是以<code>二进制</code>存储的，所以在计算时计算机要把数据先转换成<code>二进制</code>进行计算，然后在把计算结果转换成<code>十进制</code>。</p><p>由上面的代码不难看出，在计算<code>0.1+0.2</code>时，<code>二进制</code>计算发生了精度丢失，导致再转换成<code>十进制</code>后和预计的结果不符。</p><h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><p><img src="https://raw.githubusercontent.com/wang-zhibiao/wang-zhibiao.github.io/master/img/%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2.jpg" alt="隐式转换"></p><h3 id="if语句和逻辑语句"><a href="#if语句和逻辑语句" class="headerlink" title="if语句和逻辑语句"></a>if语句和逻辑语句</h3><p>在<code>if</code>语句和逻辑语句中，如果只有单个变量，会先将变量转换为<code>Boolean</code>值，只有下面几种情况会转换成<code>false</code>，其余被转换成<code>true</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">undefined</span><br><span class="line">&apos;&apos;</span><br><span class="line">NaN</span><br><span class="line">0</span><br><span class="line">false</span><br></pre></td></tr></table></figure><h3 id="各种运数学算符"><a href="#各种运数学算符" class="headerlink" title="各种运数学算符"></a>各种运数学算符</h3><p>我们在对各种非<code>Number</code>类型运用数学运算符(<code>- * /</code>)时，会先将非<code>Number</code>类型转换为<code>Number</code>类型;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 - true // 0</span><br><span class="line">1 - null //  1</span><br><span class="line">1 * undefined //  NaN</span><br><span class="line">2 * [&apos;5&apos;] //  10</span><br></pre></td></tr></table></figure><p>注意<code>+</code>是个例外，执行<code>+</code>操作符时：</p><ul><li>1.当一侧为<code>String</code>类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。</li><li>2.当一侧为<code>Number</code>类型，另一侧为原始类型，则将原始类型转换为<code>Number</code>类型。</li><li>3.当一侧为<code>Number</code>类型，另一侧为引用类型，将引用类型和<code>Number</code>类型转换成字符串后拼接。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">123 + &apos;123&apos; // 123123   （规则1）</span><br><span class="line">123 + null  // 123    （规则2）</span><br><span class="line">123 + true // 124    （规则2）</span><br><span class="line">123 + &#123;&#125;  // 123[object Object]    （规则3）</span><br></pre></td></tr></table></figure><h3 id="运算符"><a href="#运算符" class="headerlink" title="== 运算符"></a>== 运算符</h3><p>使用<code>==</code>时，若两侧类型相同，则比较结果和<code>===</code>相同，否则会发生隐式转换，使用<code>==</code>时发生的转换可以分为几种不同的情况（只考虑两侧类型不同）：</p><ul><li><h5 id="1-NaN"><a href="#1-NaN" class="headerlink" title="1.NaN"></a><strong>1.NaN</strong></h5></li></ul><p><code>NaN</code>和其他任何类型比较永远返回<code>false</code>(包括和他自己)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NaN == NaN // false</span><br></pre></td></tr></table></figure><ul><li><h5 id="2-Boolean"><a href="#2-Boolean" class="headerlink" title="2.Boolean"></a><strong>2.Boolean</strong></h5></li></ul><p><code>Boolean</code>和其他任何类型比较，<code>Boolean</code>首先被转换为<code>Number</code>类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">true == 1  // true </span><br><span class="line">true == &apos;2&apos;  // false</span><br><span class="line">true == [&apos;1&apos;]  // true</span><br><span class="line">true == [&apos;2&apos;]  // false</span><br></pre></td></tr></table></figure><blockquote><p>这里注意一个可能会弄混的点：<code>undefined、null</code>和<code>Boolean</code>比较，虽然<code>undefined、null</code>和<code>false</code>都很容易被想象成假值，但是他们比较结果是<code>false</code>，原因是<code>false</code>首先被转换成<code>0</code>：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">undefined == false // false</span><br><span class="line">null == false // false</span><br></pre></td></tr></table></figure><ul><li><h5 id="3-String和Number"><a href="#3-String和Number" class="headerlink" title="3.String和Number"></a><strong>3.String和Number</strong></h5></li></ul><p><code>String</code>和<code>Number</code>比较，先将<code>String</code>转换为<code>Number</code>类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">123 == &apos;123&apos; // true</span><br><span class="line">&apos;&apos; == 0 // true</span><br></pre></td></tr></table></figure><ul><li><h5 id="4-null和undefined"><a href="#4-null和undefined" class="headerlink" title="4.null和undefined"></a><strong>4.null和undefined</strong></h5></li></ul><p><code>null == undefined</code>比较结果是<code>true</code>，除此之外，<code>null、undefined</code>和其他任何结果的比较值都为<code>false</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">null == undefined // true</span><br><span class="line">null == &apos;&apos; // false</span><br><span class="line">null == 0 // false</span><br><span class="line">null == false // false</span><br><span class="line">undefined == &apos;&apos; // false</span><br><span class="line">undefined == 0 // false</span><br><span class="line">undefined == false // false</span><br></pre></td></tr></table></figure><ul><li><h5 id="5-原始类型和引用类型"><a href="#5-原始类型和引用类型" class="headerlink" title="5.原始类型和引用类型"></a><strong>5.原始类型和引用类型</strong></h5></li></ul><p>当原始类型和引用类型做比较时，对象类型会依照<code>ToPrimitive</code>规则转换为原始类型:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;[object Object]&apos; == &#123;&#125; // true</span><br><span class="line">&apos;1,2,3&apos; == [1, 2, 3] // true</span><br></pre></td></tr></table></figure><p>来看看下面这个比较：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] == ![] // true</span><br></pre></td></tr></table></figure><p><code>!</code>的优先级高于<code>==</code>，<code>![]</code>首先会被转换为<code>false</code>，然后根据上面第三点，<code>false</code>转换成<code>Number</code>类型<code>0</code>，左侧<code>[]</code>转换为<code>0</code>，两侧比较相等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[null] == false // true</span><br><span class="line">[undefined] == false // true</span><br></pre></td></tr></table></figure><p>根据数组的<code>ToPrimitive</code>规则，数组元素为<code>null</code>或<code>undefined</code>时，该元素被当做空字符串处理，所以<code>[null]、[undefined]</code>都会被转换为<code>0</code>。</p><h4 id="原型链的规则"><a href="#原型链的规则" class="headerlink" title="原型链的规则"></a>原型链的规则</h4><ul><li>1.所有引用类型都具有对象特性，即可以自由扩展属性</li><li>2.所有引用类型都具有一个<code>proto</code>（隐式原型）属性，是一个普通对象</li><li>3.所有的函数都具有<code>prototype</code>（显式原型）属性，也是一个普通对象</li><li>4.所有引用类型<code>proto</code>值指向它构造函数的<code>prototype</code></li><li>5.当试图得到一个对象的属性时，如果变量本身没有这个属性，则会去他的<code>proto</code>中去找</li></ul><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><p>上面我们在拆箱操作中提到了<code>toString</code>函数，我们可以调用它实现从引用类型的转换。</p><blockquote><p>每一个引用类型都有<code>toString</code>方法，默认情况下，<code>toString()</code>方法被每个<code>Object</code>对象继承。如果此方法在自定义对象中未被覆盖，<code>toString()</code> 返回 <code>&quot;[object type]&quot;</code>，其中<code>type</code>是对象的类型。</p></blockquote><p><img src="https://raw.githubusercontent.com/wang-zhibiao/wang-zhibiao.github.io/master/img/tostring.jpg" alt="tostring"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、JavaScript数据类型&quot;&gt;&lt;a href=&quot;#一、JavaScript数据类型&quot; class=&quot;headerlink&quot; title=&quot;一、JavaScript数据类型&quot;&gt;&lt;/a&gt;一、JavaScript数据类型&lt;/h2&gt;&lt;p&gt;ECMAScript标准规定
      
    
    </summary>
    
      <category term="javascript" scheme="http://wang-zhibiao.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://wang-zhibiao.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>this指向，call，apply，bind</title>
    <link href="http://wang-zhibiao.github.io/2019/06/02/this%E6%8C%87%E5%90%91%EF%BC%8Capply%EF%BC%8Ccall,bind/"/>
    <id>http://wang-zhibiao.github.io/2019/06/02/this指向，apply，call,bind/</id>
    <published>2019-06-02T01:10:56.000Z</published>
    <updated>2019-07-24T09:58:35.663Z</updated>
    
    <content type="html"><![CDATA[<p>如何理解This指向</p><p>this ：谁调用它 他就指向谁。（<strong>this 永远指向最后调用它的那个对象</strong>）</p><p>1.在浏览器：如果this是在函数外部则this指向window</p><p>2.在node环境：如果this在函数外部则指向{}</p><p>​    如果有new绑定 则指向这个new的实例对象</p><p>​    函数是否通过 call,apply 调用，或者使用了 bind 绑定，如果是，那么this绑定的就是指定的对象【归结为显式绑定】。</p><p>​    这里同样需要注意一种<strong>特殊</strong>情况，如果 call,apply 或者 bind 传入的第一个参数值是 <code>undefined</code> 或者 <code>null</code>，严格模式下 this 的值为传入的值 null /undefined。非严格模式下，实际应用的默认绑定规则，this 指向全局对象(node环境为global，浏览器环境为window)</p><p>隐式绑定，函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的隐式调用为: <code>xxx.fn()</code></p><p>箭头函数的情况：箭头函数没有自己的this，继承外层上下文绑定的this。</p><h4 id="看看具体例子"><a href="#看看具体例子" class="headerlink" title="看看具体例子"></a>看看具体例子</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    <span class="comment">// name: "Cherry",</span></span><br><span class="line">    fn : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);      <span class="comment">//==》undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.a.fn();</span><br></pre></td></tr></table></figure><p>说明：这里有通过window调用a ，最后调用的是谁的呢？？  其实是a最后调用了this=》》a里面没有那么这个属性，即使外面的window有name也不会调用==》》就像我们对于变量的调用一样，，函数内部的变量不可以使用其他的函数内部的变量，a和window是两个函数  即使window包括a但是调用的时候是使用this  指向了a  也就是标明  我一定要使用a里面的属性</p><h4 id="再看看这个坑"><a href="#再看看这个坑" class="headerlink" title="再看看这个坑"></a>再看看这个坑</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name : <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// name: "Cherry",</span></span><br><span class="line">    fn : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);      <span class="comment">//==&gt; windowsName</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = a.fn;</span><br><span class="line">f();</span><br></pre></td></tr></table></figure><p>为什么和之前的调用差不多 this却是指向window  由上往下看，var f 的时候根本没有调用a.fn;</p><p>最后fn（）  是使用了window调用的 所以指向了外面的name</p><h4 id="this-的指向并不是在创建的时候就可以确定的-永远指向最后调用的它"><a href="#this-的指向并不是在创建的时候就可以确定的-永远指向最后调用的它" class="headerlink" title="this 的指向并不是在创建的时候就可以确定的  永远指向最后调用的它"></a>this 的指向并不是在创建的时候就可以确定的  永远指向最后调用的它</h4><h4 id="call和apply以及bind都与this有关-因为他们改变了this的指向"><a href="#call和apply以及bind都与this有关-因为他们改变了this的指向" class="headerlink" title="call和apply以及bind都与this有关 因为他们改变了this的指向"></a>call和apply以及bind都与this有关 因为他们改变了this的指向</h4><h3 id="先说说this改变的几种方法"><a href="#先说说this改变的几种方法" class="headerlink" title="先说说this改变的几种方法"></a>先说说this改变的几种方法</h3><h5 id="1-当你new一个对象时-this就指向创建的实例"><a href="#1-当你new一个对象时-this就指向创建的实例" class="headerlink" title="1.当你new一个对象时  this就指向创建的实例"></a>1.当你new一个对象时  this就指向创建的实例</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"><span class="comment">// 我们可以使用data创建时间 这是因为data的this在赋值当中已经指向实例new Date（）</span></span><br></pre></td></tr></table></figure>  <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new 的实现原理:</span><br><span class="line">创建一个空对象，构造函数中的this指向这个空对象</span><br><span class="line">这个新对象被执行 [[原型]] 连接</span><br><span class="line">执行构造函数方法，属性和方法被添加到this引用的对象中</span><br><span class="line">如果构造函数中没有返回其它对象，那么返回this，即创建的这个的新对象，否则，返回构造函数中返回的对象。</span><br></pre></td></tr></table></figure><h5 id="2-使用闭包解决，有两层函数可以再第一层使用-this-this改变指向"><a href="#2-使用闭包解决，有两层函数可以再第一层使用-this-this改变指向" class="headerlink" title="2.使用闭包解决，有两层函数可以再第一层使用_this= this改变指向"></a>2.使用闭包解决，有两层函数可以再第一层使用<code>_this= this</code>改变指向</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在这里使用的是闭包的原理 也可以改变this的指向</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="keyword">this</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(_this)  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-es6的箭头函数-指向外部的this，（）-gt"><a href="#3-es6的箭头函数-指向外部的this，（）-gt" class="headerlink" title="3.es6的箭头函数 指向外部的this，（）=&gt;{}"></a>3.es6的箭头函数 指向外部的this，<code>（）=&gt;{}</code></h5><p><strong>箭头函数的 this 始终指向函数定义时的 this，而非执行时。</strong></p><h3 id="4-call-apply-bind"><a href="#4-call-apply-bind" class="headerlink" title="4.call apply  bind"></a>4.call apply  bind</h3><blockquote><p>call</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">Object</span> = &#123;</span><br><span class="line">    name:<span class="string">'Mr.wang'</span></span><br><span class="line">    first()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name) </span><br><span class="line">    &#125;</span><br><span class="line">second()&#123;</span><br><span class="line">        third()&#123;</span><br><span class="line">          <span class="keyword">return</span>  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">        &#125;.call(a)</span><br><span class="line">        third();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.second()  <span class="comment">//==&gt; 输出为 Mr.wang</span></span><br></pre></td></tr></table></figure><blockquote><p>apply</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">Object</span> = &#123;</span><br><span class="line">    name:<span class="string">'Mr.wang'</span></span><br><span class="line">    first()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name) </span><br><span class="line">    &#125;</span><br><span class="line">second()&#123;</span><br><span class="line">        third()&#123;</span><br><span class="line">          <span class="keyword">return</span>  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">        &#125;.apply(a)</span><br><span class="line">        third();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.second()  <span class="comment">//==&gt; 输出为 Mr.wang</span></span><br></pre></td></tr></table></figure><blockquote><p>bind</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">Object</span> = &#123;</span><br><span class="line">    name:<span class="string">'Mr.wang'</span></span><br><span class="line">    first()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name) </span><br><span class="line">    &#125;</span><br><span class="line">second()&#123;</span><br><span class="line">        third()&#123;</span><br><span class="line">          <span class="keyword">return</span>  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">        &#125;.bind(a)</span><br><span class="line">        third();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.second()()  <span class="comment">//==&gt; 输出为 Mr.wang</span></span><br><span class="line">bind 为什么是两个（）（） 接着看</span><br></pre></td></tr></table></figure><h4 id="apply-和-call-的区别"><a href="#apply-和-call-的区别" class="headerlink" title="apply 和 call 的区别"></a>apply 和 call 的区别</h4><p>他们之间的区别只是传入参数的区别</p><h5 id="appll-this-a-b-c"><a href="#appll-this-a-b-c" class="headerlink" title="appll(this,[a,b,c])"></a>appll(this,[a,b,c])</h5><h5 id="call-this-a-b-c"><a href="#call-this-a-b-c" class="headerlink" title="call(this,a,b,c)"></a>call(this,a,b,c)</h5><p>bind与apply和call有着大的区别</p><p>bind会生成新的函数，需要调用再次调用 也就是()()的原因 也可以在赋值后调用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如何理解This指向&lt;/p&gt;
&lt;p&gt;this ：谁调用它 他就指向谁。（&lt;strong&gt;this 永远指向最后调用它的那个对象&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;1.在浏览器：如果this是在函数外部则this指向window&lt;/p&gt;
&lt;p&gt;2.在node环境：如果this
      
    
    </summary>
    
      <category term="Es6语法" scheme="http://wang-zhibiao.github.io/categories/Es6%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="javascript" scheme="http://wang-zhibiao.github.io/tags/javascript/"/>
    
      <category term="function" scheme="http://wang-zhibiao.github.io/tags/function/"/>
    
  </entry>
  
  <entry>
    <title>Es6解构赋值</title>
    <link href="http://wang-zhibiao.github.io/2019/05/11/Es6%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <id>http://wang-zhibiao.github.io/2019/05/11/Es6变量的解构赋值/</id>
    <published>2019-05-11T02:10:56.000Z</published>
    <updated>2019-07-14T01:28:26.270Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h2><ol><li>数组的解构赋值</li><li>对象的解构赋值</li><li>字符串的解构赋值</li><li>数值和布尔值的解构赋值</li><li>函数参数的解构赋值</li></ol><h3 id="1数组的解构赋值"><a href="#1数组的解构赋值" class="headerlink" title="1数组的解构赋值"></a>1数组的解构赋值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">// 为abc各自an规律赋值</span></span><br><span class="line"><span class="keyword">let</span> [a,[b,[c]]] = [<span class="number">1</span>,[<span class="number">2</span>,[<span class="number">3</span>]]]  <span class="comment">//如果为嵌套数组，可以用一样的嵌套数组赋值</span></span><br><span class="line"><span class="keyword">let</span> [x,y] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">//如果赋值两边长度不一，，则部分赋值 部分未赋值为uddefined</span></span><br><span class="line"><span class="keyword">let</span> [...arr] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">//扩展运算符可以直接把所有的数字赋值给arr arr=[1,2,3]</span></span><br><span class="line"><span class="keyword">let</span> [first,...arrAll]=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] <span class="comment">//当第一个first赋值以后，其他的数字都会给arrAll包含  first =1 arrAll=[2,3,4]</span></span><br></pre></td></tr></table></figure><h4 id="结构赋值为何左右两边为数组？"><a href="#结构赋值为何左右两边为数组？" class="headerlink" title="结构赋值为何左右两边为数组？"></a>结构赋值为何左右两边为数组？</h4><p>正常的赋值是一个一个赋值，解构赋值是吧需要赋值的解析重构，循环赋值 通过数组可遍历的特性就可以解构</p><h4 id="解构赋值的默认值"><a href="#解构赋值的默认值" class="headerlink" title="解构赋值的默认值"></a>解构赋值的默认值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a=<span class="number">11</span>] = [] <span class="comment">//a输出为11 在赋值之前就已经赋值 解构只是再次赋值 不会冲突 注意点 [] 数组里面无任何值，但是有undefined 所以才会解构成功 ，否则部分赋值也不会实现，以下情况请注意 null与undefined有本质的区别，两者不等，所以赋值时可以成功为null，解构赋值也严格遵守严格运算符（===）</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];<span class="comment">//x = 1</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>]; <span class="comment">//x = null</span></span><br></pre></td></tr></table></figure><h3 id="2对象的解构赋值"><a href="#2对象的解构赋值" class="headerlink" title="2对象的解构赋值"></a>2对象的解构赋值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a&#125;=&#123;<span class="attr">a</span>:<span class="string">'good'</span>,<span class="attr">b</span>:<span class="string">'nice'</span>&#125; <span class="comment">//a = good 对象里不同于数组，它是无序的集合 所以赋值要用见来赋值 两者的键要相同</span></span><br><span class="line"><span class="comment">//如果没有对应的键则会返回undefined</span></span><br><span class="line"><span class="comment">//对象的解构赋值可以对内置对象进行赋值</span></span><br><span class="line"><span class="keyword">let</span>&#123;log,sin,cos&#125; = <span class="built_in">Math</span></span><br><span class="line"><span class="keyword">let</span> &#123;log&#125; = <span class="built_in">console</span></span><br><span class="line"><span class="comment">//当取得所对应的对象的方法时，可以直接调用</span></span><br><span class="line">log(<span class="string">'hello word'</span>) <span class="comment">//控制台输出hello word</span></span><br><span class="line">sin(<span class="number">90</span>)  <span class="comment">//输出为 1</span></span><br><span class="line"><span class="keyword">let</span> &#123;a，&#123;b&#125;&#125; = &#123;<span class="attr">a</span>:<span class="number">11</span>,&#123;<span class="attr">b</span>:<span class="number">22</span>&#125;&#125; <span class="comment">//对象一样支持嵌套赋值</span></span><br><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;&#125;; <span class="comment">//也支持默认值</span></span><br></pre></td></tr></table></figure><p>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;; <span class="comment">//已经声明的变量再解构赋值会报错 ，&#123;x&#125; 会被解析为代码块</span></span><br><span class="line"><span class="comment">//解决方法</span></span><br><span class="line">(&#123;x&#125;=&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;); <span class="comment">//括号包裹</span></span><br><span class="line"><span class="comment">//解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。</span></span><br><span class="line">(&#123;&#125;=&#123;<span class="attr">a</span>:dd&#125;) <span class="comment">//语法可行但毫无意义</span></span><br><span class="line"><span class="comment">//数组也是一种特殊的对象 他是用索引值当键</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="number">0</span>:first&#125; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h3 id="3字符串的解构赋值"><a href="#3字符串的解构赋值" class="headerlink" title="3字符串的解构赋值"></a>3字符串的解构赋值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c,d,e] = <span class="string">'hello'</span> <span class="comment">// a=h,b=e,c=l,d=l,e=o  //这是将字符串转化为数组遍历在赋值</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">'hello'</span>; <span class="comment">//len = 5 // 数组都有length这个键 表示长度</span></span><br></pre></td></tr></table></figure><h3 id="4数值和布尔值的解构赋值"><a href="#4数值和布尔值的解构赋值" class="headerlink" title="4数值和布尔值的解构赋值"></a>4数值和布尔值的解构赋值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></span><br><span class="line"><span class="comment">//数字和布尔类型会转化为对象 所以在s的原型链与赋值的原型链相等 前面的键 toString 是转化为字符串的方法</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line">s === <span class="built_in">Boolean</span>.prototype.toString <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 由于ndefined和null无法转为对象 所以不能进行赋值</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: x &#125; = <span class="literal">undefined</span>; <span class="comment">// TypeError</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: y &#125; = <span class="literal">null</span>; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><h2 id="5函数参数的解构赋值"><a href="#5函数参数的解构赋值" class="headerlink" title="5函数参数的解构赋值"></a>5函数参数的解构赋值</h2><p>函数的解构赋值我们经常使用 当我们进行传参时 就会进行解构赋值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">2</span>,<span class="number">3</span>) <span class="comment">//a和b都会在函数调用时传参解构赋值</span></span><br></pre></td></tr></table></figure><p>函数参数的默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">fn(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8] </span></span><br><span class="line">fn(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, 0]</span></span><br><span class="line">fn(&#123;&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line">fn(); <span class="comment">// [0, 0]</span></span><br><span class="line"><span class="comment">//如果有默认值,参数没有就使用默认值</span></span><br></pre></td></tr></table></figure><p>另一种函数的默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">&#123;x, y&#125; = &#123;x:<span class="number">0</span>,y:<span class="number">0</span>&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">fn(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8] </span></span><br><span class="line">fn(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, undefined]</span></span><br><span class="line">fn(&#123;&#125;); <span class="comment">// [undefined, undefined]</span></span><br><span class="line">fn(); <span class="comment">// [0, 0]</span></span><br><span class="line"><span class="comment">//如果有默认值,参数没有就使用默认值</span></span><br><span class="line"><span class="comment">//这种写法使用了对象的键值对赋值，不是之前的值传递，所以 当参数为&#123;&#125;时 传递的是undefined</span></span><br></pre></td></tr></table></figure><h3 id="圆括号"><a href="#圆括号" class="headerlink" title="圆括号"></a>圆括号</h3><p>圆括号是为了解决赋值时解析的无法辨别，但是要注意使用时机，否则会报错</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;变量的解构赋值&quot;&gt;&lt;a href=&quot;#变量的解构赋值&quot; class=&quot;headerlink&quot; title=&quot;变量的解构赋值&quot;&gt;&lt;/a&gt;变量的解构赋值&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;数组的解构赋值&lt;/li&gt;
&lt;li&gt;对象的解构赋值&lt;/li&gt;
&lt;li&gt;字符串的解构赋值&lt;/
      
    
    </summary>
    
      <category term="基础" scheme="http://wang-zhibiao.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="javascript" scheme="http://wang-zhibiao.github.io/tags/javascript/"/>
    
      <category term="Es6" scheme="http://wang-zhibiao.github.io/tags/Es6/"/>
    
  </entry>
  
  <entry>
    <title>let var const三种定义方式及闭包</title>
    <link href="http://wang-zhibiao.github.io/2019/05/10/var%20let%20const%E4%B8%89%E7%A7%8D%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F%E5%8F%8A%E9%97%AD%E5%8C%85/"/>
    <id>http://wang-zhibiao.github.io/2019/05/10/var let const三种定义方式及闭包/</id>
    <published>2019-05-09T16:10:56.000Z</published>
    <updated>2019-07-14T01:27:55.718Z</updated>
    
    <content type="html"><![CDATA[<h3 id="let-var-const-之间的区别"><a href="#let-var-const-之间的区别" class="headerlink" title="let var const 之间的区别"></a>let var const 之间的区别</h3><h4 id="var"><a href="#var" class="headerlink" title="var"></a>var</h4><p>var的作用域是根据函数作用域的， 他在函数内起作用   这里就引用到闭包和作用域链</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">out</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">000</span>; <span class="comment">//=&gt; 这个a的作用域作用在out内 而info函数在out函数内 所以可以调用</span></span><br><span class="line">b=<span class="number">222</span> <span class="comment">//=&gt; 报错err 因为b的作用域在info函数内 包裹他的out函数不可以调用它</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">info</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b=<span class="number">999</span>;</span><br><span class="line">a= <span class="number">111</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>var 的变量提升</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a=<span class="number">10</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//变量提升 就是var定义的变量会在先声明再赋值 提升到函数顶部</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  a=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><p>let的作用域的块级作用域，不会变量提升  可以理解为在某块范围内作用 与var 的函数作用域不同在于 let的作用域会形成闭包</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出 3 3 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出 0 1 2</span></span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var会在全局声明 而setTimeout 是一个定时器 也是异步回调  会在同步执行完毕再执行异步 所以当for循环完毕 i=3时调用三次定时器  </span><br><span class="line">let 的作用范围会在for循环内 每循环一次 i会形成一次闭包  i会被setTimeout调用</span><br></pre></td></tr></table></figure><h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p>const代表一个值的常量索引，常量的值在垃圾回收前永远不能改变，所以需要谨慎使用。</p><p>cosnt定义的值不能被改变 否则会报错</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Uncaught TypeError: Assignment to constant variable.</span><br><span class="line">未捕获的类型错误:赋值给常量变量。</span><br></pre></td></tr></table></figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>外部可以访问内部的私有变量</p><p>可以返回携带状态的函数，并且状态隐藏 可以做到变量的私有</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n=<span class="number">999</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(n); <span class="comment">// 999</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p><p>既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function f1()&#123;</span><br><span class="line">var n=999;</span><br><span class="line">function f2()&#123;</span><br><span class="line">alert(n); </span><br><span class="line">&#125;</span><br><span class="line">return f2;</span><br><span class="line">&#125;</span><br><span class="line">var result=f1();</span><br><span class="line">result(); // 999</span><br></pre></td></tr></table></figure><p>闭包就是能够读取其他函数内部变量的函数</p><p>要形成闭包 必须两层function函数作用域</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function f1()&#123;</span><br><span class="line">  var n=999;</span><br><span class="line">  Add=function()&#123;n+=1&#125;</span><br><span class="line">  function f2()&#123;</span><br><span class="line">  console.log(n)</span><br><span class="line">&#125;</span><br><span class="line">return f2;</span><br><span class="line">&#125;</span><br><span class="line">var result=f1();</span><br><span class="line">result(); // 999</span><br><span class="line">Add();</span><br><span class="line">result(); // 1000</span><br></pre></td></tr></table></figure><p>这里形成闭包后，f1的局部变量n一直保存在内存中，并没有因为f1的重复调用而清除</p><p>原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p><p>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">  name: <span class="string">"My Object"</span>,</span><br><span class="line">  getNameFunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getNameFunc()());</span><br></pre></td></tr></table></figure><p>经典闭包题</p><p>个人理解</p><p>object.getNameFunc()  执行到这一步时 调用object内的函数 返回一个function（）{return this.name} 这时候 name还是My Object  当再次执行时object.getNameFunc()()  调用了外部的name 输出为The Window</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;let-var-const-之间的区别&quot;&gt;&lt;a href=&quot;#let-var-const-之间的区别&quot; class=&quot;headerlink&quot; title=&quot;let var const 之间的区别&quot;&gt;&lt;/a&gt;let var const 之间的区别&lt;/h3&gt;&lt;h4 i
      
    
    </summary>
    
      <category term="javascript" scheme="http://wang-zhibiao.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://wang-zhibiao.github.io/tags/javascript/"/>
    
      <category term="function" scheme="http://wang-zhibiao.github.io/tags/function/"/>
    
  </entry>
  
  <entry>
    <title>隐藏元素的方法</title>
    <link href="http://wang-zhibiao.github.io/2019/03/22/%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://wang-zhibiao.github.io/2019/03/22/隐藏元素的方法/</id>
    <published>2019-03-21T16:10:56.000Z</published>
    <updated>2019-07-13T02:29:27.392Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>隐藏类型</p></blockquote><p>屏幕并不是唯一的输出机制，比如说屏幕上看不见的元素（隐藏的元素），其中一些依然能够被读屏软件阅读出来（因为读屏软件依赖于可访问性树来阐述）。为了消除它们之间的歧义，我们将其归为三大类：</p><ul><li>完全隐藏：元素从DOM树中消失，不占据空间。</li><li>视觉上的隐藏：屏幕中不可见，占据空间。</li><li>语义上的隐藏：读屏软件不可读，但正常占据空间。</li></ul><blockquote><p>完全隐藏</p></blockquote><h4 id="1-display-属性"><a href="#1-display-属性" class="headerlink" title="1.display 属性"></a>1.<code>display</code> 属性</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">none</span>;</span><br></pre></td></tr></table></figure><h4 id="2-hidden-属性"><a href="#2-hidden-属性" class="headerlink" title="2.hidden 属性"></a>2.hidden 属性</h4><blockquote><p>HTML5 新增属性，相当于 <code>display: none</code></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">hidden</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>视觉上的隐藏,在页面中还存在</p></blockquote><h4 id="3-利用-position-和-盒模型-将元素移出可视区范围"><a href="#3-利用-position-和-盒模型-将元素移出可视区范围" class="headerlink" title="3.利用 position 和 盒模型 将元素移出可视区范围"></a>3.利用 <code>position</code> 和 盒模型 将元素移出可视区范围</h4><blockquote><p>设置 <code>posoition</code> 为 <code>absolute</code> 或 <code>fixed</code>，通过设置 <code>top</code>、<code>left</code> 等值，将其移出可视区域。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">position</span><span class="selector-pseudo">:absolute</span>;</span><br><span class="line"><span class="selector-tag">left</span>: <span class="selector-tag">-999px</span>;</span><br></pre></td></tr></table></figure><blockquote><p>设置 <code>position</code> 为 <code>relative</code>，通过设置 <code>top</code>、<code>left</code> 等值，将其移出可视区域。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">relative</span>;</span><br><span class="line"><span class="selector-tag">left</span>: <span class="selector-tag">-999px</span>;</span><br></pre></td></tr></table></figure><blockquote><p>设置 margin 值，将其移出可视区域范围（可视区域占位）。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">margin-left</span>: <span class="selector-tag">-99999px</span>;</span><br><span class="line"><span class="selector-tag">height</span>: 0;</span><br></pre></td></tr></table></figure><h4 id="3-利用-transfrom"><a href="#3-利用-transfrom" class="headerlink" title="3.利用 transfrom"></a>3.利用 transfrom</h4><blockquote><p>缩放</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">scale</span>(0);</span><br><span class="line"><span class="selector-tag">height</span>: 0;</span><br></pre></td></tr></table></figure><blockquote><p>移动 <code>translateX</code>, <code>translateY</code></p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateX</span>(<span class="selector-tag">-99999px</span>);</span><br><span class="line"><span class="selector-tag">height</span>: 0</span><br></pre></td></tr></table></figure><blockquote><p>旋转 <code>rotate</code></p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform: rotateY(90deg) //直角在界面上形成线性视觉屏蔽</span><br></pre></td></tr></table></figure><h4 id="4-设置其大小为0"><a href="#4-设置其大小为0" class="headerlink" title="4.设置其大小为0"></a>4.设置其大小为0</h4><blockquote><p>宽高为0，字体大小为0：</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">height</span>: 0;</span><br><span class="line"><span class="selector-tag">width</span>: 0;</span><br><span class="line"><span class="selector-tag">font-size</span>: 0;</span><br></pre></td></tr></table></figure><blockquote><p>宽高为0，超出隐藏:</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">height</span>: 0;</span><br><span class="line"><span class="selector-tag">width</span>: 0;</span><br><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br></pre></td></tr></table></figure><h4 id="5-设置透明度为0"><a href="#5-设置透明度为0" class="headerlink" title="5.设置透明度为0"></a>5.设置透明度为0</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">opacity</span>: 0;</span><br></pre></td></tr></table></figure><h4 id="6-visibility属性"><a href="#6-visibility属性" class="headerlink" title="6.visibility属性"></a>6.<code>visibility</code>属性</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">visibility</span>: <span class="selector-tag">hidden</span>;</span><br></pre></td></tr></table></figure><h4 id="7-层级覆盖，z-index-属性"><a href="#7-层级覆盖，z-index-属性" class="headerlink" title="7.层级覆盖，z-index 属性"></a>7.层级覆盖，<code>z-index</code> 属性</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">relative</span>;</span><br><span class="line"><span class="selector-tag">z-index</span>: <span class="selector-tag">-999</span>;</span><br></pre></td></tr></table></figure><h5 id="再设置一个层级较高的元素覆盖在此元素上。"><a href="#再设置一个层级较高的元素覆盖在此元素上。" class="headerlink" title="再设置一个层级较高的元素覆盖在此元素上。"></a>再设置一个层级较高的元素覆盖在此元素上。</h5><h4 id="8-clip-path-裁剪"><a href="#8-clip-path-裁剪" class="headerlink" title="8.clip-path 裁剪"></a>8.clip-path 裁剪</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">clip-path</span>: <span class="selector-tag">polygon</span>(0 0, 0 0, 0 0, 0 0);</span><br></pre></td></tr></table></figure><p><strong>语义上的隐藏</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;隐藏类型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;屏幕并不是唯一的输出机制，比如说屏幕上看不见的元素（隐藏的元素），其中一些依然能够被读屏软件阅读出来（因为读屏软件依赖于可访问性树来阐述）。为了消除它们之间的歧义，我们将其归为三大类：&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="基础" scheme="http://wang-zhibiao.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="javascript" scheme="http://wang-zhibiao.github.io/tags/javascript/"/>
    
      <category term="function" scheme="http://wang-zhibiao.github.io/tags/function/"/>
    
  </entry>
  
  <entry>
    <title>BFC协议</title>
    <link href="http://wang-zhibiao.github.io/2018/12/30/BFC%E5%8D%8F%E8%AE%AE/"/>
    <id>http://wang-zhibiao.github.io/2018/12/30/BFC协议/</id>
    <published>2018-12-29T16:14:56.000Z</published>
    <updated>2019-07-14T01:29:51.152Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是BFC？BFC的布局规则是什么？如何创建BFC？"><a href="#什么是BFC？BFC的布局规则是什么？如何创建BFC？" class="headerlink" title="什么是BFC？BFC的布局规则是什么？如何创建BFC？"></a>什么是BFC？BFC的布局规则是什么？如何创建BFC？</h3><p><strong>查看解析</strong></p><ul><li>Box 是 CSS 布局的对象和基本单位，页面是由若干个Box组成的。</li><li>元素的类型 和 <code>display</code> 属性，决定了这个 Box 的类型。不同类型的 Box 会参与不同的 Formatting Context。</li></ul><blockquote><h4 id="Formatting-Context"><a href="#Formatting-Context" class="headerlink" title="Formatting Context"></a>Formatting Context</h4></blockquote><ul><li>Formatting Context 是页面的一块渲染区域，并且有一套渲染规则，决定了其子元素将如何定位，以及和其它元素的关系和相互作用。</li><li>Formatting Context 有 BFC (Block formatting context)，IFC (Inline formatting context)，FFC (Flex formatting context) 和 GFC (Grid formatting context)。FFC 和 GFC 为 CC3 中新增。</li></ul><blockquote><h4 id="BFC布局规则"><a href="#BFC布局规则" class="headerlink" title="BFC布局规则"></a><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.w3.org%2FTR%2F2011%2FREC-CSS2-20110607%2Fvisuren.html%23block-formatting" target="_blank" rel="noopener">BFC布局规则</a></h4></blockquote><ul><li>BFC内，盒子依次垂直排列。</li><li>BFC内，两个盒子的垂直距离由 <code>margin</code> 属性决定。属于同一个BFC的两个相邻Box的margin会发生重叠【符合合并原则的margin合并后是使用大的margin】</li><li>BFC内，每个盒子的左外边缘接触内部盒子的左边缘（对于从右到左的格式，右边缘接触）。即使在存在浮动的情况下也是如此。除非创建新的BFC。</li><li>BFC的区域不会与float box重叠。</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li><li>计算BFC的高度时，浮动元素也参与计算。</li></ul><blockquote><h4 id="如何创建BFC"><a href="#如何创建BFC" class="headerlink" title="如何创建BFC"></a>如何创建BFC</h4></blockquote><h2 id="根元素"><a href="#根元素" class="headerlink" title="根元素"></a>根元素</h2><ul><li>浮动元素（float 属性不为 none）</li><li>position 为 absolute 或 fixed</li><li>overflow 不为 visible 的块元素</li><li>display 为 inline-block, table-cell, table-caption</li></ul><blockquote><p>BFC 的应用</p></blockquote><ul><li>防止 margin  重叠 (同一个BFC内的两个两个相邻Box的 <code>margin</code> 会发生重叠，触发生成两个BFC，即不会重叠)</li><li>清除内部浮动 (创建一个新的 BFC，因为根据 BFC 的规则，计算 BFC 的高度时，浮动元素也参与计算)</li><li>自适应多栏布局 (BFC的区域不会与float box重叠。因此，可以触发生成一个新的BFC)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是BFC？BFC的布局规则是什么？如何创建BFC？&quot;&gt;&lt;a href=&quot;#什么是BFC？BFC的布局规则是什么？如何创建BFC？&quot; class=&quot;headerlink&quot; title=&quot;什么是BFC？BFC的布局规则是什么？如何创建BFC？&quot;&gt;&lt;/a&gt;什么是BF
      
    
    </summary>
    
      <category term="javascript" scheme="http://wang-zhibiao.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://wang-zhibiao.github.io/tags/javascript/"/>
    
      <category term="function" scheme="http://wang-zhibiao.github.io/tags/function/"/>
    
  </entry>
  
  <entry>
    <title>盒子居中的方法</title>
    <link href="http://wang-zhibiao.github.io/2018/12/20/%E7%9B%92%E5%AD%90%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://wang-zhibiao.github.io/2018/12/20/盒子居中的方法/</id>
    <published>2018-12-20T11:50:59.000Z</published>
    <updated>2019-07-14T01:29:23.856Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h3 id="盒子居中的方法："><a href="#盒子居中的方法：" class="headerlink" title="盒子居中的方法："></a>盒子居中的方法：</h3><h5 id="1-宽度和高度已知的。"><a href="#1-宽度和高度已知的。" class="headerlink" title="1.宽度和高度已知的。"></a>1.宽度和高度已知的。</h5><p>思路：<br>  父元素相对定位<br>  子元素绝对定位 </p><p>子元素{</p><p>left: 50%;top: 50%;<br>margin-left: 减去子元素的宽度一半。<br>margin-top: 减去子元素的高度一半；</p><p>}</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line">        <span class="selector-id">#box</span>&#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">            <span class="attribute">position</span>: relative;</span><br><span class="line">            background: red; //方便观看</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-id">#box1</span>&#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">            <span class="attribute">position</span>: absolute;</span><br><span class="line">            <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">            <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">            margin-left: -100px;  //定位后偏移值超过子元素的宽度一半需减去</span><br><span class="line">            margin-top: -50px;//定位后偏移值超过子元素的高度一半需减去</span><br><span class="line">            <span class="selector-tag">background</span>: <span class="selector-tag">green</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h5 id="2-宽度和高度可以随意改变"><a href="#2-宽度和高度可以随意改变" class="headerlink" title="2.宽度和高度可以随意改变"></a>2.宽度和高度可以随意改变</h5><p>思路：<br>  父元素相对定位<br>  子元素绝对定位 </p><p>子元素{</p><p>left: 0;top: 0; bottom:0;right:0;</p><p>margin:auto;</p><p>}</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#box</span>&#123;</span><br><span class="line">     <span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">     <span class="attribute">position</span>: relative;</span><br><span class="line">     <span class="attribute">background</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="selector-id">#box1</span>&#123;</span><br><span class="line">     <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">     position: absolute;//四个方位定义盒子所在的位置 当所有为0&amp;&amp;margin:auto时,盒子居中 </span><br><span class="line">     <span class="selector-tag">top</span>: 0;</span><br><span class="line">     <span class="selector-tag">right</span>: 0;</span><br><span class="line">     <span class="selector-tag">bottom</span>: 0;</span><br><span class="line">     <span class="selector-tag">left</span>: 0;</span><br><span class="line">     <span class="selector-tag">margin</span>: <span class="selector-tag">auto</span>;</span><br><span class="line">     <span class="selector-tag">background</span>: <span class="selector-tag">green</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="3-flex布局"><a href="#3-flex布局" class="headerlink" title="3.flex布局"></a>3.flex布局</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">           <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">           <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">           <span class="attribute">background</span>: <span class="number">#f99</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="selector-class">.box1</span>&#123;</span><br><span class="line">           <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">           <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">           <span class="attribute">background</span>: green;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="selector-class">.center</span>&#123;</span><br><span class="line">           display: flex;  //开启弹性盒子 主轴侧轴交叉得到居中</span><br><span class="line">           justify-content: center;//实现水平居中</span><br><span class="line">           align-items: center;//实现垂直居中</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h5 id="4-平移-定位-transform"><a href="#4-平移-定位-transform" class="headerlink" title="4.平移 定位+transform"></a>4.平移 定位+transform</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent_box</span>&#123;</span><br><span class="line">          <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">          <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">          <span class="attribute">background</span>: red;</span><br><span class="line">          <span class="attribute">position</span>: relative;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="selector-class">.child_box</span>&#123;</span><br><span class="line">          <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">          <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">          <span class="attribute">background</span>: green;</span><br><span class="line">          position: absolute;//与第一个类似 但可以根据子元素的宽高自动居中</span><br><span class="line">          <span class="selector-tag">top</span>: 50%;</span><br><span class="line">          <span class="selector-tag">left</span>: 50%;</span><br><span class="line">          transform: translate( -50%,-50%);//平移相当于盒子margin(左,上)减半</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="如何清除浮动"><a href="#如何清除浮动" class="headerlink" title="如何清除浮动"></a>如何清除浮动</h3><p>清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。</p><h4 id="父级添加overflow属性方法"><a href="#父级添加overflow属性方法" class="headerlink" title="父级添加overflow属性方法"></a>父级添加overflow属性方法</h4><p>可以通过触发BFC的方式，可以实现清除浮动效果。</p><h4 id="使用after伪元素清除浮动"><a href="#使用after伪元素清除浮动" class="headerlink" title="使用after伪元素清除浮动"></a>使用after伪元素清除浮动</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>; </span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">  <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;   </span><br><span class="line">.clearfix &#123;*zoom: 1;&#125;   /* IE6、7 专有 */</span><br></pre></td></tr></table></figure><h4 id="使用before和after双伪元素清除浮动"><a href="#使用before和after双伪元素清除浮动" class="headerlink" title="使用before和after双伪元素清除浮动"></a>使用before和after双伪元素清除浮动</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:before</span>,<span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123; </span><br><span class="line">  <span class="attribute">content</span>:<span class="string">""</span>;</span><br><span class="line">  <span class="attribute">display</span>:table;  <span class="comment">/* 这句话可以触发BFC BFC可以清除浮动 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line"> <span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">  *zoom:1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="浏览器查询Unicode编码"><a href="#浏览器查询Unicode编码" class="headerlink" title="浏览器查询Unicode编码"></a>浏览器查询Unicode编码</h3><p> 浏览器控制台输出   escape(‘查询字符串’)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; title=&quot;HTML&quot;&gt;&lt;/a&gt;HTML&lt;/h1&gt;&lt;h3 id=&quot;盒子居中的方法：&quot;&gt;&lt;a href=&quot;#盒子居中的方法：&quot; class=&quot;headerlink&quot; title=&quot;盒
      
    
    </summary>
    
      <category term="知识" scheme="http://wang-zhibiao.github.io/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="debug" scheme="http://wang-zhibiao.github.io/tags/debug/"/>
    
      <category term="css" scheme="http://wang-zhibiao.github.io/tags/css/"/>
    
      <category term="html" scheme="http://wang-zhibiao.github.io/tags/html/"/>
    
  </entry>
  
</feed>
