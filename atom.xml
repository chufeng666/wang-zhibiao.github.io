<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wang-zhibiao&#39;blog</title>
  
  <subtitle>I am is a boy</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wang-zhibiao.github.io/"/>
  <updated>2019-07-01T01:20:12.648Z</updated>
  <id>http://wang-zhibiao.github.io/</id>
  
  <author>
    <name>wangzhibiao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS全局污染</title>
    <link href="http://wang-zhibiao.github.io/2019/06/20/JS%E5%85%A8%E5%B1%80%E6%B1%A1%E6%9F%93/"/>
    <id>http://wang-zhibiao.github.io/2019/06/20/JS全局污染/</id>
    <published>2019-06-20T11:50:59.000Z</published>
    <updated>2019-07-01T01:20:12.648Z</updated>
    
    <content type="html"><![CDATA[<p>所谓全局变量污染 ：定义多个全局变量，函数，对象挂载在window上，如果重复使用则造成变量冲突</p><p>如果定义一个全局变量则会在window上挂载这个变量，所有的函数，对象，引用此js文件的都可以使用，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/输出</span></span><br><span class="line"><span class="regexp">Window</span></span><br><span class="line"><span class="regexp">a: 10</span></span><br><span class="line"><span class="regexp">alert: ƒ alert()</span></span><br><span class="line"><span class="regexp">applicationCache: ApplicationCache &#123;status: 0, oncached: null, onchecking: null, ondownloading: null, onerror: null, …&#125;</span></span><br><span class="line"><span class="regexp">。。。。。。。</span></span><br></pre></td></tr></table></figure><h3 id="污染"><a href="#污染" class="headerlink" title="污染"></a>污染</h3><p>如同衣物沾上污渍，笔墨落入清水。</p><p>全局window是大家都能使用，如果在全局挂载变量太多，难免会调用重复的变量，改变其属性或值。</p><p>在开发中，多人共同开发，每个人的代码习惯不同，命名方法不同，如果其他人命名一个变量ID，那么，在调用ID时会改变上一个人的ID导致不是自己想要的ID。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//developer_first.js</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> ID = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(ID);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/developer_second.js</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    var ID = 2;</span></span><br><span class="line"><span class="regexp">console.log(ID);</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line"><span class="comment">//developer_thirdly.js</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> ID = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(ID);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/在主文件中调用</span></span><br><span class="line"><span class="regexp">&lt;head&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="developer_first.js"&gt;&lt;/</span>script&gt;</span><br><span class="line">&lt;script src=<span class="string">"developer_second.js"</span>&gt;&lt;/script&gt;  </span><br><span class="line">&lt;script src=<span class="string">"developer_thirdly.js"</span>&gt;&lt;/script&gt;   <span class="comment">//最后的</span></span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/=&gt;输出  4 4 4</span></span><br></pre></td></tr></table></figure><p>ID会使用最后调用的js文件</p><p>为了避免全局污染，应慎重使用全局变量。了解模块化，或者let 定义的let不在window里 在script内有效</p><p>或者函数{}内有效，形成块级作用域</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;所谓全局变量污染 ：定义多个全局变量，函数，对象挂载在window上，如果重复使用则造成变量冲突&lt;/p&gt;
&lt;p&gt;如果定义一个全局变量则会在window上挂载这个变量，所有的函数，对象，引用此js文件的都可以使用，&lt;/p&gt;
&lt;figure class=&quot;highlight j
      
    
    </summary>
    
      <category term="javascript" scheme="http://wang-zhibiao.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://wang-zhibiao.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>隐藏元素的方法</title>
    <link href="http://wang-zhibiao.github.io/2019/06/12/%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://wang-zhibiao.github.io/2019/06/12/隐藏元素的方法/</id>
    <published>2019-06-11T16:10:56.000Z</published>
    <updated>2019-06-29T07:50:17.857Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>隐藏类型</p></blockquote><p>屏幕并不是唯一的输出机制，比如说屏幕上看不见的元素（隐藏的元素），其中一些依然能够被读屏软件阅读出来（因为读屏软件依赖于可访问性树来阐述）。为了消除它们之间的歧义，我们将其归为三大类：</p><ul><li>完全隐藏：元素从DOM树中消失，不占据空间。</li><li>视觉上的隐藏：屏幕中不可见，占据空间。</li><li>语义上的隐藏：读屏软件不可读，但正常占据空间。</li></ul><blockquote><p>完全隐藏</p></blockquote><h4 id="1-display-属性"><a href="#1-display-属性" class="headerlink" title="1.display 属性"></a>1.<code>display</code> 属性</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">none</span>;</span><br></pre></td></tr></table></figure><h4 id="2-hidden-属性"><a href="#2-hidden-属性" class="headerlink" title="2.hidden 属性"></a>2.hidden 属性</h4><blockquote><p>HTML5 新增属性，相当于 <code>display: none</code></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">hidden</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>视觉上的隐藏,在页面中还存在</p></blockquote><h4 id="3-利用-position-和-盒模型-将元素移出可视区范围"><a href="#3-利用-position-和-盒模型-将元素移出可视区范围" class="headerlink" title="3.利用 position 和 盒模型 将元素移出可视区范围"></a>3.利用 <code>position</code> 和 盒模型 将元素移出可视区范围</h4><blockquote><p>设置 <code>posoition</code> 为 <code>absolute</code> 或 <code>fixed</code>，通过设置 <code>top</code>、<code>left</code> 等值，将其移出可视区域。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">position</span><span class="selector-pseudo">:absolute</span>;</span><br><span class="line"><span class="selector-tag">left</span>: <span class="selector-tag">-999px</span>;</span><br></pre></td></tr></table></figure><blockquote><p>设置 <code>position</code> 为 <code>relative</code>，通过设置 <code>top</code>、<code>left</code> 等值，将其移出可视区域。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">relative</span>;</span><br><span class="line"><span class="selector-tag">left</span>: <span class="selector-tag">-999px</span>;</span><br></pre></td></tr></table></figure><blockquote><p>设置 margin 值，将其移出可视区域范围（可视区域占位）。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">margin-left</span>: <span class="selector-tag">-99999px</span>;</span><br><span class="line"><span class="selector-tag">height</span>: 0;</span><br></pre></td></tr></table></figure><h4 id="3-利用-transfrom"><a href="#3-利用-transfrom" class="headerlink" title="3.利用 transfrom"></a>3.利用 transfrom</h4><blockquote><p>缩放</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">scale</span>(0);</span><br><span class="line"><span class="selector-tag">height</span>: 0;</span><br></pre></td></tr></table></figure><blockquote><p>移动 <code>translateX</code>, <code>translateY</code></p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateX</span>(<span class="selector-tag">-99999px</span>);</span><br><span class="line"><span class="selector-tag">height</span>: 0</span><br></pre></td></tr></table></figure><blockquote><p>旋转 <code>rotate</code></p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform: rotateY(90deg) //直角在界面上形成线性视觉屏蔽</span><br></pre></td></tr></table></figure><h4 id="4-设置其大小为0"><a href="#4-设置其大小为0" class="headerlink" title="4.设置其大小为0"></a>4.设置其大小为0</h4><blockquote><p>宽高为0，字体大小为0：</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">height</span>: 0;</span><br><span class="line"><span class="selector-tag">width</span>: 0;</span><br><span class="line"><span class="selector-tag">font-size</span>: 0;</span><br></pre></td></tr></table></figure><blockquote><p>宽高为0，超出隐藏:</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">height</span>: 0;</span><br><span class="line"><span class="selector-tag">width</span>: 0;</span><br><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br></pre></td></tr></table></figure><h4 id="5-设置透明度为0"><a href="#5-设置透明度为0" class="headerlink" title="5.设置透明度为0"></a>5.设置透明度为0</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">opacity</span>: 0;</span><br></pre></td></tr></table></figure><h4 id="6-visibility属性"><a href="#6-visibility属性" class="headerlink" title="6.visibility属性"></a>6.<code>visibility</code>属性</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">visibility</span>: <span class="selector-tag">hidden</span>;</span><br></pre></td></tr></table></figure><h4 id="7-层级覆盖，z-index-属性"><a href="#7-层级覆盖，z-index-属性" class="headerlink" title="7.层级覆盖，z-index 属性"></a>7.层级覆盖，<code>z-index</code> 属性</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">relative</span>;</span><br><span class="line"><span class="selector-tag">z-index</span>: <span class="selector-tag">-999</span>;</span><br></pre></td></tr></table></figure><h5 id="再设置一个层级较高的元素覆盖在此元素上。"><a href="#再设置一个层级较高的元素覆盖在此元素上。" class="headerlink" title="再设置一个层级较高的元素覆盖在此元素上。"></a>再设置一个层级较高的元素覆盖在此元素上。</h5><h4 id="8-clip-path-裁剪"><a href="#8-clip-path-裁剪" class="headerlink" title="8.clip-path 裁剪"></a>8.clip-path 裁剪</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">clip-path</span>: <span class="selector-tag">polygon</span>(0 0, 0 0, 0 0, 0 0);</span><br></pre></td></tr></table></figure><p><strong>语义上的隐藏</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;隐藏类型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;屏幕并不是唯一的输出机制，比如说屏幕上看不见的元素（隐藏的元素），其中一些依然能够被读屏软件阅读出来（因为读屏软件依赖于可访问性树来阐述）。为了消除它们之间的歧义，我们将其归为三大类：&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="基础" scheme="http://wang-zhibiao.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="javascript" scheme="http://wang-zhibiao.github.io/tags/javascript/"/>
    
      <category term="function" scheme="http://wang-zhibiao.github.io/tags/function/"/>
    
  </entry>
  
  <entry>
    <title>BFC协议</title>
    <link href="http://wang-zhibiao.github.io/2019/06/12/BFC%E5%8D%8F%E8%AE%AE/"/>
    <id>http://wang-zhibiao.github.io/2019/06/12/BFC协议/</id>
    <published>2019-06-11T16:10:56.000Z</published>
    <updated>2019-06-29T07:50:29.866Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是BFC？BFC的布局规则是什么？如何创建BFC？"><a href="#什么是BFC？BFC的布局规则是什么？如何创建BFC？" class="headerlink" title="什么是BFC？BFC的布局规则是什么？如何创建BFC？"></a>什么是BFC？BFC的布局规则是什么？如何创建BFC？</h3><p><strong>查看解析</strong></p><ul><li>Box 是 CSS 布局的对象和基本单位，页面是由若干个Box组成的。</li><li>元素的类型 和 <code>display</code> 属性，决定了这个 Box 的类型。不同类型的 Box 会参与不同的 Formatting Context。</li></ul><blockquote><h4 id="Formatting-Context"><a href="#Formatting-Context" class="headerlink" title="Formatting Context"></a>Formatting Context</h4></blockquote><ul><li>Formatting Context 是页面的一块渲染区域，并且有一套渲染规则，决定了其子元素将如何定位，以及和其它元素的关系和相互作用。</li><li>Formatting Context 有 BFC (Block formatting context)，IFC (Inline formatting context)，FFC (Flex formatting context) 和 GFC (Grid formatting context)。FFC 和 GFC 为 CC3 中新增。</li></ul><blockquote><h4 id="BFC布局规则"><a href="#BFC布局规则" class="headerlink" title="BFC布局规则"></a><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.w3.org%2FTR%2F2011%2FREC-CSS2-20110607%2Fvisuren.html%23block-formatting" target="_blank" rel="noopener">BFC布局规则</a></h4></blockquote><ul><li>BFC内，盒子依次垂直排列。</li><li>BFC内，两个盒子的垂直距离由 <code>margin</code> 属性决定。属于同一个BFC的两个相邻Box的margin会发生重叠【符合合并原则的margin合并后是使用大的margin】</li><li>BFC内，每个盒子的左外边缘接触内部盒子的左边缘（对于从右到左的格式，右边缘接触）。即使在存在浮动的情况下也是如此。除非创建新的BFC。</li><li>BFC的区域不会与float box重叠。</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li><li>计算BFC的高度时，浮动元素也参与计算。</li></ul><blockquote><h4 id="如何创建BFC"><a href="#如何创建BFC" class="headerlink" title="如何创建BFC"></a>如何创建BFC</h4></blockquote><h2 id="根元素"><a href="#根元素" class="headerlink" title="根元素"></a>根元素</h2><ul><li>浮动元素（float 属性不为 none）</li><li>position 为 absolute 或 fixed</li><li>overflow 不为 visible 的块元素</li><li>display 为 inline-block, table-cell, table-caption</li></ul><blockquote><p>BFC 的应用</p></blockquote><ul><li>防止 margin  重叠 (同一个BFC内的两个两个相邻Box的 <code>margin</code> 会发生重叠，触发生成两个BFC，即不会重叠)</li><li>清除内部浮动 (创建一个新的 BFC，因为根据 BFC 的规则，计算 BFC 的高度时，浮动元素也参与计算)</li><li>自适应多栏布局 (BFC的区域不会与float box重叠。因此，可以触发生成一个新的BFC)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是BFC？BFC的布局规则是什么？如何创建BFC？&quot;&gt;&lt;a href=&quot;#什么是BFC？BFC的布局规则是什么？如何创建BFC？&quot; class=&quot;headerlink&quot; title=&quot;什么是BFC？BFC的布局规则是什么？如何创建BFC？&quot;&gt;&lt;/a&gt;什么是BF
      
    
    </summary>
    
      <category term="javascript" scheme="http://wang-zhibiao.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://wang-zhibiao.github.io/tags/javascript/"/>
    
      <category term="function" scheme="http://wang-zhibiao.github.io/tags/function/"/>
    
  </entry>
  
  <entry>
    <title>let var const三种定义方式及闭包</title>
    <link href="http://wang-zhibiao.github.io/2019/06/12/var%20let%20const%E4%B8%89%E7%A7%8D%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F%E5%8F%8A%E9%97%AD%E5%8C%85/"/>
    <id>http://wang-zhibiao.github.io/2019/06/12/var let const三种定义方式及闭包/</id>
    <published>2019-06-11T16:10:56.000Z</published>
    <updated>2019-06-29T03:24:17.522Z</updated>
    
    <content type="html"><![CDATA[<h3 id="let-var-const-之间的区别"><a href="#let-var-const-之间的区别" class="headerlink" title="let var const 之间的区别"></a>let var const 之间的区别</h3><h4 id="var"><a href="#var" class="headerlink" title="var"></a>var</h4><p>var的作用域是根据函数作用域的， 他在函数内起作用   这里就引用到闭包和作用域链</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">out</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">000</span>; <span class="comment">//=&gt; 这个a的作用域作用在out内 而info函数在out函数内 所以可以调用</span></span><br><span class="line">b=<span class="number">222</span> <span class="comment">//=&gt; 报错err 因为b的作用域在info函数内 包裹他的out函数不可以调用它</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">info</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b=<span class="number">999</span>;</span><br><span class="line">a= <span class="number">111</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>var 的变量提升</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a=<span class="number">10</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//变量提升 就是var定义的变量会在先声明再赋值 提升到函数顶部</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  a=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><p>let的作用域的块级作用域，不会变量提升  可以理解为在某块范围内作用 与var 的函数作用域不同在于 let的作用域会形成闭包</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出 3 3 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出 0 1 2</span></span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var会在全局声明 而setTimeout 是一个定时器 也是异步回调  会在同步执行完毕再执行异步 所以当for循环完毕 i=3时调用三次定时器  </span><br><span class="line">let 的作用范围会在for循环内 每循环一次 i会形成一次闭包  i会被setTimeout调用</span><br></pre></td></tr></table></figure><h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p>const代表一个值的常量索引，常量的值在垃圾回收前永远不能改变，所以需要谨慎使用。</p><p>cosnt定义的值不能被改变 否则会报错</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Uncaught TypeError: Assignment to constant variable.</span><br><span class="line">未捕获的类型错误:赋值给常量变量。</span><br></pre></td></tr></table></figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>外部可以访问内部的私有变量</p><p>可以返回携带状态的函数，并且状态隐藏 可以做到变量的私有</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n=<span class="number">999</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(n); <span class="comment">// 999</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p><p>既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function f1()&#123;</span><br><span class="line">var n=999;</span><br><span class="line">function f2()&#123;</span><br><span class="line">alert(n); </span><br><span class="line">&#125;</span><br><span class="line">return f2;</span><br><span class="line">&#125;</span><br><span class="line">var result=f1();</span><br><span class="line">result(); // 999</span><br></pre></td></tr></table></figure><p>闭包就是能够读取其他函数内部变量的函数</p><p>要形成闭包 必须两层function函数作用域</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function f1()&#123;</span><br><span class="line">  var n=999;</span><br><span class="line">  Add=function()&#123;n+=1&#125;</span><br><span class="line">  function f2()&#123;</span><br><span class="line">  console.log(n)</span><br><span class="line">&#125;</span><br><span class="line">return f2;</span><br><span class="line">&#125;</span><br><span class="line">var result=f1();</span><br><span class="line">result(); // 999</span><br><span class="line">Add();</span><br><span class="line">result(); // 1000</span><br></pre></td></tr></table></figure><p>这里形成闭包后，f1的局部变量n一直保存在内存中，并没有因为f1的重复调用而清除</p><p>原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p><p>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">  name: <span class="string">"My Object"</span>,</span><br><span class="line">  getNameFunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getNameFunc()());</span><br></pre></td></tr></table></figure><p>经典闭包题</p><p>个人理解</p><p>object.getNameFunc()  执行到这一步时 调用object内的函数 返回一个function（）{return this.name} 这时候 name还是My Object  当再次执行时object.getNameFunc()()  调用了外部的name 输出为The Window</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;let-var-const-之间的区别&quot;&gt;&lt;a href=&quot;#let-var-const-之间的区别&quot; class=&quot;headerlink&quot; title=&quot;let var const 之间的区别&quot;&gt;&lt;/a&gt;let var const 之间的区别&lt;/h3&gt;&lt;h4 i
      
    
    </summary>
    
      <category term="javascript" scheme="http://wang-zhibiao.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://wang-zhibiao.github.io/tags/javascript/"/>
    
      <category term="function" scheme="http://wang-zhibiao.github.io/tags/function/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript的变量以及数据类型</title>
    <link href="http://wang-zhibiao.github.io/2019/06/09/%E5%8F%98%E9%87%8F%E5%92%8Cjs%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://wang-zhibiao.github.io/2019/06/09/变量和js类型的理解/</id>
    <published>2019-06-09T01:24:56.000Z</published>
    <updated>2019-06-24T03:30:23.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、JavaScript数据类型"><a href="#一、JavaScript数据类型" class="headerlink" title="一、JavaScript数据类型"></a>一、JavaScript数据类型</h2><p>ECMAScript标准规定了<code>7</code>种数据类型，其把这<code>7</code>种数据类型又分为两种：原始类型和对象类型。</p><h3 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a><strong>原始类型</strong></h3><ul><li><code>Null</code>：只包含一个值：<code>null</code></li><li><code>Undefined</code>：只包含一个值：<code>undefined</code></li><li><code>Boolean</code>：包含两个值：<code>true</code>和<code>false</code></li><li><code>Number</code>：整数或浮点数，还有一些特殊值（<code>-Infinity</code>、<code>+Infinity</code>、<code>NaN</code>）</li><li><code>String</code>：一串表示文本值的字符序列</li><li><code>Symbol</code>：一种实例是唯一且不可改变的数据类型</li></ul><p>(在<code>es10</code>中加入了第七种原始类型<code>BigInt</code>，现已被最新<code>Chrome</code>支持)</p><h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a><strong>对象类型</strong></h3><ul><li><p><code>Object</code>：自己分一类丝毫不过分，除了常用的<code>Object</code>，<code>Array</code>、<code>Function</code>等都属于特殊的对象</p><blockquote><p>区分原始类型和对象类型 - 不可变性</p></blockquote></li></ul><p>原始类型存放在栈空间中，而复杂类型存放在堆空间中</p><h3 id="栈内存："><a href="#栈内存：" class="headerlink" title="栈内存："></a>栈内存：</h3><ul><li>存储的值大小固定</li><li>空间较小</li><li>可以直接操作其保存的变量，运行效率高</li><li>由系统自动分配存储空间</li></ul><h3 id="堆内存："><a href="#堆内存：" class="headerlink" title="堆内存："></a>堆内存：</h3><ul><li>存储的值大小不定，可动态调整</li><li>空间较大，运行效率低</li><li>无法直接操作其内部存储，使用引用地址读取</li><li>通过代码进行分配空间</li></ul><h4 id="字符串-具备不可变性"><a href="#字符串-具备不可变性" class="headerlink" title="字符串 具备不可变性"></a><code>字符串 具备不可变性</code></h4><p>不管是字符串的裁切splice 还是 toLowerCase 都是在原有的基础上产生新的字符串</p><p><code>JavaScript</code>中的原始类型的值被直接存储在栈中，在变量定义时，栈就为其分配好了内存空间。</p><p>由于栈中的内存空间的大小是固定的，那么注定了存储在栈中的变量就是不可变的</p><h4 id="对象-具备可变性"><a href="#对象-具备可变性" class="headerlink" title="对象 具备可变性"></a><code>对象 具备可变性</code></h4><p>引用类型的值实际存储在堆内存中，它在栈中只存储了一个固定长度的地址，这个地址指向堆内存中的值。</p><p>数组  是一个复杂（引用）类型</p><h4 id="通过一些api可以改变数组"><a href="#通过一些api可以改变数组" class="headerlink" title="通过一些api可以改变数组"></a>通过一些api可以改变数组</h4><ul><li><code>pop()</code> 删除数组最后一个元素，如果数组为空，则不改变数组，返回undefined，改变原数组，返回被删除的元素</li><li><code>push()</code>向数组末尾添加一个或多个元素，改变原数组，返回新数组的长度</li><li><code>shift()</code>把数组的第一个元素删除，若空数组，不进行任何操作，返回undefined,改变原数组，返回第一个元素的值</li><li><code>unshift()</code>向数组的开头添加一个或多个元素，改变原数组，返回新数组的长度</li><li><code>reverse()</code>颠倒数组中元素的顺序，改变原数组，返回该数组</li><li><code>sort()</code>对数组元素进行排序，改变原数组，返回该数组</li><li><code>splice()</code>从数组中添加/删除项目，改变原数组，返回被删除的元素</li></ul><p>当我们进行复制时两者有着本质的区别</p><p>这里涉及到浅拷贝和深拷贝—本质是复制时是否改变复制的对象的数值或属性或方法</p><h4 id="原始类型-1"><a href="#原始类型-1" class="headerlink" title="原始类型"></a>原始类型</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'wang'</span>;</span><br><span class="line"><span class="keyword">var</span> newName = name;</span><br><span class="line">newName = <span class="string">'Mr.wang'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// =&gt;wang</span></span><br><span class="line"><span class="built_in">console</span>.log(newName) <span class="comment">// =&gt;Mr.wang</span></span><br></pre></td></tr></table></figure><p>内存中有一个变量<code>name</code>，值为<code>wang</code>。我们从变量<code>name</code>复制出一个变量<code>newName</code>，此时在内存中创建了一个块新的空间用于存储<code>wang</code>，虽然两者值是相同的，但是两者指向的内存空间完全不同，这两个变量参与任何操作都互不影响。</p><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">'wang'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> newObj = obj;</span><br><span class="line">newObj.name = <span class="string">'Mr.wang'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name) <span class="comment">//=&gt; Mr.wang</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.name)<span class="comment">//=&gt; Mr.wang</span></span><br></pre></td></tr></table></figure><p>当我们复制引用类型的变量时，实际上复制的是栈中存储的地址，所以复制出来的<code>newObj</code>实际上和<code>obj</code>指向的堆中同一个对象。因此，我们改变其中任何一个变量的值，另一个变量都会受到影响，这就是为什么会有深拷贝和浅拷贝的原因。</p><h3 id="原始类型和引用类型的比较"><a href="#原始类型和引用类型的比较" class="headerlink" title="原始类型和引用类型的比较"></a>原始类型和引用类型的比较</h3><p>原始类型，比较时会直接比较它们的值，如果值相等，即返回<code>true</code>。</p><p>引用类型，比较时会比较它们的引用地址，虽然两个变量在堆中存储的对象具有的属性值都是相等的，但是它们被存储在了不同的存储空间，因此比较值为<code>false</code>。</p><h4 id="区分null和undefined"><a href="#区分null和undefined" class="headerlink" title="区分null和undefined"></a>区分null和undefined</h4><p><strong>null</strong></p><p>表示被赋值过的对象，刻意把一个对象赋值为<code>null</code>，故意表示其为空，不应有值。</p><p>所以对象的某个属性值为<code>null</code>是正常的，<code>null</code>转换为数值时值为<code>0</code>。</p><p><strong>undefined</strong></p><p>表示“缺少值”，即此处应有一个值，但还没有定义，</p><p>如果一个对象的某个属性值为<code>undefined</code>，这是不正常的，如<code>obj.name=undefined</code>，我们不应该这样写，应该直接<code>delete obj.name</code>。</p><p><code>undefined</code>转为数值时为<code>NaN</code>(非数字值的特殊值)<img src="https://raw.githubusercontent.com/wang-zhibiao/wang-zhibiao.github.io/master/img/nullAndundefined.png" alt="nullAndundefined.png"></p><p><code>JavaScript</code>是一门动态类型语言，成员除了表示存在的空值外，还有可能根本就不存在（因为存不存在只在运行期才知道），这就是<code>undefined</code>的意义所在。对于<code>JAVA</code>这种强类型语言，如果有<code>&quot;undefined&quot;</code>这种情况，就会直接编译失败，所以在它不需要一个这样的类型。</p><h4 id="你想不到的0-1-0-2≠0-3"><a href="#你想不到的0-1-0-2≠0-3" class="headerlink" title="你想不到的0.1+0.2≠0.3"></a>你想不到的0.1+0.2≠0.3</h4><blockquote><p>本质是：由于数字在js中的计算是先转换为二进制在进行计算的，然后以十进制输出</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">judgeFloat</span>(<span class="params">n, m</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> binaryN = n.toString(<span class="number">2</span>);</span><br><span class="line">      <span class="keyword">const</span> binaryM = m.toString(<span class="number">2</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;n&#125;</span>的二进制是    <span class="subst">$&#123;binaryN&#125;</span>`</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;m&#125;</span>的二进制是    <span class="subst">$&#123;binaryM&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">const</span> MN = m + n;</span><br><span class="line">      <span class="keyword">const</span> accuracyMN = (m * <span class="number">100</span> + n * <span class="number">100</span>) / <span class="number">100</span>;</span><br><span class="line">      <span class="keyword">const</span> binaryMN = MN.toString(<span class="number">2</span>);</span><br><span class="line">      <span class="keyword">const</span> accuracyBinaryMN = accuracyMN.toString(<span class="number">2</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;n&#125;</span>+<span class="subst">$&#123;m&#125;</span>的二进制是<span class="subst">$&#123;binaryMN&#125;</span>`</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;accuracyMN&#125;</span>的二进制是    <span class="subst">$&#123;accuracyBinaryMN&#125;</span>`</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;n&#125;</span>+<span class="subst">$&#123;m&#125;</span>的二进制再转成十进制是<span class="subst">$&#123;to10(binaryMN)&#125;</span>`</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;accuracyMN&#125;</span>的二进制是再转成十进制是<span class="subst">$&#123;to10(accuracyBinaryMN)&#125;</span>`</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;n&#125;</span>+<span class="subst">$&#123;m&#125;</span>在js中计算是<span class="subst">$&#123;(to10(binaryMN) === to10(accuracyBinaryMN)) ? <span class="string">''</span> : <span class="string">'不'</span>&#125;</span>准确的`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">to10</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> pre = (n.split(<span class="string">'.'</span>)[<span class="number">0</span>] - <span class="number">0</span>).toString(<span class="number">2</span>);</span><br><span class="line">      <span class="keyword">const</span> arr = n.split(<span class="string">'.'</span>)[<span class="number">1</span>].split(<span class="string">''</span>);</span><br><span class="line">      <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (i &lt; arr.length) &#123;</span><br><span class="line">        result += arr[i] * <span class="built_in">Math</span>.pow(<span class="number">2</span>, -(i + <span class="number">1</span>));</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    judgeFloat(<span class="number">0.1</span>, <span class="number">0.2</span>);</span><br><span class="line">    judgeFloat(<span class="number">0.6</span>, <span class="number">0.7</span>);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wang-zhibiao/wang-zhibiao.github.io/master/img/0.1+0.2.jpg" alt="0.1+0.2"></p><p>计算机中所有的数据都是以<code>二进制</code>存储的，所以在计算时计算机要把数据先转换成<code>二进制</code>进行计算，然后在把计算结果转换成<code>十进制</code>。</p><p>由上面的代码不难看出，在计算<code>0.1+0.2</code>时，<code>二进制</code>计算发生了精度丢失，导致再转换成<code>十进制</code>后和预计的结果不符。</p><h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><p><img src="https://raw.githubusercontent.com/wang-zhibiao/wang-zhibiao.github.io/master/img/%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2.jpg" alt="隐式转换"></p><h3 id="if语句和逻辑语句"><a href="#if语句和逻辑语句" class="headerlink" title="if语句和逻辑语句"></a>if语句和逻辑语句</h3><p>在<code>if</code>语句和逻辑语句中，如果只有单个变量，会先将变量转换为<code>Boolean</code>值，只有下面几种情况会转换成<code>false</code>，其余被转换成<code>true</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">undefined</span><br><span class="line">&apos;&apos;</span><br><span class="line">NaN</span><br><span class="line">0</span><br><span class="line">false</span><br></pre></td></tr></table></figure><h3 id="各种运数学算符"><a href="#各种运数学算符" class="headerlink" title="各种运数学算符"></a>各种运数学算符</h3><p>我们在对各种非<code>Number</code>类型运用数学运算符(<code>- * /</code>)时，会先将非<code>Number</code>类型转换为<code>Number</code>类型;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 - true // 0</span><br><span class="line">1 - null //  1</span><br><span class="line">1 * undefined //  NaN</span><br><span class="line">2 * [&apos;5&apos;] //  10</span><br></pre></td></tr></table></figure><p>注意<code>+</code>是个例外，执行<code>+</code>操作符时：</p><ul><li>1.当一侧为<code>String</code>类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。</li><li>2.当一侧为<code>Number</code>类型，另一侧为原始类型，则将原始类型转换为<code>Number</code>类型。</li><li>3.当一侧为<code>Number</code>类型，另一侧为引用类型，将引用类型和<code>Number</code>类型转换成字符串后拼接。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">123 + &apos;123&apos; // 123123   （规则1）</span><br><span class="line">123 + null  // 123    （规则2）</span><br><span class="line">123 + true // 124    （规则2）</span><br><span class="line">123 + &#123;&#125;  // 123[object Object]    （规则3）</span><br></pre></td></tr></table></figure><h3 id="运算符"><a href="#运算符" class="headerlink" title="== 运算符"></a>== 运算符</h3><p>使用<code>==</code>时，若两侧类型相同，则比较结果和<code>===</code>相同，否则会发生隐式转换，使用<code>==</code>时发生的转换可以分为几种不同的情况（只考虑两侧类型不同）：</p><ul><li><h5 id="1-NaN"><a href="#1-NaN" class="headerlink" title="1.NaN"></a><strong>1.NaN</strong></h5></li></ul><p><code>NaN</code>和其他任何类型比较永远返回<code>false</code>(包括和他自己)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NaN == NaN // false</span><br></pre></td></tr></table></figure><ul><li><h5 id="2-Boolean"><a href="#2-Boolean" class="headerlink" title="2.Boolean"></a><strong>2.Boolean</strong></h5></li></ul><p><code>Boolean</code>和其他任何类型比较，<code>Boolean</code>首先被转换为<code>Number</code>类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">true == 1  // true </span><br><span class="line">true == &apos;2&apos;  // false</span><br><span class="line">true == [&apos;1&apos;]  // true</span><br><span class="line">true == [&apos;2&apos;]  // false</span><br></pre></td></tr></table></figure><blockquote><p>这里注意一个可能会弄混的点：<code>undefined、null</code>和<code>Boolean</code>比较，虽然<code>undefined、null</code>和<code>false</code>都很容易被想象成假值，但是他们比较结果是<code>false</code>，原因是<code>false</code>首先被转换成<code>0</code>：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">undefined == false // false</span><br><span class="line">null == false // false</span><br></pre></td></tr></table></figure><ul><li><h5 id="3-String和Number"><a href="#3-String和Number" class="headerlink" title="3.String和Number"></a><strong>3.String和Number</strong></h5></li></ul><p><code>String</code>和<code>Number</code>比较，先将<code>String</code>转换为<code>Number</code>类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">123 == &apos;123&apos; // true</span><br><span class="line">&apos;&apos; == 0 // true</span><br></pre></td></tr></table></figure><ul><li><h5 id="4-null和undefined"><a href="#4-null和undefined" class="headerlink" title="4.null和undefined"></a><strong>4.null和undefined</strong></h5></li></ul><p><code>null == undefined</code>比较结果是<code>true</code>，除此之外，<code>null、undefined</code>和其他任何结果的比较值都为<code>false</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">null == undefined // true</span><br><span class="line">null == &apos;&apos; // false</span><br><span class="line">null == 0 // false</span><br><span class="line">null == false // false</span><br><span class="line">undefined == &apos;&apos; // false</span><br><span class="line">undefined == 0 // false</span><br><span class="line">undefined == false // false</span><br></pre></td></tr></table></figure><ul><li><h5 id="5-原始类型和引用类型"><a href="#5-原始类型和引用类型" class="headerlink" title="5.原始类型和引用类型"></a><strong>5.原始类型和引用类型</strong></h5></li></ul><p>当原始类型和引用类型做比较时，对象类型会依照<code>ToPrimitive</code>规则转换为原始类型:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;[object Object]&apos; == &#123;&#125; // true</span><br><span class="line">&apos;1,2,3&apos; == [1, 2, 3] // true</span><br></pre></td></tr></table></figure><p>来看看下面这个比较：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] == ![] // true</span><br></pre></td></tr></table></figure><p><code>!</code>的优先级高于<code>==</code>，<code>![]</code>首先会被转换为<code>false</code>，然后根据上面第三点，<code>false</code>转换成<code>Number</code>类型<code>0</code>，左侧<code>[]</code>转换为<code>0</code>，两侧比较相等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[null] == false // true</span><br><span class="line">[undefined] == false // true</span><br></pre></td></tr></table></figure><p>根据数组的<code>ToPrimitive</code>规则，数组元素为<code>null</code>或<code>undefined</code>时，该元素被当做空字符串处理，所以<code>[null]、[undefined]</code>都会被转换为<code>0</code>。</p><h4 id="原型链的规则"><a href="#原型链的规则" class="headerlink" title="原型链的规则"></a>原型链的规则</h4><ul><li>1.所有引用类型都具有对象特性，即可以自由扩展属性</li><li>2.所有引用类型都具有一个<code>proto</code>（隐式原型）属性，是一个普通对象</li><li>3.所有的函数都具有<code>prototype</code>（显式原型）属性，也是一个普通对象</li><li>4.所有引用类型<code>proto</code>值指向它构造函数的<code>prototype</code></li><li>5.当试图得到一个对象的属性时，如果变量本身没有这个属性，则会去他的<code>proto</code>中去找</li></ul><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><p>上面我们在拆箱操作中提到了<code>toString</code>函数，我们可以调用它实现从引用类型的转换。</p><blockquote><p>每一个引用类型都有<code>toString</code>方法，默认情况下，<code>toString()</code>方法被每个<code>Object</code>对象继承。如果此方法在自定义对象中未被覆盖，<code>toString()</code> 返回 <code>&quot;[object type]&quot;</code>，其中<code>type</code>是对象的类型。</p></blockquote><p><img src="https://raw.githubusercontent.com/wang-zhibiao/wang-zhibiao.github.io/master/img/tostring.jpg" alt="tostring"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、JavaScript数据类型&quot;&gt;&lt;a href=&quot;#一、JavaScript数据类型&quot; class=&quot;headerlink&quot; title=&quot;一、JavaScript数据类型&quot;&gt;&lt;/a&gt;一、JavaScript数据类型&lt;/h2&gt;&lt;p&gt;ECMAScript标准规定
      
    
    </summary>
    
      <category term="javascript" scheme="http://wang-zhibiao.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://wang-zhibiao.github.io/tags/javascript/"/>
    
  </entry>
  
</feed>
