<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wang-zhibiao&#39;blog</title>
  
  <subtitle>I am is a boy</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wang-zhibiao.github.io/"/>
  <updated>2019-07-01T01:20:12.648Z</updated>
  <id>http://wang-zhibiao.github.io/</id>
  
  <author>
    <name>wangzhibiao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS全局污染</title>
    <link href="http://wang-zhibiao.github.io/2019/06/20/JS%E5%85%A8%E5%B1%80%E6%B1%A1%E6%9F%93/"/>
    <id>http://wang-zhibiao.github.io/2019/06/20/JS全局污染/</id>
    <published>2019-06-20T11:50:59.000Z</published>
    <updated>2019-07-01T01:20:12.648Z</updated>
    
    <content type="html"><![CDATA[<p>所谓全局变量污染 ：定义多个全局变量，函数，对象挂载在window上，如果重复使用则造成变量冲突</p><p>如果定义一个全局变量则会在window上挂载这个变量，所有的函数，对象，引用此js文件的都可以使用，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/输出</span></span><br><span class="line"><span class="regexp">Window</span></span><br><span class="line"><span class="regexp">a: 10</span></span><br><span class="line"><span class="regexp">alert: ƒ alert()</span></span><br><span class="line"><span class="regexp">applicationCache: ApplicationCache &#123;status: 0, oncached: null, onchecking: null, ondownloading: null, onerror: null, …&#125;</span></span><br><span class="line"><span class="regexp">。。。。。。。</span></span><br></pre></td></tr></table></figure><h3 id="污染"><a href="#污染" class="headerlink" title="污染"></a>污染</h3><p>如同衣物沾上污渍，笔墨落入清水。</p><p>全局window是大家都能使用，如果在全局挂载变量太多，难免会调用重复的变量，改变其属性或值。</p><p>在开发中，多人共同开发，每个人的代码习惯不同，命名方法不同，如果其他人命名一个变量ID，那么，在调用ID时会改变上一个人的ID导致不是自己想要的ID。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//developer_first.js</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> ID = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(ID);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/developer_second.js</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    var ID = 2;</span></span><br><span class="line"><span class="regexp">console.log(ID);</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line"><span class="comment">//developer_thirdly.js</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> ID = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(ID);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/在主文件中调用</span></span><br><span class="line"><span class="regexp">&lt;head&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="developer_first.js"&gt;&lt;/</span>script&gt;</span><br><span class="line">&lt;script src=<span class="string">"developer_second.js"</span>&gt;&lt;/script&gt;  </span><br><span class="line">&lt;script src=<span class="string">"developer_thirdly.js"</span>&gt;&lt;/script&gt;   <span class="comment">//最后的</span></span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/=&gt;输出  4 4 4</span></span><br></pre></td></tr></table></figure><p>ID会使用最后调用的js文件</p><p>为了避免全局污染，应慎重使用全局变量。了解模块化，或者let 定义的let不在window里 在script内有效</p><p>或者函数{}内有效，形成块级作用域</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;所谓全局变量污染 ：定义多个全局变量，函数，对象挂载在window上，如果重复使用则造成变量冲突&lt;/p&gt;
&lt;p&gt;如果定义一个全局变量则会在window上挂载这个变量，所有的函数，对象，引用此js文件的都可以使用，&lt;/p&gt;
&lt;figure class=&quot;highlight j
      
    
    </summary>
    
      <category term="javascript" scheme="http://wang-zhibiao.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://wang-zhibiao.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>js常见的继承方式</title>
    <link href="http://wang-zhibiao.github.io/2019/06/20/js%E7%9A%84%E5%85%AD%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/"/>
    <id>http://wang-zhibiao.github.io/2019/06/20/js的六种继承方式/</id>
    <published>2019-06-20T01:10:56.000Z</published>
    <updated>2019-07-14T01:29:05.728Z</updated>
    
    <content type="html"><![CDATA[<p>js中的继承：在js中的继承只是属性和方法的继承 一般没有所谓的多态性，js的继承只是为了使代码的复用性更高。</p><h3 id="js的继承是通过prototype来继承的"><a href="#js的继承是通过prototype来继承的" class="headerlink" title="js的继承是通过prototype来继承的"></a>js的继承是通过prototype来继承的</h3><h4 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1 原型链继承"></a>1 原型链继承</h4><p>这种方式关键在于:**子类型的原型为父类型的一个实例对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//父类型</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name,</span><br><span class="line">    <span class="keyword">this</span>.age = age,</span><br><span class="line">    <span class="keyword">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Person.prototype.setAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="comment">//子类型</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.price = price</span><br><span class="line">    <span class="keyword">this</span>.setScore = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// Student.prototype.sayHello = function () &#123; &#125;//在这里写子类的原型方法和属性是无效的，</span></span><br><span class="line"><span class="comment">//因为会改变原型的指向，所以应该放到重新指定之后</span></span><br><span class="line">  Student.prototype = <span class="keyword">new</span> Person() <span class="comment">// 子类型的原型为父类型的一个实例对象</span></span><br><span class="line">  <span class="keyword">var</span> s1 = <span class="keyword">new</span> Student(<span class="number">15000</span>)</span><br><span class="line">  <span class="keyword">var</span> s2 = <span class="keyword">new</span> Student(<span class="number">14000</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(s1,s2)</span><br></pre></td></tr></table></figure><p>说明：定义一个Person父类型拥有对象和方法   <code>Person.prototype.setAge = function () {}</code> 这是一种在外部定义的一个在prototype原型上的方法 原理：每个function身上都有一个原型 在原型身上可以挂载方法和属性</p><p><code>Student.prototype = new Person()</code>  Student原型指向Person的实例对象，所以<strong>子类的实例就可以通过proto__访问到 Student.prototype 也就是Person的实例，这样就可以访问到父类的私有方法，然后再通过__proto指向父类的prototype就可以获得到父类原型上的方法</strong>。于是做到了将父类的私有、公有方法和属性都当做子类的公有属性</p><p>弊端：<strong>子类继承父类的属性和方法是将父类的私有属性和公有方法都作为自己的公有属性和方法</strong> 如果父类的私有属性有引用类型，子类继承的是这个父类的引用地址 如果子类操作父类的引用类型就会导致引用类型改变详情请看 <a href="[https://wang-zhibiao.github.io/2019/06/09/%E5%8F%98%E9%87%8F%E5%92%8Cjs%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3/](https://wang-zhibiao.github.io/2019/06/09/%E5%8F%98%E9%87%8F%E5%92%8Cjs%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3/)**">js数据类型</a></p><p><strong>我们需要在子类中添加新的方法或者是重写父类的方法时候，切记一定要放到替换原型的语句之后</strong></p><h4 id="2-借用构造函数继承"><a href="#2-借用构造函数继承" class="headerlink" title="2  借用构造函数继承"></a>2  借用构造函数继承</h4><p>这种方式关键在于:<strong>在子类型构造函数中通用call()调用父类型构造函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name,</span><br><span class="line">  <span class="keyword">this</span>.age = age,</span><br><span class="line">  <span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, price</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, name, age)  <span class="comment">// 相当于: this.Person(name, age)</span></span><br><span class="line">  <span class="comment">/*this.name = name</span></span><br><span class="line"><span class="comment">  this.age = age*/</span></span><br><span class="line">  <span class="keyword">this</span>.price = price</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Student(<span class="string">'Tom'</span>, <span class="number">20</span>, <span class="number">15000</span>)</span><br></pre></td></tr></table></figure><p>说明：在Student中构造Person的属性和方法，但是只是实现部分继承，如果父类的属性和方法太多，继承麻烦。但是解决了引用类型的问题因为这个构造函数是再次创建实例</p><p>弊端：子类的实例是根据父类的实例重新构造的，<strong>只能继承父类的实例属性和方法，不能继承原型属性和方法</strong> 代码复用性弱，每个子类都是父类的实例函数副本，影响性能</p><h4 id="3-原型链-借用构造函数的组合继承"><a href="#3-原型链-借用构造函数的组合继承" class="headerlink" title="3 原型链+借用构造函数的组合继承"></a>3 原型链+借用构造函数的组合继承</h4><p>这种方式关键在于:<strong>通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</strong> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name,</span><br><span class="line">  <span class="keyword">this</span>.age = age,</span><br><span class="line">  <span class="keyword">this</span>.setAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"111"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span> (<span class="params">name, age, price</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//第一次调用构造函数</span></span><br><span class="line">  Person.call(<span class="keyword">this</span>, name, age)</span><br><span class="line">  <span class="keyword">this</span>.price = price</span><br><span class="line">  <span class="keyword">this</span>.setScore = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 令Student的原型指向Person的实例</span></span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person()</span><br><span class="line">Student.prototype.constructor = Student<span class="comment">//组合继承也是需要修复构造函数指向的</span></span><br><span class="line">Student.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Student(<span class="string">'Tom'</span>, <span class="number">20</span>, <span class="number">15000</span>)</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> Student(<span class="string">'Jack'</span>, <span class="number">22</span>, <span class="number">14000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1)</span><br><span class="line"><span class="built_in">console</span>.log(s1.constructor) <span class="comment">//Student</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.constructor) <span class="comment">//Person</span></span><br></pre></td></tr></table></figure><p>说明：在子类中调用构造函数生成实例对象但是只是包含属性，在子类的原型链上继承Person的实例，再次使用构造函数，是刚继承的实例构造成一个新的实例赋值 这个实例属于Student  构造函数（constructor） –字面意思，能构造一个实例的函数 </p><p>弊端：无论如何都会调用两次构造函数，创建子类的原型和子类构造函数内部</p><h4 id="4-组合继承的优化-原型指向"><a href="#4-组合继承的优化-原型指向" class="headerlink" title="4 组合继承的优化-原型指向"></a>4 组合继承的优化-原型指向</h4><p>这种方式关键在于 <strong>通过父类原型和子类原型指向同一对象，子类可以继承到父类的公有方法当做自己的公有方法，而且不会初始化两次实例方法/属性，避免的组合继承的缺点</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name,</span><br><span class="line">  <span class="keyword">this</span>.age = age,</span><br><span class="line">  <span class="keyword">this</span>.setAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"111"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span> (<span class="params">name, age, price</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  Person.call(<span class="keyword">this</span>, name, age)</span><br><span class="line">  <span class="keyword">this</span>.price = price</span><br><span class="line">  <span class="keyword">this</span>.setScore = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原型的赋值</span></span><br><span class="line">Student.prototype = Person.prototype</span><br><span class="line">Student.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Student(<span class="string">'Tom'</span>, <span class="number">20</span>, <span class="number">15000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1)</span><br></pre></td></tr></table></figure><p>说明：原型的赋值会让两个类指向同一个对象 ，与上面的区别在于一个是构造函数的赋值 这是原型的赋值，不会生成两次实例</p><p>弊端：父类指向不明，都是原型的赋值 同一个对象，没有父子关系，引用类型问题，</p><h4 id="5-组合继承的优化-创建对象"><a href="#5-组合继承的优化-创建对象" class="headerlink" title="5 组合继承的优化-创建对象"></a>5 组合继承的优化-创建对象</h4><p>这种方式关键在于 <strong>借助原型可以基于已有的对象来创建对象，var B = Object.create(A)以A对象为原型，生成了B对象。B继承了A的所有属性和方法</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name,</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"111"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span> (<span class="params">name, age, price</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  Person.call(<span class="keyword">this</span>, name, age)</span><br><span class="line">  <span class="keyword">this</span>.price = price</span><br><span class="line">  <span class="keyword">this</span>.setScore = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = <span class="built_in">Object</span>.create(Person.prototype)<span class="comment">//核心代码</span></span><br><span class="line">Student.prototype.constructor = Student<span class="comment">//核心代码</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Student(<span class="string">'Tom'</span>, <span class="number">20</span>, <span class="number">15000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1 <span class="keyword">instanceof</span> Student, s1 <span class="keyword">instanceof</span> Person) <span class="comment">// true true</span></span><br><span class="line"><span class="built_in">console</span>.log(s1.constructor) <span class="comment">//Student</span></span><br><span class="line"><span class="built_in">console</span>.log(s1)</span><br></pre></td></tr></table></figure><p>说明：<code>Student.prototype = Object.create(Person.prototype)</code> 创建一个基于Person的的prototype创建一个新的对象给Student，继承Person 的所有的属性和方法 （Object.create）Object身上挂载create这个方法可以创建新的对象</p><p>目前来说，使用缺点都解决了，但是还未趋近完美</p><h4 id="6-Es6的class继承"><a href="#6-Es6的class继承" class="headerlink" title="6 Es6的class继承"></a>6 Es6的class继承</h4><p>ES6中引入了class关键字，class可以通过extends关键字实现继承，还可以通过static关键字定义类的静态方法,这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p><p>ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。</p><p><strong>需要注意的是，class关键字只是原型的语法糖，JavaScript继承仍然是基于原型实现的</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">//调用类的构造方法</span></span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//定义一般的方法</span></span><br><span class="line">  showName () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"调用父类的方法"</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person(<span class="string">'kobe'</span>, <span class="number">39</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1)</span><br><span class="line"><span class="comment">//定义一个子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age, salary) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name, age)<span class="comment">//通过super调用父类的构造方法</span></span><br><span class="line">    <span class="keyword">this</span>.salary = salary</span><br><span class="line">  &#125;</span><br><span class="line">  showName () &#123;<span class="comment">//在子类自身定义方法</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"调用子类的方法"</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age, <span class="keyword">this</span>.salary);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> Student(<span class="string">'wade'</span>, <span class="number">38</span>, <span class="number">1000000000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1)</span><br><span class="line">s1.showName()</span><br></pre></td></tr></table></figure><p>说明：本质上原型和class没有区别，但是代码的整洁可读性更高 ，super相当于原型继承的 <code>Person.call(this, name, age)</code> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;js中的继承：在js中的继承只是属性和方法的继承 一般没有所谓的多态性，js的继承只是为了使代码的复用性更高。&lt;/p&gt;
&lt;h3 id=&quot;js的继承是通过prototype来继承的&quot;&gt;&lt;a href=&quot;#js的继承是通过prototype来继承的&quot; class=&quot;header
      
    
    </summary>
    
      <category term="js高级" scheme="http://wang-zhibiao.github.io/categories/js%E9%AB%98%E7%BA%A7/"/>
    
    
      <category term="javascript" scheme="http://wang-zhibiao.github.io/tags/javascript/"/>
    
      <category term="function" scheme="http://wang-zhibiao.github.io/tags/function/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript的变量以及数据类型</title>
    <link href="http://wang-zhibiao.github.io/2019/06/09/%E5%8F%98%E9%87%8F%E5%92%8Cjs%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://wang-zhibiao.github.io/2019/06/09/变量和js类型的理解/</id>
    <published>2019-06-09T01:24:56.000Z</published>
    <updated>2019-07-14T01:27:28.709Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、JavaScript数据类型"><a href="#一、JavaScript数据类型" class="headerlink" title="一、JavaScript数据类型"></a>一、JavaScript数据类型</h2><p>ECMAScript标准规定了<code>7</code>种数据类型，其把这<code>7</code>种数据类型又分为两种：原始类型和对象类型。</p><h3 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a><strong>原始类型</strong></h3><ul><li><code>Null</code>：只包含一个值：<code>null</code></li><li><code>Undefined</code>：只包含一个值：<code>undefined</code></li><li><code>Boolean</code>：包含两个值：<code>true</code>和<code>false</code></li><li><code>Number</code>：整数或浮点数，还有一些特殊值（<code>-Infinity</code>、<code>+Infinity</code>、<code>NaN</code>）</li><li><code>String</code>：一串表示文本值的字符序列</li><li><code>Symbol</code>：一种实例是唯一且不可改变的数据类型</li></ul><p>(在<code>es10</code>中加入了第七种原始类型<code>BigInt</code>，现已被最新<code>Chrome</code>支持)</p><h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a><strong>对象类型</strong></h3><ul><li><p><code>Object</code>：自己分一类丝毫不过分，除了常用的<code>Object</code>，<code>Array</code>、<code>Function</code>等都属于特殊的对象</p><blockquote><p>区分原始类型和对象类型 - 不可变性</p></blockquote></li></ul><p>原始类型存放在栈空间中，而复杂类型存放在堆空间中</p><h3 id="栈内存："><a href="#栈内存：" class="headerlink" title="栈内存："></a>栈内存：</h3><ul><li>存储的值大小固定</li><li>空间较小</li><li>可以直接操作其保存的变量，运行效率高</li><li>由系统自动分配存储空间</li></ul><h3 id="堆内存："><a href="#堆内存：" class="headerlink" title="堆内存："></a>堆内存：</h3><ul><li>存储的值大小不定，可动态调整</li><li>空间较大，运行效率低</li><li>无法直接操作其内部存储，使用引用地址读取</li><li>通过代码进行分配空间</li></ul><h4 id="字符串-具备不可变性"><a href="#字符串-具备不可变性" class="headerlink" title="字符串 具备不可变性"></a><code>字符串 具备不可变性</code></h4><p>不管是字符串的裁切splice 还是 toLowerCase 都是在原有的基础上产生新的字符串</p><p><code>JavaScript</code>中的原始类型的值被直接存储在栈中，在变量定义时，栈就为其分配好了内存空间。</p><p>由于栈中的内存空间的大小是固定的，那么注定了存储在栈中的变量就是不可变的</p><h4 id="对象-具备可变性"><a href="#对象-具备可变性" class="headerlink" title="对象 具备可变性"></a><code>对象 具备可变性</code></h4><p>引用类型的值实际存储在堆内存中，它在栈中只存储了一个固定长度的地址，这个地址指向堆内存中的值。</p><p>数组  是一个复杂（引用）类型</p><h4 id="通过一些api可以改变数组"><a href="#通过一些api可以改变数组" class="headerlink" title="通过一些api可以改变数组"></a>通过一些api可以改变数组</h4><ul><li><code>pop()</code> 删除数组最后一个元素，如果数组为空，则不改变数组，返回undefined，改变原数组，返回被删除的元素</li><li><code>push()</code>向数组末尾添加一个或多个元素，改变原数组，返回新数组的长度</li><li><code>shift()</code>把数组的第一个元素删除，若空数组，不进行任何操作，返回undefined,改变原数组，返回第一个元素的值</li><li><code>unshift()</code>向数组的开头添加一个或多个元素，改变原数组，返回新数组的长度</li><li><code>reverse()</code>颠倒数组中元素的顺序，改变原数组，返回该数组</li><li><code>sort()</code>对数组元素进行排序，改变原数组，返回该数组</li><li><code>splice()</code>从数组中添加/删除项目，改变原数组，返回被删除的元素</li></ul><p>当我们进行复制时两者有着本质的区别</p><p>这里涉及到浅拷贝和深拷贝—本质是复制时是否改变复制的对象的数值或属性或方法</p><h4 id="原始类型-1"><a href="#原始类型-1" class="headerlink" title="原始类型"></a>原始类型</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'wang'</span>;</span><br><span class="line"><span class="keyword">var</span> newName = name;</span><br><span class="line">newName = <span class="string">'Mr.wang'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// =&gt;wang</span></span><br><span class="line"><span class="built_in">console</span>.log(newName) <span class="comment">// =&gt;Mr.wang</span></span><br></pre></td></tr></table></figure><p>内存中有一个变量<code>name</code>，值为<code>wang</code>。我们从变量<code>name</code>复制出一个变量<code>newName</code>，此时在内存中创建了一个块新的空间用于存储<code>wang</code>，虽然两者值是相同的，但是两者指向的内存空间完全不同，这两个变量参与任何操作都互不影响。</p><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">'wang'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> newObj = obj;</span><br><span class="line">newObj.name = <span class="string">'Mr.wang'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name) <span class="comment">//=&gt; Mr.wang</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.name)<span class="comment">//=&gt; Mr.wang</span></span><br></pre></td></tr></table></figure><p>当我们复制引用类型的变量时，实际上复制的是栈中存储的地址，所以复制出来的<code>newObj</code>实际上和<code>obj</code>指向的堆中同一个对象。因此，我们改变其中任何一个变量的值，另一个变量都会受到影响，这就是为什么会有深拷贝和浅拷贝的原因。</p><h3 id="原始类型和引用类型的比较"><a href="#原始类型和引用类型的比较" class="headerlink" title="原始类型和引用类型的比较"></a>原始类型和引用类型的比较</h3><p>原始类型，比较时会直接比较它们的值，如果值相等，即返回<code>true</code>。</p><p>引用类型，比较时会比较它们的引用地址，虽然两个变量在堆中存储的对象具有的属性值都是相等的，但是它们被存储在了不同的存储空间，因此比较值为<code>false</code>。</p><h4 id="区分null和undefined"><a href="#区分null和undefined" class="headerlink" title="区分null和undefined"></a>区分null和undefined</h4><p><strong>null</strong></p><p>表示被赋值过的对象，刻意把一个对象赋值为<code>null</code>，故意表示其为空，不应有值。</p><p>所以对象的某个属性值为<code>null</code>是正常的，<code>null</code>转换为数值时值为<code>0</code>。</p><p><strong>undefined</strong></p><p>表示“缺少值”，即此处应有一个值，但还没有定义，</p><p>如果一个对象的某个属性值为<code>undefined</code>，这是不正常的，如<code>obj.name=undefined</code>，我们不应该这样写，应该直接<code>delete obj.name</code>。</p><p><code>undefined</code>转为数值时为<code>NaN</code>(非数字值的特殊值)<img src="https://raw.githubusercontent.com/wang-zhibiao/wang-zhibiao.github.io/master/img/nullAndundefined.png" alt="nullAndundefined.png"></p><p><code>JavaScript</code>是一门动态类型语言，成员除了表示存在的空值外，还有可能根本就不存在（因为存不存在只在运行期才知道），这就是<code>undefined</code>的意义所在。对于<code>JAVA</code>这种强类型语言，如果有<code>&quot;undefined&quot;</code>这种情况，就会直接编译失败，所以在它不需要一个这样的类型。</p><h4 id="你想不到的0-1-0-2≠0-3"><a href="#你想不到的0-1-0-2≠0-3" class="headerlink" title="你想不到的0.1+0.2≠0.3"></a>你想不到的0.1+0.2≠0.3</h4><blockquote><p>本质是：由于数字在js中的计算是先转换为二进制在进行计算的，然后以十进制输出</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">judgeFloat</span>(<span class="params">n, m</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> binaryN = n.toString(<span class="number">2</span>);</span><br><span class="line">      <span class="keyword">const</span> binaryM = m.toString(<span class="number">2</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;n&#125;</span>的二进制是    <span class="subst">$&#123;binaryN&#125;</span>`</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;m&#125;</span>的二进制是    <span class="subst">$&#123;binaryM&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">const</span> MN = m + n;</span><br><span class="line">      <span class="keyword">const</span> accuracyMN = (m * <span class="number">100</span> + n * <span class="number">100</span>) / <span class="number">100</span>;</span><br><span class="line">      <span class="keyword">const</span> binaryMN = MN.toString(<span class="number">2</span>);</span><br><span class="line">      <span class="keyword">const</span> accuracyBinaryMN = accuracyMN.toString(<span class="number">2</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;n&#125;</span>+<span class="subst">$&#123;m&#125;</span>的二进制是<span class="subst">$&#123;binaryMN&#125;</span>`</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;accuracyMN&#125;</span>的二进制是    <span class="subst">$&#123;accuracyBinaryMN&#125;</span>`</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;n&#125;</span>+<span class="subst">$&#123;m&#125;</span>的二进制再转成十进制是<span class="subst">$&#123;to10(binaryMN)&#125;</span>`</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;accuracyMN&#125;</span>的二进制是再转成十进制是<span class="subst">$&#123;to10(accuracyBinaryMN)&#125;</span>`</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;n&#125;</span>+<span class="subst">$&#123;m&#125;</span>在js中计算是<span class="subst">$&#123;(to10(binaryMN) === to10(accuracyBinaryMN)) ? <span class="string">''</span> : <span class="string">'不'</span>&#125;</span>准确的`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">to10</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> pre = (n.split(<span class="string">'.'</span>)[<span class="number">0</span>] - <span class="number">0</span>).toString(<span class="number">2</span>);</span><br><span class="line">      <span class="keyword">const</span> arr = n.split(<span class="string">'.'</span>)[<span class="number">1</span>].split(<span class="string">''</span>);</span><br><span class="line">      <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (i &lt; arr.length) &#123;</span><br><span class="line">        result += arr[i] * <span class="built_in">Math</span>.pow(<span class="number">2</span>, -(i + <span class="number">1</span>));</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    judgeFloat(<span class="number">0.1</span>, <span class="number">0.2</span>);</span><br><span class="line">    judgeFloat(<span class="number">0.6</span>, <span class="number">0.7</span>);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wang-zhibiao/wang-zhibiao.github.io/master/img/0.1+0.2.jpg" alt="0.1+0.2"></p><p>计算机中所有的数据都是以<code>二进制</code>存储的，所以在计算时计算机要把数据先转换成<code>二进制</code>进行计算，然后在把计算结果转换成<code>十进制</code>。</p><p>由上面的代码不难看出，在计算<code>0.1+0.2</code>时，<code>二进制</code>计算发生了精度丢失，导致再转换成<code>十进制</code>后和预计的结果不符。</p><h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><p><img src="https://raw.githubusercontent.com/wang-zhibiao/wang-zhibiao.github.io/master/img/%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2.jpg" alt="隐式转换"></p><h3 id="if语句和逻辑语句"><a href="#if语句和逻辑语句" class="headerlink" title="if语句和逻辑语句"></a>if语句和逻辑语句</h3><p>在<code>if</code>语句和逻辑语句中，如果只有单个变量，会先将变量转换为<code>Boolean</code>值，只有下面几种情况会转换成<code>false</code>，其余被转换成<code>true</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">undefined</span><br><span class="line">&apos;&apos;</span><br><span class="line">NaN</span><br><span class="line">0</span><br><span class="line">false</span><br></pre></td></tr></table></figure><h3 id="各种运数学算符"><a href="#各种运数学算符" class="headerlink" title="各种运数学算符"></a>各种运数学算符</h3><p>我们在对各种非<code>Number</code>类型运用数学运算符(<code>- * /</code>)时，会先将非<code>Number</code>类型转换为<code>Number</code>类型;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 - true // 0</span><br><span class="line">1 - null //  1</span><br><span class="line">1 * undefined //  NaN</span><br><span class="line">2 * [&apos;5&apos;] //  10</span><br></pre></td></tr></table></figure><p>注意<code>+</code>是个例外，执行<code>+</code>操作符时：</p><ul><li>1.当一侧为<code>String</code>类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。</li><li>2.当一侧为<code>Number</code>类型，另一侧为原始类型，则将原始类型转换为<code>Number</code>类型。</li><li>3.当一侧为<code>Number</code>类型，另一侧为引用类型，将引用类型和<code>Number</code>类型转换成字符串后拼接。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">123 + &apos;123&apos; // 123123   （规则1）</span><br><span class="line">123 + null  // 123    （规则2）</span><br><span class="line">123 + true // 124    （规则2）</span><br><span class="line">123 + &#123;&#125;  // 123[object Object]    （规则3）</span><br></pre></td></tr></table></figure><h3 id="运算符"><a href="#运算符" class="headerlink" title="== 运算符"></a>== 运算符</h3><p>使用<code>==</code>时，若两侧类型相同，则比较结果和<code>===</code>相同，否则会发生隐式转换，使用<code>==</code>时发生的转换可以分为几种不同的情况（只考虑两侧类型不同）：</p><ul><li><h5 id="1-NaN"><a href="#1-NaN" class="headerlink" title="1.NaN"></a><strong>1.NaN</strong></h5></li></ul><p><code>NaN</code>和其他任何类型比较永远返回<code>false</code>(包括和他自己)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NaN == NaN // false</span><br></pre></td></tr></table></figure><ul><li><h5 id="2-Boolean"><a href="#2-Boolean" class="headerlink" title="2.Boolean"></a><strong>2.Boolean</strong></h5></li></ul><p><code>Boolean</code>和其他任何类型比较，<code>Boolean</code>首先被转换为<code>Number</code>类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">true == 1  // true </span><br><span class="line">true == &apos;2&apos;  // false</span><br><span class="line">true == [&apos;1&apos;]  // true</span><br><span class="line">true == [&apos;2&apos;]  // false</span><br></pre></td></tr></table></figure><blockquote><p>这里注意一个可能会弄混的点：<code>undefined、null</code>和<code>Boolean</code>比较，虽然<code>undefined、null</code>和<code>false</code>都很容易被想象成假值，但是他们比较结果是<code>false</code>，原因是<code>false</code>首先被转换成<code>0</code>：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">undefined == false // false</span><br><span class="line">null == false // false</span><br></pre></td></tr></table></figure><ul><li><h5 id="3-String和Number"><a href="#3-String和Number" class="headerlink" title="3.String和Number"></a><strong>3.String和Number</strong></h5></li></ul><p><code>String</code>和<code>Number</code>比较，先将<code>String</code>转换为<code>Number</code>类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">123 == &apos;123&apos; // true</span><br><span class="line">&apos;&apos; == 0 // true</span><br></pre></td></tr></table></figure><ul><li><h5 id="4-null和undefined"><a href="#4-null和undefined" class="headerlink" title="4.null和undefined"></a><strong>4.null和undefined</strong></h5></li></ul><p><code>null == undefined</code>比较结果是<code>true</code>，除此之外，<code>null、undefined</code>和其他任何结果的比较值都为<code>false</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">null == undefined // true</span><br><span class="line">null == &apos;&apos; // false</span><br><span class="line">null == 0 // false</span><br><span class="line">null == false // false</span><br><span class="line">undefined == &apos;&apos; // false</span><br><span class="line">undefined == 0 // false</span><br><span class="line">undefined == false // false</span><br></pre></td></tr></table></figure><ul><li><h5 id="5-原始类型和引用类型"><a href="#5-原始类型和引用类型" class="headerlink" title="5.原始类型和引用类型"></a><strong>5.原始类型和引用类型</strong></h5></li></ul><p>当原始类型和引用类型做比较时，对象类型会依照<code>ToPrimitive</code>规则转换为原始类型:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;[object Object]&apos; == &#123;&#125; // true</span><br><span class="line">&apos;1,2,3&apos; == [1, 2, 3] // true</span><br></pre></td></tr></table></figure><p>来看看下面这个比较：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] == ![] // true</span><br></pre></td></tr></table></figure><p><code>!</code>的优先级高于<code>==</code>，<code>![]</code>首先会被转换为<code>false</code>，然后根据上面第三点，<code>false</code>转换成<code>Number</code>类型<code>0</code>，左侧<code>[]</code>转换为<code>0</code>，两侧比较相等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[null] == false // true</span><br><span class="line">[undefined] == false // true</span><br></pre></td></tr></table></figure><p>根据数组的<code>ToPrimitive</code>规则，数组元素为<code>null</code>或<code>undefined</code>时，该元素被当做空字符串处理，所以<code>[null]、[undefined]</code>都会被转换为<code>0</code>。</p><h4 id="原型链的规则"><a href="#原型链的规则" class="headerlink" title="原型链的规则"></a>原型链的规则</h4><ul><li>1.所有引用类型都具有对象特性，即可以自由扩展属性</li><li>2.所有引用类型都具有一个<code>proto</code>（隐式原型）属性，是一个普通对象</li><li>3.所有的函数都具有<code>prototype</code>（显式原型）属性，也是一个普通对象</li><li>4.所有引用类型<code>proto</code>值指向它构造函数的<code>prototype</code></li><li>5.当试图得到一个对象的属性时，如果变量本身没有这个属性，则会去他的<code>proto</code>中去找</li></ul><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><p>上面我们在拆箱操作中提到了<code>toString</code>函数，我们可以调用它实现从引用类型的转换。</p><blockquote><p>每一个引用类型都有<code>toString</code>方法，默认情况下，<code>toString()</code>方法被每个<code>Object</code>对象继承。如果此方法在自定义对象中未被覆盖，<code>toString()</code> 返回 <code>&quot;[object type]&quot;</code>，其中<code>type</code>是对象的类型。</p></blockquote><p><img src="https://raw.githubusercontent.com/wang-zhibiao/wang-zhibiao.github.io/master/img/tostring.jpg" alt="tostring"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、JavaScript数据类型&quot;&gt;&lt;a href=&quot;#一、JavaScript数据类型&quot; class=&quot;headerlink&quot; title=&quot;一、JavaScript数据类型&quot;&gt;&lt;/a&gt;一、JavaScript数据类型&lt;/h2&gt;&lt;p&gt;ECMAScript标准规定
      
    
    </summary>
    
      <category term="javascript" scheme="http://wang-zhibiao.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://wang-zhibiao.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Es6解构赋值</title>
    <link href="http://wang-zhibiao.github.io/2019/05/11/Es6%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <id>http://wang-zhibiao.github.io/2019/05/11/Es6变量的解构赋值/</id>
    <published>2019-05-11T02:10:56.000Z</published>
    <updated>2019-07-14T01:28:26.270Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h2><ol><li>数组的解构赋值</li><li>对象的解构赋值</li><li>字符串的解构赋值</li><li>数值和布尔值的解构赋值</li><li>函数参数的解构赋值</li></ol><h3 id="1数组的解构赋值"><a href="#1数组的解构赋值" class="headerlink" title="1数组的解构赋值"></a>1数组的解构赋值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">// 为abc各自an规律赋值</span></span><br><span class="line"><span class="keyword">let</span> [a,[b,[c]]] = [<span class="number">1</span>,[<span class="number">2</span>,[<span class="number">3</span>]]]  <span class="comment">//如果为嵌套数组，可以用一样的嵌套数组赋值</span></span><br><span class="line"><span class="keyword">let</span> [x,y] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">//如果赋值两边长度不一，，则部分赋值 部分未赋值为uddefined</span></span><br><span class="line"><span class="keyword">let</span> [...arr] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">//扩展运算符可以直接把所有的数字赋值给arr arr=[1,2,3]</span></span><br><span class="line"><span class="keyword">let</span> [first,...arrAll]=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] <span class="comment">//当第一个first赋值以后，其他的数字都会给arrAll包含  first =1 arrAll=[2,3,4]</span></span><br></pre></td></tr></table></figure><h4 id="结构赋值为何左右两边为数组？"><a href="#结构赋值为何左右两边为数组？" class="headerlink" title="结构赋值为何左右两边为数组？"></a>结构赋值为何左右两边为数组？</h4><p>正常的赋值是一个一个赋值，解构赋值是吧需要赋值的解析重构，循环赋值 通过数组可遍历的特性就可以解构</p><h4 id="解构赋值的默认值"><a href="#解构赋值的默认值" class="headerlink" title="解构赋值的默认值"></a>解构赋值的默认值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a=<span class="number">11</span>] = [] <span class="comment">//a输出为11 在赋值之前就已经赋值 解构只是再次赋值 不会冲突 注意点 [] 数组里面无任何值，但是有undefined 所以才会解构成功 ，否则部分赋值也不会实现，以下情况请注意 null与undefined有本质的区别，两者不等，所以赋值时可以成功为null，解构赋值也严格遵守严格运算符（===）</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];<span class="comment">//x = 1</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>]; <span class="comment">//x = null</span></span><br></pre></td></tr></table></figure><h3 id="2对象的解构赋值"><a href="#2对象的解构赋值" class="headerlink" title="2对象的解构赋值"></a>2对象的解构赋值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a&#125;=&#123;<span class="attr">a</span>:<span class="string">'good'</span>,<span class="attr">b</span>:<span class="string">'nice'</span>&#125; <span class="comment">//a = good 对象里不同于数组，它是无序的集合 所以赋值要用见来赋值 两者的键要相同</span></span><br><span class="line"><span class="comment">//如果没有对应的键则会返回undefined</span></span><br><span class="line"><span class="comment">//对象的解构赋值可以对内置对象进行赋值</span></span><br><span class="line"><span class="keyword">let</span>&#123;log,sin,cos&#125; = <span class="built_in">Math</span></span><br><span class="line"><span class="keyword">let</span> &#123;log&#125; = <span class="built_in">console</span></span><br><span class="line"><span class="comment">//当取得所对应的对象的方法时，可以直接调用</span></span><br><span class="line">log(<span class="string">'hello word'</span>) <span class="comment">//控制台输出hello word</span></span><br><span class="line">sin(<span class="number">90</span>)  <span class="comment">//输出为 1</span></span><br><span class="line"><span class="keyword">let</span> &#123;a，&#123;b&#125;&#125; = &#123;<span class="attr">a</span>:<span class="number">11</span>,&#123;<span class="attr">b</span>:<span class="number">22</span>&#125;&#125; <span class="comment">//对象一样支持嵌套赋值</span></span><br><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;&#125;; <span class="comment">//也支持默认值</span></span><br></pre></td></tr></table></figure><p>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;; <span class="comment">//已经声明的变量再解构赋值会报错 ，&#123;x&#125; 会被解析为代码块</span></span><br><span class="line"><span class="comment">//解决方法</span></span><br><span class="line">(&#123;x&#125;=&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;); <span class="comment">//括号包裹</span></span><br><span class="line"><span class="comment">//解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。</span></span><br><span class="line">(&#123;&#125;=&#123;<span class="attr">a</span>:dd&#125;) <span class="comment">//语法可行但毫无意义</span></span><br><span class="line"><span class="comment">//数组也是一种特殊的对象 他是用索引值当键</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="number">0</span>:first&#125; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h3 id="3字符串的解构赋值"><a href="#3字符串的解构赋值" class="headerlink" title="3字符串的解构赋值"></a>3字符串的解构赋值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c,d,e] = <span class="string">'hello'</span> <span class="comment">// a=h,b=e,c=l,d=l,e=o  //这是将字符串转化为数组遍历在赋值</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">'hello'</span>; <span class="comment">//len = 5 // 数组都有length这个键 表示长度</span></span><br></pre></td></tr></table></figure><h3 id="4数值和布尔值的解构赋值"><a href="#4数值和布尔值的解构赋值" class="headerlink" title="4数值和布尔值的解构赋值"></a>4数值和布尔值的解构赋值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></span><br><span class="line"><span class="comment">//数字和布尔类型会转化为对象 所以在s的原型链与赋值的原型链相等 前面的键 toString 是转化为字符串的方法</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line">s === <span class="built_in">Boolean</span>.prototype.toString <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 由于ndefined和null无法转为对象 所以不能进行赋值</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: x &#125; = <span class="literal">undefined</span>; <span class="comment">// TypeError</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: y &#125; = <span class="literal">null</span>; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><h2 id="5函数参数的解构赋值"><a href="#5函数参数的解构赋值" class="headerlink" title="5函数参数的解构赋值"></a>5函数参数的解构赋值</h2><p>函数的解构赋值我们经常使用 当我们进行传参时 就会进行解构赋值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">2</span>,<span class="number">3</span>) <span class="comment">//a和b都会在函数调用时传参解构赋值</span></span><br></pre></td></tr></table></figure><p>函数参数的默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">fn(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8] </span></span><br><span class="line">fn(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, 0]</span></span><br><span class="line">fn(&#123;&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line">fn(); <span class="comment">// [0, 0]</span></span><br><span class="line"><span class="comment">//如果有默认值,参数没有就使用默认值</span></span><br></pre></td></tr></table></figure><p>另一种函数的默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">&#123;x, y&#125; = &#123;x:<span class="number">0</span>,y:<span class="number">0</span>&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">fn(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8] </span></span><br><span class="line">fn(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, undefined]</span></span><br><span class="line">fn(&#123;&#125;); <span class="comment">// [undefined, undefined]</span></span><br><span class="line">fn(); <span class="comment">// [0, 0]</span></span><br><span class="line"><span class="comment">//如果有默认值,参数没有就使用默认值</span></span><br><span class="line"><span class="comment">//这种写法使用了对象的键值对赋值，不是之前的值传递，所以 当参数为&#123;&#125;时 传递的是undefined</span></span><br></pre></td></tr></table></figure><h3 id="圆括号"><a href="#圆括号" class="headerlink" title="圆括号"></a>圆括号</h3><p>圆括号是为了解决赋值时解析的无法辨别，但是要注意使用时机，否则会报错</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;变量的解构赋值&quot;&gt;&lt;a href=&quot;#变量的解构赋值&quot; class=&quot;headerlink&quot; title=&quot;变量的解构赋值&quot;&gt;&lt;/a&gt;变量的解构赋值&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;数组的解构赋值&lt;/li&gt;
&lt;li&gt;对象的解构赋值&lt;/li&gt;
&lt;li&gt;字符串的解构赋值&lt;/
      
    
    </summary>
    
      <category term="基础" scheme="http://wang-zhibiao.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="javascript" scheme="http://wang-zhibiao.github.io/tags/javascript/"/>
    
      <category term="Es6" scheme="http://wang-zhibiao.github.io/tags/Es6/"/>
    
  </entry>
  
  <entry>
    <title>let var const三种定义方式及闭包</title>
    <link href="http://wang-zhibiao.github.io/2019/05/10/var%20let%20const%E4%B8%89%E7%A7%8D%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F%E5%8F%8A%E9%97%AD%E5%8C%85/"/>
    <id>http://wang-zhibiao.github.io/2019/05/10/var let const三种定义方式及闭包/</id>
    <published>2019-05-09T16:10:56.000Z</published>
    <updated>2019-07-14T01:27:55.718Z</updated>
    
    <content type="html"><![CDATA[<h3 id="let-var-const-之间的区别"><a href="#let-var-const-之间的区别" class="headerlink" title="let var const 之间的区别"></a>let var const 之间的区别</h3><h4 id="var"><a href="#var" class="headerlink" title="var"></a>var</h4><p>var的作用域是根据函数作用域的， 他在函数内起作用   这里就引用到闭包和作用域链</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">out</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">000</span>; <span class="comment">//=&gt; 这个a的作用域作用在out内 而info函数在out函数内 所以可以调用</span></span><br><span class="line">b=<span class="number">222</span> <span class="comment">//=&gt; 报错err 因为b的作用域在info函数内 包裹他的out函数不可以调用它</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">info</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b=<span class="number">999</span>;</span><br><span class="line">a= <span class="number">111</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>var 的变量提升</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a=<span class="number">10</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//变量提升 就是var定义的变量会在先声明再赋值 提升到函数顶部</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  a=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><p>let的作用域的块级作用域，不会变量提升  可以理解为在某块范围内作用 与var 的函数作用域不同在于 let的作用域会形成闭包</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出 3 3 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出 0 1 2</span></span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var会在全局声明 而setTimeout 是一个定时器 也是异步回调  会在同步执行完毕再执行异步 所以当for循环完毕 i=3时调用三次定时器  </span><br><span class="line">let 的作用范围会在for循环内 每循环一次 i会形成一次闭包  i会被setTimeout调用</span><br></pre></td></tr></table></figure><h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p>const代表一个值的常量索引，常量的值在垃圾回收前永远不能改变，所以需要谨慎使用。</p><p>cosnt定义的值不能被改变 否则会报错</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Uncaught TypeError: Assignment to constant variable.</span><br><span class="line">未捕获的类型错误:赋值给常量变量。</span><br></pre></td></tr></table></figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>外部可以访问内部的私有变量</p><p>可以返回携带状态的函数，并且状态隐藏 可以做到变量的私有</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n=<span class="number">999</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(n); <span class="comment">// 999</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p><p>既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function f1()&#123;</span><br><span class="line">var n=999;</span><br><span class="line">function f2()&#123;</span><br><span class="line">alert(n); </span><br><span class="line">&#125;</span><br><span class="line">return f2;</span><br><span class="line">&#125;</span><br><span class="line">var result=f1();</span><br><span class="line">result(); // 999</span><br></pre></td></tr></table></figure><p>闭包就是能够读取其他函数内部变量的函数</p><p>要形成闭包 必须两层function函数作用域</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function f1()&#123;</span><br><span class="line">  var n=999;</span><br><span class="line">  Add=function()&#123;n+=1&#125;</span><br><span class="line">  function f2()&#123;</span><br><span class="line">  console.log(n)</span><br><span class="line">&#125;</span><br><span class="line">return f2;</span><br><span class="line">&#125;</span><br><span class="line">var result=f1();</span><br><span class="line">result(); // 999</span><br><span class="line">Add();</span><br><span class="line">result(); // 1000</span><br></pre></td></tr></table></figure><p>这里形成闭包后，f1的局部变量n一直保存在内存中，并没有因为f1的重复调用而清除</p><p>原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p><p>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">  name: <span class="string">"My Object"</span>,</span><br><span class="line">  getNameFunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getNameFunc()());</span><br></pre></td></tr></table></figure><p>经典闭包题</p><p>个人理解</p><p>object.getNameFunc()  执行到这一步时 调用object内的函数 返回一个function（）{return this.name} 这时候 name还是My Object  当再次执行时object.getNameFunc()()  调用了外部的name 输出为The Window</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;let-var-const-之间的区别&quot;&gt;&lt;a href=&quot;#let-var-const-之间的区别&quot; class=&quot;headerlink&quot; title=&quot;let var const 之间的区别&quot;&gt;&lt;/a&gt;let var const 之间的区别&lt;/h3&gt;&lt;h4 i
      
    
    </summary>
    
      <category term="javascript" scheme="http://wang-zhibiao.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://wang-zhibiao.github.io/tags/javascript/"/>
    
      <category term="function" scheme="http://wang-zhibiao.github.io/tags/function/"/>
    
  </entry>
  
  <entry>
    <title>隐藏元素的方法</title>
    <link href="http://wang-zhibiao.github.io/2019/03/22/%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://wang-zhibiao.github.io/2019/03/22/隐藏元素的方法/</id>
    <published>2019-03-21T16:10:56.000Z</published>
    <updated>2019-07-13T02:29:27.392Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>隐藏类型</p></blockquote><p>屏幕并不是唯一的输出机制，比如说屏幕上看不见的元素（隐藏的元素），其中一些依然能够被读屏软件阅读出来（因为读屏软件依赖于可访问性树来阐述）。为了消除它们之间的歧义，我们将其归为三大类：</p><ul><li>完全隐藏：元素从DOM树中消失，不占据空间。</li><li>视觉上的隐藏：屏幕中不可见，占据空间。</li><li>语义上的隐藏：读屏软件不可读，但正常占据空间。</li></ul><blockquote><p>完全隐藏</p></blockquote><h4 id="1-display-属性"><a href="#1-display-属性" class="headerlink" title="1.display 属性"></a>1.<code>display</code> 属性</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">none</span>;</span><br></pre></td></tr></table></figure><h4 id="2-hidden-属性"><a href="#2-hidden-属性" class="headerlink" title="2.hidden 属性"></a>2.hidden 属性</h4><blockquote><p>HTML5 新增属性，相当于 <code>display: none</code></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">hidden</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>视觉上的隐藏,在页面中还存在</p></blockquote><h4 id="3-利用-position-和-盒模型-将元素移出可视区范围"><a href="#3-利用-position-和-盒模型-将元素移出可视区范围" class="headerlink" title="3.利用 position 和 盒模型 将元素移出可视区范围"></a>3.利用 <code>position</code> 和 盒模型 将元素移出可视区范围</h4><blockquote><p>设置 <code>posoition</code> 为 <code>absolute</code> 或 <code>fixed</code>，通过设置 <code>top</code>、<code>left</code> 等值，将其移出可视区域。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">position</span><span class="selector-pseudo">:absolute</span>;</span><br><span class="line"><span class="selector-tag">left</span>: <span class="selector-tag">-999px</span>;</span><br></pre></td></tr></table></figure><blockquote><p>设置 <code>position</code> 为 <code>relative</code>，通过设置 <code>top</code>、<code>left</code> 等值，将其移出可视区域。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">relative</span>;</span><br><span class="line"><span class="selector-tag">left</span>: <span class="selector-tag">-999px</span>;</span><br></pre></td></tr></table></figure><blockquote><p>设置 margin 值，将其移出可视区域范围（可视区域占位）。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">margin-left</span>: <span class="selector-tag">-99999px</span>;</span><br><span class="line"><span class="selector-tag">height</span>: 0;</span><br></pre></td></tr></table></figure><h4 id="3-利用-transfrom"><a href="#3-利用-transfrom" class="headerlink" title="3.利用 transfrom"></a>3.利用 transfrom</h4><blockquote><p>缩放</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">scale</span>(0);</span><br><span class="line"><span class="selector-tag">height</span>: 0;</span><br></pre></td></tr></table></figure><blockquote><p>移动 <code>translateX</code>, <code>translateY</code></p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateX</span>(<span class="selector-tag">-99999px</span>);</span><br><span class="line"><span class="selector-tag">height</span>: 0</span><br></pre></td></tr></table></figure><blockquote><p>旋转 <code>rotate</code></p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform: rotateY(90deg) //直角在界面上形成线性视觉屏蔽</span><br></pre></td></tr></table></figure><h4 id="4-设置其大小为0"><a href="#4-设置其大小为0" class="headerlink" title="4.设置其大小为0"></a>4.设置其大小为0</h4><blockquote><p>宽高为0，字体大小为0：</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">height</span>: 0;</span><br><span class="line"><span class="selector-tag">width</span>: 0;</span><br><span class="line"><span class="selector-tag">font-size</span>: 0;</span><br></pre></td></tr></table></figure><blockquote><p>宽高为0，超出隐藏:</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">height</span>: 0;</span><br><span class="line"><span class="selector-tag">width</span>: 0;</span><br><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br></pre></td></tr></table></figure><h4 id="5-设置透明度为0"><a href="#5-设置透明度为0" class="headerlink" title="5.设置透明度为0"></a>5.设置透明度为0</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">opacity</span>: 0;</span><br></pre></td></tr></table></figure><h4 id="6-visibility属性"><a href="#6-visibility属性" class="headerlink" title="6.visibility属性"></a>6.<code>visibility</code>属性</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">visibility</span>: <span class="selector-tag">hidden</span>;</span><br></pre></td></tr></table></figure><h4 id="7-层级覆盖，z-index-属性"><a href="#7-层级覆盖，z-index-属性" class="headerlink" title="7.层级覆盖，z-index 属性"></a>7.层级覆盖，<code>z-index</code> 属性</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">relative</span>;</span><br><span class="line"><span class="selector-tag">z-index</span>: <span class="selector-tag">-999</span>;</span><br></pre></td></tr></table></figure><h5 id="再设置一个层级较高的元素覆盖在此元素上。"><a href="#再设置一个层级较高的元素覆盖在此元素上。" class="headerlink" title="再设置一个层级较高的元素覆盖在此元素上。"></a>再设置一个层级较高的元素覆盖在此元素上。</h5><h4 id="8-clip-path-裁剪"><a href="#8-clip-path-裁剪" class="headerlink" title="8.clip-path 裁剪"></a>8.clip-path 裁剪</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">clip-path</span>: <span class="selector-tag">polygon</span>(0 0, 0 0, 0 0, 0 0);</span><br></pre></td></tr></table></figure><p><strong>语义上的隐藏</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;隐藏类型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;屏幕并不是唯一的输出机制，比如说屏幕上看不见的元素（隐藏的元素），其中一些依然能够被读屏软件阅读出来（因为读屏软件依赖于可访问性树来阐述）。为了消除它们之间的歧义，我们将其归为三大类：&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="基础" scheme="http://wang-zhibiao.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="javascript" scheme="http://wang-zhibiao.github.io/tags/javascript/"/>
    
      <category term="function" scheme="http://wang-zhibiao.github.io/tags/function/"/>
    
  </entry>
  
  <entry>
    <title>BFC协议</title>
    <link href="http://wang-zhibiao.github.io/2018/12/30/BFC%E5%8D%8F%E8%AE%AE/"/>
    <id>http://wang-zhibiao.github.io/2018/12/30/BFC协议/</id>
    <published>2018-12-29T16:14:56.000Z</published>
    <updated>2019-07-14T01:29:51.152Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是BFC？BFC的布局规则是什么？如何创建BFC？"><a href="#什么是BFC？BFC的布局规则是什么？如何创建BFC？" class="headerlink" title="什么是BFC？BFC的布局规则是什么？如何创建BFC？"></a>什么是BFC？BFC的布局规则是什么？如何创建BFC？</h3><p><strong>查看解析</strong></p><ul><li>Box 是 CSS 布局的对象和基本单位，页面是由若干个Box组成的。</li><li>元素的类型 和 <code>display</code> 属性，决定了这个 Box 的类型。不同类型的 Box 会参与不同的 Formatting Context。</li></ul><blockquote><h4 id="Formatting-Context"><a href="#Formatting-Context" class="headerlink" title="Formatting Context"></a>Formatting Context</h4></blockquote><ul><li>Formatting Context 是页面的一块渲染区域，并且有一套渲染规则，决定了其子元素将如何定位，以及和其它元素的关系和相互作用。</li><li>Formatting Context 有 BFC (Block formatting context)，IFC (Inline formatting context)，FFC (Flex formatting context) 和 GFC (Grid formatting context)。FFC 和 GFC 为 CC3 中新增。</li></ul><blockquote><h4 id="BFC布局规则"><a href="#BFC布局规则" class="headerlink" title="BFC布局规则"></a><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.w3.org%2FTR%2F2011%2FREC-CSS2-20110607%2Fvisuren.html%23block-formatting" target="_blank" rel="noopener">BFC布局规则</a></h4></blockquote><ul><li>BFC内，盒子依次垂直排列。</li><li>BFC内，两个盒子的垂直距离由 <code>margin</code> 属性决定。属于同一个BFC的两个相邻Box的margin会发生重叠【符合合并原则的margin合并后是使用大的margin】</li><li>BFC内，每个盒子的左外边缘接触内部盒子的左边缘（对于从右到左的格式，右边缘接触）。即使在存在浮动的情况下也是如此。除非创建新的BFC。</li><li>BFC的区域不会与float box重叠。</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li><li>计算BFC的高度时，浮动元素也参与计算。</li></ul><blockquote><h4 id="如何创建BFC"><a href="#如何创建BFC" class="headerlink" title="如何创建BFC"></a>如何创建BFC</h4></blockquote><h2 id="根元素"><a href="#根元素" class="headerlink" title="根元素"></a>根元素</h2><ul><li>浮动元素（float 属性不为 none）</li><li>position 为 absolute 或 fixed</li><li>overflow 不为 visible 的块元素</li><li>display 为 inline-block, table-cell, table-caption</li></ul><blockquote><p>BFC 的应用</p></blockquote><ul><li>防止 margin  重叠 (同一个BFC内的两个两个相邻Box的 <code>margin</code> 会发生重叠，触发生成两个BFC，即不会重叠)</li><li>清除内部浮动 (创建一个新的 BFC，因为根据 BFC 的规则，计算 BFC 的高度时，浮动元素也参与计算)</li><li>自适应多栏布局 (BFC的区域不会与float box重叠。因此，可以触发生成一个新的BFC)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是BFC？BFC的布局规则是什么？如何创建BFC？&quot;&gt;&lt;a href=&quot;#什么是BFC？BFC的布局规则是什么？如何创建BFC？&quot; class=&quot;headerlink&quot; title=&quot;什么是BFC？BFC的布局规则是什么？如何创建BFC？&quot;&gt;&lt;/a&gt;什么是BF
      
    
    </summary>
    
      <category term="javascript" scheme="http://wang-zhibiao.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://wang-zhibiao.github.io/tags/javascript/"/>
    
      <category term="function" scheme="http://wang-zhibiao.github.io/tags/function/"/>
    
  </entry>
  
  <entry>
    <title>盒子居中的方法</title>
    <link href="http://wang-zhibiao.github.io/2018/12/20/%E7%9B%92%E5%AD%90%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://wang-zhibiao.github.io/2018/12/20/盒子居中的方法/</id>
    <published>2018-12-20T11:50:59.000Z</published>
    <updated>2019-07-14T01:29:23.856Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h3 id="盒子居中的方法："><a href="#盒子居中的方法：" class="headerlink" title="盒子居中的方法："></a>盒子居中的方法：</h3><h5 id="1-宽度和高度已知的。"><a href="#1-宽度和高度已知的。" class="headerlink" title="1.宽度和高度已知的。"></a>1.宽度和高度已知的。</h5><p>思路：<br>  父元素相对定位<br>  子元素绝对定位 </p><p>子元素{</p><p>left: 50%;top: 50%;<br>margin-left: 减去子元素的宽度一半。<br>margin-top: 减去子元素的高度一半；</p><p>}</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line">        <span class="selector-id">#box</span>&#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">            <span class="attribute">position</span>: relative;</span><br><span class="line">            background: red; //方便观看</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-id">#box1</span>&#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">            <span class="attribute">position</span>: absolute;</span><br><span class="line">            <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">            <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">            margin-left: -100px;  //定位后偏移值超过子元素的宽度一半需减去</span><br><span class="line">            margin-top: -50px;//定位后偏移值超过子元素的高度一半需减去</span><br><span class="line">            <span class="selector-tag">background</span>: <span class="selector-tag">green</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h5 id="2-宽度和高度可以随意改变"><a href="#2-宽度和高度可以随意改变" class="headerlink" title="2.宽度和高度可以随意改变"></a>2.宽度和高度可以随意改变</h5><p>思路：<br>  父元素相对定位<br>  子元素绝对定位 </p><p>子元素{</p><p>left: 0;top: 0; bottom:0;right:0;</p><p>margin:auto;</p><p>}</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#box</span>&#123;</span><br><span class="line">     <span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">     <span class="attribute">position</span>: relative;</span><br><span class="line">     <span class="attribute">background</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="selector-id">#box1</span>&#123;</span><br><span class="line">     <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">     position: absolute;//四个方位定义盒子所在的位置 当所有为0&amp;&amp;margin:auto时,盒子居中 </span><br><span class="line">     <span class="selector-tag">top</span>: 0;</span><br><span class="line">     <span class="selector-tag">right</span>: 0;</span><br><span class="line">     <span class="selector-tag">bottom</span>: 0;</span><br><span class="line">     <span class="selector-tag">left</span>: 0;</span><br><span class="line">     <span class="selector-tag">margin</span>: <span class="selector-tag">auto</span>;</span><br><span class="line">     <span class="selector-tag">background</span>: <span class="selector-tag">green</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="3-flex布局"><a href="#3-flex布局" class="headerlink" title="3.flex布局"></a>3.flex布局</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">           <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">           <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">           <span class="attribute">background</span>: <span class="number">#f99</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="selector-class">.box1</span>&#123;</span><br><span class="line">           <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">           <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">           <span class="attribute">background</span>: green;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="selector-class">.center</span>&#123;</span><br><span class="line">           display: flex;  //开启弹性盒子 主轴侧轴交叉得到居中</span><br><span class="line">           justify-content: center;//实现水平居中</span><br><span class="line">           align-items: center;//实现垂直居中</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h5 id="4-平移-定位-transform"><a href="#4-平移-定位-transform" class="headerlink" title="4.平移 定位+transform"></a>4.平移 定位+transform</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent_box</span>&#123;</span><br><span class="line">          <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">          <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">          <span class="attribute">background</span>: red;</span><br><span class="line">          <span class="attribute">position</span>: relative;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="selector-class">.child_box</span>&#123;</span><br><span class="line">          <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">          <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">          <span class="attribute">background</span>: green;</span><br><span class="line">          position: absolute;//与第一个类似 但可以根据子元素的宽高自动居中</span><br><span class="line">          <span class="selector-tag">top</span>: 50%;</span><br><span class="line">          <span class="selector-tag">left</span>: 50%;</span><br><span class="line">          transform: translate( -50%,-50%);//平移相当于盒子margin(左,上)减半</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="如何清除浮动"><a href="#如何清除浮动" class="headerlink" title="如何清除浮动"></a>如何清除浮动</h3><p>清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。</p><h4 id="父级添加overflow属性方法"><a href="#父级添加overflow属性方法" class="headerlink" title="父级添加overflow属性方法"></a>父级添加overflow属性方法</h4><p>可以通过触发BFC的方式，可以实现清除浮动效果。</p><h4 id="使用after伪元素清除浮动"><a href="#使用after伪元素清除浮动" class="headerlink" title="使用after伪元素清除浮动"></a>使用after伪元素清除浮动</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>; </span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">  <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;   </span><br><span class="line">.clearfix &#123;*zoom: 1;&#125;   /* IE6、7 专有 */</span><br></pre></td></tr></table></figure><h4 id="使用before和after双伪元素清除浮动"><a href="#使用before和after双伪元素清除浮动" class="headerlink" title="使用before和after双伪元素清除浮动"></a>使用before和after双伪元素清除浮动</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:before</span>,<span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123; </span><br><span class="line">  <span class="attribute">content</span>:<span class="string">""</span>;</span><br><span class="line">  <span class="attribute">display</span>:table;  <span class="comment">/* 这句话可以触发BFC BFC可以清除浮动 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line"> <span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">  *zoom:1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="浏览器查询Unicode编码"><a href="#浏览器查询Unicode编码" class="headerlink" title="浏览器查询Unicode编码"></a>浏览器查询Unicode编码</h3><p> 浏览器控制台输出   escape(‘查询字符串’)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; title=&quot;HTML&quot;&gt;&lt;/a&gt;HTML&lt;/h1&gt;&lt;h3 id=&quot;盒子居中的方法：&quot;&gt;&lt;a href=&quot;#盒子居中的方法：&quot; class=&quot;headerlink&quot; title=&quot;盒
      
    
    </summary>
    
      <category term="知识" scheme="http://wang-zhibiao.github.io/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="debug" scheme="http://wang-zhibiao.github.io/tags/debug/"/>
    
      <category term="css" scheme="http://wang-zhibiao.github.io/tags/css/"/>
    
      <category term="html" scheme="http://wang-zhibiao.github.io/tags/html/"/>
    
  </entry>
  
</feed>
