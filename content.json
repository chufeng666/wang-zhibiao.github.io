{"meta":{"title":"wang-zhibiao'blog","subtitle":"I am is a boy","description":"note","author":"wangzhibiao","url":"http://wang-zhibiao.github.io"},"pages":[{"title":"about","date":"2019-06-16T13:48:33.000Z","updated":"2019-06-16T13:48:34.047Z","comments":true,"path":"about/index.html","permalink":"http://wang-zhibiao.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"JS全局污染","slug":"JS全局污染","date":"2019-06-20T11:50:59.000Z","updated":"2019-07-01T01:20:12.648Z","comments":true,"path":"2019/06/20/JS全局污染/","link":"","permalink":"http://wang-zhibiao.github.io/2019/06/20/JS全局污染/","excerpt":"","text":"所谓全局变量污染 ：定义多个全局变量，函数，对象挂载在window上，如果重复使用则造成变量冲突 如果定义一个全局变量则会在window上挂载这个变量，所有的函数，对象，引用此js文件的都可以使用， 1234567891011&lt;script&gt; var a = 10; console.log(window);&lt;/script&gt;//输出Windowa: 10alert: ƒ alert()applicationCache: ApplicationCache &#123;status: 0, oncached: null, onchecking: null, ondownloading: null, onerror: null, …&#125;。。。。。。。 污染如同衣物沾上污渍，笔墨落入清水。 全局window是大家都能使用，如果在全局挂载变量太多，难免会调用重复的变量，改变其属性或值。 在开发中，多人共同开发，每个人的代码习惯不同，命名方法不同，如果其他人命名一个变量ID，那么，在调用ID时会改变上一个人的ID导致不是自己想要的ID。 123456789101112131415161718192021222324//developer_first.js&lt;script&gt; var ID = 10; console.log(ID);&lt;/script&gt;//developer_second.js&lt;script&gt; var ID = 2; console.log(ID);&lt;/script&gt;//developer_thirdly.js&lt;script&gt; var ID = 4; console.log(ID);&lt;/script&gt;//在主文件中调用&lt;head&gt;&lt;script src=\"developer_first.js\"&gt;&lt;/script&gt;&lt;script src=\"developer_second.js\"&gt;&lt;/script&gt; &lt;script src=\"developer_thirdly.js\"&gt;&lt;/script&gt; //最后的&lt;/head&gt;//=&gt;输出 4 4 4 ID会使用最后调用的js文件 为了避免全局污染，应慎重使用全局变量。了解模块化，或者let 定义的let不在window里 在script内有效 或者函数{}内有效，形成块级作用域","categories":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"}],"keywords":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}]},{"title":"js常见的继承方式","slug":"js的六种继承方式","date":"2019-06-20T01:10:56.000Z","updated":"2019-07-14T01:29:05.728Z","comments":true,"path":"2019/06/20/js的六种继承方式/","link":"","permalink":"http://wang-zhibiao.github.io/2019/06/20/js的六种继承方式/","excerpt":"","text":"js中的继承：在js中的继承只是属性和方法的继承 一般没有所谓的多态性，js的继承只是为了使代码的复用性更高。 js的继承是通过prototype来继承的1 原型链继承这种方式关键在于:**子类型的原型为父类型的一个实例对象。 12345678910111213141516171819 //父类型 function Person(name, age) &#123; this.name = name, this.age = age, this.play = [1, 2, 3] this.setName = function () &#123;&#125; &#125; Person.prototype.setAge = function () &#123;&#125; //子类型 function Student(price) &#123; this.price = price this.setScore = function () &#123;&#125; &#125;// Student.prototype.sayHello = function () &#123; &#125;//在这里写子类的原型方法和属性是无效的，//因为会改变原型的指向，所以应该放到重新指定之后 Student.prototype = new Person() // 子类型的原型为父类型的一个实例对象 var s1 = new Student(15000) var s2 = new Student(14000) console.log(s1,s2) 说明：定义一个Person父类型拥有对象和方法 Person.prototype.setAge = function () {} 这是一种在外部定义的一个在prototype原型上的方法 原理：每个function身上都有一个原型 在原型身上可以挂载方法和属性 Student.prototype = new Person() Student原型指向Person的实例对象，所以子类的实例就可以通过proto__访问到 Student.prototype 也就是Person的实例，这样就可以访问到父类的私有方法，然后再通过__proto指向父类的prototype就可以获得到父类原型上的方法。于是做到了将父类的私有、公有方法和属性都当做子类的公有属性 弊端：子类继承父类的属性和方法是将父类的私有属性和公有方法都作为自己的公有属性和方法 如果父类的私有属性有引用类型，子类继承的是这个父类的引用地址 如果子类操作父类的引用类型就会导致引用类型改变详情请看 js数据类型 我们需要在子类中添加新的方法或者是重写父类的方法时候，切记一定要放到替换原型的语句之后 2 借用构造函数继承这种方式关键在于:在子类型构造函数中通用call()调用父类型构造函数 12345678910111213function Person(name, age) &#123; this.name = name, this.age = age, this.setName = function () &#123;&#125;&#125;Person.prototype.setAge = function () &#123;&#125;function Student(name, age, price) &#123; Person.call(this, name, age) // 相当于: this.Person(name, age) /*this.name = name this.age = age*/ this.price = price&#125;var s1 = new Student('Tom', 20, 15000) 说明：在Student中构造Person的属性和方法，但是只是实现部分继承，如果父类的属性和方法太多，继承麻烦。但是解决了引用类型的问题因为这个构造函数是再次创建实例 弊端：子类的实例是根据父类的实例重新构造的，只能继承父类的实例属性和方法，不能继承原型属性和方法 代码复用性弱，每个子类都是父类的实例函数副本，影响性能 3 原型链+借用构造函数的组合继承这种方式关键在于:通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用 。 1234567891011121314151617181920212223function Person (name, age) &#123; this.name = name, this.age = age, this.setAge = function () &#123; &#125;&#125;Person.prototype.setAge = function () &#123; console.log(\"111\")&#125;function Student (name, age, price) &#123; //第一次调用构造函数 Person.call(this, name, age) this.price = price this.setScore = function () &#123; &#125;&#125;// 令Student的原型指向Person的实例Student.prototype = new Person()Student.prototype.constructor = Student//组合继承也是需要修复构造函数指向的Student.prototype.sayHello = function () &#123; &#125;var s1 = new Student('Tom', 20, 15000)var s2 = new Student('Jack', 22, 14000)console.log(s1)console.log(s1.constructor) //Studentconsole.log(p1.constructor) //Person 说明：在子类中调用构造函数生成实例对象但是只是包含属性，在子类的原型链上继承Person的实例，再次使用构造函数，是刚继承的实例构造成一个新的实例赋值 这个实例属于Student 构造函数（constructor） –字面意思，能构造一个实例的函数 弊端：无论如何都会调用两次构造函数，创建子类的原型和子类构造函数内部 4 组合继承的优化-原型指向这种方式关键在于 通过父类原型和子类原型指向同一对象，子类可以继承到父类的公有方法当做自己的公有方法，而且不会初始化两次实例方法/属性，避免的组合继承的缺点 12345678910111213141516171819function Person (name, age) &#123; this.name = name, this.age = age, this.setAge = function () &#123; &#125;&#125;Person.prototype.setAge = function () &#123; console.log(\"111\")&#125;function Student (name, age, price) &#123; //构造函数 Person.call(this, name, age) this.price = price this.setScore = function () &#123; &#125;&#125;//原型的赋值Student.prototype = Person.prototypeStudent.prototype.sayHello = function () &#123; &#125;var s1 = new Student('Tom', 20, 15000)console.log(s1) 说明：原型的赋值会让两个类指向同一个对象 ，与上面的区别在于一个是构造函数的赋值 这是原型的赋值，不会生成两次实例 弊端：父类指向不明，都是原型的赋值 同一个对象，没有父子关系，引用类型问题， 5 组合继承的优化-创建对象这种方式关键在于 借助原型可以基于已有的对象来创建对象，var B = Object.create(A)以A对象为原型，生成了B对象。B继承了A的所有属性和方法 12345678910111213141516171819function Person (name, age) &#123; this.name = name, this.age = age&#125;Person.prototype.setAge = function () &#123; console.log(\"111\")&#125;function Student (name, age, price) &#123; //构造函数 Person.call(this, name, age) this.price = price this.setScore = function () &#123; &#125;&#125;Student.prototype = Object.create(Person.prototype)//核心代码Student.prototype.constructor = Student//核心代码var s1 = new Student('Tom', 20, 15000)console.log(s1 instanceof Student, s1 instanceof Person) // true trueconsole.log(s1.constructor) //Studentconsole.log(s1) 说明：Student.prototype = Object.create(Person.prototype) 创建一个基于Person的的prototype创建一个新的对象给Student，继承Person 的所有的属性和方法 （Object.create）Object身上挂载create这个方法可以创建新的对象 目前来说，使用缺点都解决了，但是还未趋近完美 6 Es6的class继承ES6中引入了class关键字，class可以通过extends关键字实现继承，还可以通过static关键字定义类的静态方法,这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。 ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。 需要注意的是，class关键字只是原型的语法糖，JavaScript继承仍然是基于原型实现的。 12345678910111213141516171819202122232425262728class Person &#123; //调用类的构造方法 constructor(name, age) &#123; this.name = name this.age = age &#125; //定义一般的方法 showName () &#123; console.log(\"调用父类的方法\") console.log(this.name, this.age); &#125;&#125;let p1 = new Person('kobe', 39)console.log(p1)//定义一个子类class Student extends Person &#123; constructor(name, age, salary) &#123; super(name, age)//通过super调用父类的构造方法 this.salary = salary &#125; showName () &#123;//在子类自身定义方法 console.log(\"调用子类的方法\") console.log(this.name, this.age, this.salary); &#125;&#125;let s1 = new Student('wade', 38, 1000000000)console.log(s1)s1.showName() 说明：本质上原型和class没有区别，但是代码的整洁可读性更高 ，super相当于原型继承的 Person.call(this, name, age)","categories":[{"name":"js高级","slug":"js高级","permalink":"http://wang-zhibiao.github.io/categories/js高级/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"function","slug":"function","permalink":"http://wang-zhibiao.github.io/tags/function/"}],"keywords":[{"name":"js高级","slug":"js高级","permalink":"http://wang-zhibiao.github.io/categories/js高级/"}]},{"title":"JavaScript的变量以及数据类型","slug":"变量和js类型的理解","date":"2019-06-09T01:24:56.000Z","updated":"2019-07-14T01:27:28.709Z","comments":true,"path":"2019/06/09/变量和js类型的理解/","link":"","permalink":"http://wang-zhibiao.github.io/2019/06/09/变量和js类型的理解/","excerpt":"","text":"一、JavaScript数据类型ECMAScript标准规定了7种数据类型，其把这7种数据类型又分为两种：原始类型和对象类型。 原始类型 Null：只包含一个值：null Undefined：只包含一个值：undefined Boolean：包含两个值：true和false Number：整数或浮点数，还有一些特殊值（-Infinity、+Infinity、NaN） String：一串表示文本值的字符序列 Symbol：一种实例是唯一且不可改变的数据类型 (在es10中加入了第七种原始类型BigInt，现已被最新Chrome支持) 对象类型 Object：自己分一类丝毫不过分，除了常用的Object，Array、Function等都属于特殊的对象 区分原始类型和对象类型 - 不可变性 原始类型存放在栈空间中，而复杂类型存放在堆空间中 栈内存： 存储的值大小固定 空间较小 可以直接操作其保存的变量，运行效率高 由系统自动分配存储空间 堆内存： 存储的值大小不定，可动态调整 空间较大，运行效率低 无法直接操作其内部存储，使用引用地址读取 通过代码进行分配空间 字符串 具备不可变性不管是字符串的裁切splice 还是 toLowerCase 都是在原有的基础上产生新的字符串 JavaScript中的原始类型的值被直接存储在栈中，在变量定义时，栈就为其分配好了内存空间。 由于栈中的内存空间的大小是固定的，那么注定了存储在栈中的变量就是不可变的 对象 具备可变性引用类型的值实际存储在堆内存中，它在栈中只存储了一个固定长度的地址，这个地址指向堆内存中的值。 数组 是一个复杂（引用）类型 通过一些api可以改变数组 pop() 删除数组最后一个元素，如果数组为空，则不改变数组，返回undefined，改变原数组，返回被删除的元素 push()向数组末尾添加一个或多个元素，改变原数组，返回新数组的长度 shift()把数组的第一个元素删除，若空数组，不进行任何操作，返回undefined,改变原数组，返回第一个元素的值 unshift()向数组的开头添加一个或多个元素，改变原数组，返回新数组的长度 reverse()颠倒数组中元素的顺序，改变原数组，返回该数组 sort()对数组元素进行排序，改变原数组，返回该数组 splice()从数组中添加/删除项目，改变原数组，返回被删除的元素 当我们进行复制时两者有着本质的区别 这里涉及到浅拷贝和深拷贝—本质是复制时是否改变复制的对象的数值或属性或方法 原始类型12345var name = 'wang';var newName = name;newName = 'Mr.wang';console.log(name) // =&gt;wangconsole.log(newName) // =&gt;Mr.wang 内存中有一个变量name，值为wang。我们从变量name复制出一个变量newName，此时在内存中创建了一个块新的空间用于存储wang，虽然两者值是相同的，但是两者指向的内存空间完全不同，这两个变量参与任何操作都互不影响。 引用类型12345var obj = &#123;name:'wang'&#125;;var newObj = obj;newObj.name = 'Mr.wang';console.log(obj.name) //=&gt; Mr.wangconsole.log(newObj.name)//=&gt; Mr.wang 当我们复制引用类型的变量时，实际上复制的是栈中存储的地址，所以复制出来的newObj实际上和obj指向的堆中同一个对象。因此，我们改变其中任何一个变量的值，另一个变量都会受到影响，这就是为什么会有深拷贝和浅拷贝的原因。 原始类型和引用类型的比较原始类型，比较时会直接比较它们的值，如果值相等，即返回true。 引用类型，比较时会比较它们的引用地址，虽然两个变量在堆中存储的对象具有的属性值都是相等的，但是它们被存储在了不同的存储空间，因此比较值为false。 区分null和undefinednull 表示被赋值过的对象，刻意把一个对象赋值为null，故意表示其为空，不应有值。 所以对象的某个属性值为null是正常的，null转换为数值时值为0。 undefined 表示“缺少值”，即此处应有一个值，但还没有定义， 如果一个对象的某个属性值为undefined，这是不正常的，如obj.name=undefined，我们不应该这样写，应该直接delete obj.name。 undefined转为数值时为NaN(非数字值的特殊值) JavaScript是一门动态类型语言，成员除了表示存在的空值外，还有可能根本就不存在（因为存不存在只在运行期才知道），这就是undefined的意义所在。对于JAVA这种强类型语言，如果有&quot;undefined&quot;这种情况，就会直接编译失败，所以在它不需要一个这样的类型。 你想不到的0.1+0.2≠0.3 本质是：由于数字在js中的计算是先转换为二进制在进行计算的，然后以十进制输出 12345678910111213141516171819202122232425262728function judgeFloat(n, m) &#123; const binaryN = n.toString(2); const binaryM = m.toString(2); console.log(`$&#123;n&#125;的二进制是 $&#123;binaryN&#125;`); console.log(`$&#123;m&#125;的二进制是 $&#123;binaryM&#125;`); const MN = m + n; const accuracyMN = (m * 100 + n * 100) / 100; const binaryMN = MN.toString(2); const accuracyBinaryMN = accuracyMN.toString(2); console.log(`$&#123;n&#125;+$&#123;m&#125;的二进制是$&#123;binaryMN&#125;`); console.log(`$&#123;accuracyMN&#125;的二进制是 $&#123;accuracyBinaryMN&#125;`); console.log(`$&#123;n&#125;+$&#123;m&#125;的二进制再转成十进制是$&#123;to10(binaryMN)&#125;`); console.log(`$&#123;accuracyMN&#125;的二进制是再转成十进制是$&#123;to10(accuracyBinaryMN)&#125;`); console.log(`$&#123;n&#125;+$&#123;m&#125;在js中计算是$&#123;(to10(binaryMN) === to10(accuracyBinaryMN)) ? '' : '不'&#125;准确的`); &#125; function to10(n) &#123; const pre = (n.split('.')[0] - 0).toString(2); const arr = n.split('.')[1].split(''); let i = 0; let result = 0; while (i &lt; arr.length) &#123; result += arr[i] * Math.pow(2, -(i + 1)); i++; &#125; return result; &#125; judgeFloat(0.1, 0.2); judgeFloat(0.6, 0.7); 计算机中所有的数据都是以二进制存储的，所以在计算时计算机要把数据先转换成二进制进行计算，然后在把计算结果转换成十进制。 由上面的代码不难看出，在计算0.1+0.2时，二进制计算发生了精度丢失，导致再转换成十进制后和预计的结果不符。 隐式转换 if语句和逻辑语句在if语句和逻辑语句中，如果只有单个变量，会先将变量转换为Boolean值，只有下面几种情况会转换成false，其余被转换成true： 123456nullundefined&apos;&apos;NaN0false 各种运数学算符我们在对各种非Number类型运用数学运算符(- * /)时，会先将非Number类型转换为Number类型; 12341 - true // 01 - null // 11 * undefined // NaN2 * [&apos;5&apos;] // 10 注意+是个例外，执行+操作符时： 1.当一侧为String类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。 2.当一侧为Number类型，另一侧为原始类型，则将原始类型转换为Number类型。 3.当一侧为Number类型，另一侧为引用类型，将引用类型和Number类型转换成字符串后拼接。 1234123 + &apos;123&apos; // 123123 （规则1）123 + null // 123 （规则2）123 + true // 124 （规则2）123 + &#123;&#125; // 123[object Object] （规则3） == 运算符使用==时，若两侧类型相同，则比较结果和===相同，否则会发生隐式转换，使用==时发生的转换可以分为几种不同的情况（只考虑两侧类型不同）： 1.NaN NaN和其他任何类型比较永远返回false(包括和他自己)。 1NaN == NaN // false 2.Boolean Boolean和其他任何类型比较，Boolean首先被转换为Number类型。 1234true == 1 // true true == &apos;2&apos; // falsetrue == [&apos;1&apos;] // truetrue == [&apos;2&apos;] // false 这里注意一个可能会弄混的点：undefined、null和Boolean比较，虽然undefined、null和false都很容易被想象成假值，但是他们比较结果是false，原因是false首先被转换成0： 12undefined == false // falsenull == false // false 3.String和Number String和Number比较，先将String转换为Number类型。 12123 == &apos;123&apos; // true&apos;&apos; == 0 // true 4.null和undefined null == undefined比较结果是true，除此之外，null、undefined和其他任何结果的比较值都为false。 1234567null == undefined // truenull == &apos;&apos; // falsenull == 0 // falsenull == false // falseundefined == &apos;&apos; // falseundefined == 0 // falseundefined == false // false 5.原始类型和引用类型 当原始类型和引用类型做比较时，对象类型会依照ToPrimitive规则转换为原始类型: 12&apos;[object Object]&apos; == &#123;&#125; // true&apos;1,2,3&apos; == [1, 2, 3] // true 来看看下面这个比较： 1[] == ![] // true !的优先级高于==，![]首先会被转换为false，然后根据上面第三点，false转换成Number类型0，左侧[]转换为0，两侧比较相等。 12[null] == false // true[undefined] == false // true 根据数组的ToPrimitive规则，数组元素为null或undefined时，该元素被当做空字符串处理，所以[null]、[undefined]都会被转换为0。 原型链的规则 1.所有引用类型都具有对象特性，即可以自由扩展属性 2.所有引用类型都具有一个proto（隐式原型）属性，是一个普通对象 3.所有的函数都具有prototype（显式原型）属性，也是一个普通对象 4.所有引用类型proto值指向它构造函数的prototype 5.当试图得到一个对象的属性时，如果变量本身没有这个属性，则会去他的proto中去找 toString上面我们在拆箱操作中提到了toString函数，我们可以调用它实现从引用类型的转换。 每一个引用类型都有toString方法，默认情况下，toString()方法被每个Object对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 &quot;[object type]&quot;，其中type是对象的类型。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"}],"keywords":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}]},{"title":"Es6解构赋值","slug":"Es6变量的解构赋值","date":"2019-05-11T02:10:56.000Z","updated":"2019-07-14T01:28:26.270Z","comments":true,"path":"2019/05/11/Es6变量的解构赋值/","link":"","permalink":"http://wang-zhibiao.github.io/2019/05/11/Es6变量的解构赋值/","excerpt":"","text":"变量的解构赋值 数组的解构赋值 对象的解构赋值 字符串的解构赋值 数值和布尔值的解构赋值 函数参数的解构赋值 1数组的解构赋值12345let [a,b,c] = [1,2,3] // 为abc各自an规律赋值let [a,[b,[c]]] = [1,[2,[3]]] //如果为嵌套数组，可以用一样的嵌套数组赋值let [x,y] = [1,2,3] //如果赋值两边长度不一，，则部分赋值 部分未赋值为uddefinedlet [...arr] = [1,2,3] //扩展运算符可以直接把所有的数字赋值给arr arr=[1,2,3]let [first,...arrAll]=[1,2,3,4] //当第一个first赋值以后，其他的数字都会给arrAll包含 first =1 arrAll=[2,3,4] 结构赋值为何左右两边为数组？正常的赋值是一个一个赋值，解构赋值是吧需要赋值的解析重构，循环赋值 通过数组可遍历的特性就可以解构 解构赋值的默认值123let [a=11] = [] //a输出为11 在赋值之前就已经赋值 解构只是再次赋值 不会冲突 注意点 [] 数组里面无任何值，但是有undefined 所以才会解构成功 ，否则部分赋值也不会实现，以下情况请注意 null与undefined有本质的区别，两者不等，所以赋值时可以成功为null，解构赋值也严格遵守严格运算符（===）let [x = 1] = [undefined];//x = 1let [x = 1] = [null]; //x = null 2对象的解构赋值12345678910let &#123;a&#125;=&#123;a:'good',b:'nice'&#125; //a = good 对象里不同于数组，它是无序的集合 所以赋值要用见来赋值 两者的键要相同//如果没有对应的键则会返回undefined//对象的解构赋值可以对内置对象进行赋值let&#123;log,sin,cos&#125; = Mathlet &#123;log&#125; = console//当取得所对应的对象的方法时，可以直接调用log('hello word') //控制台输出hello wordsin(90) //输出为 1let &#123;a，&#123;b&#125;&#125; = &#123;a:11,&#123;b:22&#125;&#125; //对象一样支持嵌套赋值var &#123;x = 3&#125; = &#123;&#125;; //也支持默认值 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。 注意点12345678let x;&#123;x&#125; = &#123;x: 1&#125;; //已经声明的变量再解构赋值会报错 ，&#123;x&#125; 会被解析为代码块//解决方法(&#123;x&#125;=&#123;x:1&#125;); //括号包裹//解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。(&#123;&#125;=&#123;a:dd&#125;) //语法可行但毫无意义//数组也是一种特殊的对象 他是用索引值当键let &#123;0:first&#125; = [1,2,3] 3字符串的解构赋值12let [a,b,c,d,e] = 'hello' // a=h,b=e,c=l,d=l,e=o //这是将字符串转化为数组遍历在赋值let &#123;length : len&#125; = 'hello'; //len = 5 // 数组都有length这个键 表示长度 4数值和布尔值的解构赋值12345678let &#123;toString: s&#125; = 123;s === Number.prototype.toString // true//数字和布尔类型会转化为对象 所以在s的原型链与赋值的原型链相等 前面的键 toString 是转化为字符串的方法let &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true// 由于ndefined和null无法转为对象 所以不能进行赋值let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 5函数参数的解构赋值函数的解构赋值我们经常使用 当我们进行传参时 就会进行解构赋值 1234function fn(a,b)&#123; return a+b&#125;fn(2,3) //a和b都会在函数调用时传参解构赋值 函数参数的默认值 12345678function fn(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;fn(&#123;x: 3, y: 8&#125;); // [3, 8] fn(&#123;x: 3&#125;); // [3, 0]fn(&#123;&#125;); // [0, 0]fn(); // [0, 0]//如果有默认值,参数没有就使用默认值 另一种函数的默认值 123456789function fn(&#123;x, y&#125; = &#123;x:0,y:0&#125;) &#123; return [x, y];&#125;fn(&#123;x: 3, y: 8&#125;); // [3, 8] fn(&#123;x: 3&#125;); // [3, undefined]fn(&#123;&#125;); // [undefined, undefined]fn(); // [0, 0]//如果有默认值,参数没有就使用默认值//这种写法使用了对象的键值对赋值，不是之前的值传递，所以 当参数为&#123;&#125;时 传递的是undefined 圆括号圆括号是为了解决赋值时解析的无法辨别，但是要注意使用时机，否则会报错","categories":[{"name":"基础","slug":"基础","permalink":"http://wang-zhibiao.github.io/categories/基础/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"Es6","slug":"Es6","permalink":"http://wang-zhibiao.github.io/tags/Es6/"}],"keywords":[{"name":"基础","slug":"基础","permalink":"http://wang-zhibiao.github.io/categories/基础/"}]},{"title":"let var const三种定义方式及闭包","slug":"var let const三种定义方式及闭包","date":"2019-05-09T16:10:56.000Z","updated":"2019-07-14T01:27:55.718Z","comments":true,"path":"2019/05/10/var let const三种定义方式及闭包/","link":"","permalink":"http://wang-zhibiao.github.io/2019/05/10/var let const三种定义方式及闭包/","excerpt":"","text":"let var const 之间的区别varvar的作用域是根据函数作用域的， 他在函数内起作用 这里就引用到闭包和作用域链 12345678function out()&#123; var a = 000; //=&gt; 这个a的作用域作用在out内 而info函数在out函数内 所以可以调用 b=222 //=&gt; 报错err 因为b的作用域在info函数内 包裹他的out函数不可以调用它function info()&#123; var b=999; a= 111; &#125;&#125; var 的变量提升 12345678function ()&#123; var a=10; &#125;//变量提升 就是var定义的变量会在先声明再赋值 提升到函数顶部function()&#123; var a; a=10;&#125; letlet的作用域的块级作用域，不会变量提升 可以理解为在某块范围内作用 与var 的函数作用域不同在于 let的作用域会形成闭包 12345678910111213for (var i = 0; i &lt; 3; i++) &#123; setTimeout(function () &#123; console.log(i); &#125;, 1000)&#125;//输出 3 3 3for (let i = 0; i &lt; 3; i++) &#123; setTimeout(function () &#123; console.log(i); &#125;, 1000)&#125;//输出 0 1 2 12var会在全局声明 而setTimeout 是一个定时器 也是异步回调 会在同步执行完毕再执行异步 所以当for循环完毕 i=3时调用三次定时器 let 的作用范围会在for循环内 每循环一次 i会形成一次闭包 i会被setTimeout调用 constconst代表一个值的常量索引，常量的值在垃圾回收前永远不能改变，所以需要谨慎使用。 cosnt定义的值不能被改变 否则会报错 12Uncaught TypeError: Assignment to constant variable.未捕获的类型错误:赋值给常量变量。 闭包外部可以访问内部的私有变量 可以返回携带状态的函数，并且状态隐藏 可以做到变量的私有 123456function f1()&#123; var n=999; function f2()&#123; alert(n); // 999 &#125;&#125; 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！ 123456789function f1()&#123; var n=999; function f2()&#123; alert(n); &#125;return f2;&#125;var result=f1();result(); // 999 闭包就是能够读取其他函数内部变量的函数 要形成闭包 必须两层function函数作用域 123456789101112function f1()&#123; var n=999; Add=function()&#123;n+=1&#125; function f2()&#123; console.log(n)&#125;return f2;&#125;var result=f1();result(); // 999Add();result(); // 1000 这里形成闭包后，f1的局部变量n一直保存在内存中，并没有因为f1的重复调用而清除 原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 缺点由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 12345678910var name = \"The Window\";var object = &#123; name: \"My Object\", getNameFunc: function () &#123; return function () &#123; return this.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); 经典闭包题 个人理解 object.getNameFunc() 执行到这一步时 调用object内的函数 返回一个function（）{return this.name} 这时候 name还是My Object 当再次执行时object.getNameFunc()() 调用了外部的name 输出为The Window","categories":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"function","slug":"function","permalink":"http://wang-zhibiao.github.io/tags/function/"}],"keywords":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}]},{"title":"隐藏元素的方法","slug":"隐藏元素的方法","date":"2019-03-21T16:10:56.000Z","updated":"2019-07-13T02:29:27.392Z","comments":true,"path":"2019/03/22/隐藏元素的方法/","link":"","permalink":"http://wang-zhibiao.github.io/2019/03/22/隐藏元素的方法/","excerpt":"","text":"隐藏类型 屏幕并不是唯一的输出机制，比如说屏幕上看不见的元素（隐藏的元素），其中一些依然能够被读屏软件阅读出来（因为读屏软件依赖于可访问性树来阐述）。为了消除它们之间的歧义，我们将其归为三大类： 完全隐藏：元素从DOM树中消失，不占据空间。 视觉上的隐藏：屏幕中不可见，占据空间。 语义上的隐藏：读屏软件不可读，但正常占据空间。 完全隐藏 1.display 属性1display: none; 2.hidden 属性 HTML5 新增属性，相当于 display: none 12&lt;div hidden&gt;&lt;/div&gt; 视觉上的隐藏,在页面中还存在 3.利用 position 和 盒模型 将元素移出可视区范围 设置 posoition 为 absolute 或 fixed，\b通过设置 top、left 等值，将其移出可视区域。 12position:absolute;left: -999px; 设置 position 为 relative，通过设置 top、left 等值，将其移出可视区域。 12position: relative;left: -999px; 设置 margin 值，将其移出可视区域范围（可视区域占位）。 12margin-left: -99999px;height: 0; 3.利用 transfrom 缩放 12transform: scale(0);height: 0; 移动 translateX, translateY 12transform: translateX(-99999px);height: 0 旋转 rotate 1transform: rotateY(90deg) //直角在界面上形成线性视觉屏蔽 4.设置其大小为0 宽高为0，字体大小为0： 123height: 0;width: 0;font-size: 0; 宽高为0，超出隐藏: 123height: 0;width: 0;overflow: hidden; 5.设置透明度为01opacity: 0; 6.visibility属性1visibility: hidden; 7.层级覆盖，z-index 属性12position: relative;z-index: -999; 再设置一个层级较高的元素覆盖在此元素上。8.clip-path 裁剪1clip-path: polygon(0 0, 0 0, 0 0, 0 0); 语义上的隐藏","categories":[{"name":"基础","slug":"基础","permalink":"http://wang-zhibiao.github.io/categories/基础/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"function","slug":"function","permalink":"http://wang-zhibiao.github.io/tags/function/"}],"keywords":[{"name":"基础","slug":"基础","permalink":"http://wang-zhibiao.github.io/categories/基础/"}]},{"title":"BFC协议","slug":"BFC协议","date":"2018-12-29T16:14:56.000Z","updated":"2019-07-14T01:29:51.152Z","comments":true,"path":"2018/12/30/BFC协议/","link":"","permalink":"http://wang-zhibiao.github.io/2018/12/30/BFC协议/","excerpt":"","text":"什么是BFC？BFC的布局规则是什么？如何创建BFC？查看解析 Box 是 CSS 布局的对象和基本单位，页面是由若干个Box组成的。 元素的类型 和 display 属性，决定了这个 Box 的类型。不同类型的 Box 会参与不同的 Formatting Context。 Formatting Context Formatting Context 是页面的一块渲染区域，并且有一套渲染规则，决定了其子元素将如何定位，以及和其它元素的关系和相互作用。 Formatting Context 有 BFC (Block formatting context)，IFC (Inline formatting context)，FFC (Flex formatting context) 和 GFC (Grid formatting context)。FFC 和 GFC 为 CC3 中新增。 BFC布局规则 BFC内，盒子依次垂直排列。 BFC内，两个盒子的垂直距离由 margin 属性决定。属于同一个BFC的两个相邻Box的margin会发生重叠【符合合并原则的margin合并后是使用大的margin】 BFC内，每个盒子的左外边缘接触内部盒子的左边缘（对于从右到左的格式，右边缘接触）。即使在存在浮动的情况下也是如此。除非创建新的BFC。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算。 如何创建BFC 根元素 浮动元素（float 属性不为 none） position 为 absolute 或 fixed overflow 不为 visible 的块元素 display 为 inline-block, table-cell, table-caption BFC 的应用 防止 margin 重叠 (同一个BFC内的两个两个相邻Box的 margin 会发生重叠，触发生成两个BFC，即不会重叠) 清除内部浮动 (创建一个新的 BFC，因为根据 BFC 的规则，计算 BFC 的高度时，浮动元素也参与计算) 自适应多栏布局 (BFC的区域不会与float box重叠。因此，可以触发生成一个新的BFC)","categories":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"function","slug":"function","permalink":"http://wang-zhibiao.github.io/tags/function/"}],"keywords":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}]},{"title":"盒子居中的方法","slug":"盒子居中的方法","date":"2018-12-20T11:50:59.000Z","updated":"2019-07-14T01:29:23.856Z","comments":true,"path":"2018/12/20/盒子居中的方法/","link":"","permalink":"http://wang-zhibiao.github.io/2018/12/20/盒子居中的方法/","excerpt":"","text":"HTML盒子居中的方法：1.宽度和高度已知的。思路： 父元素相对定位 子元素绝对定位 子元素{ left: 50%;top: 50%;margin-left: 减去子元素的宽度一半。margin-top: 减去子元素的高度一半； } 1234567891011121314151617&lt;style type=\"text/css\"&gt; #box&#123; width: 400px; height: 200px; position: relative; background: red; //方便观看 &#125; #box1&#123; width: 200px; height: 100px; position: absolute; top: 50%; left: 50%; margin-left: -100px; //定位后偏移值超过子元素的宽度一半需减去 margin-top: -50px; //定位后偏移值超过子元素的高度一半需减去 background: green; &#125; 2.宽度和高度可以随意改变思路： 父元素相对定位 子元素绝对定位 子元素{ left: 0;top: 0; bottom:0;right:0; margin:auto; } 1234567891011121314151617#box&#123; width: 800px; height: 400px; position: relative; background: red; &#125;#box1&#123; width: 100px; height: 50px; position: absolute;//四个方位定义盒子所在的位置 当所有为0&amp;&amp;margin:auto时,盒子居中 top: 0; right: 0; bottom: 0; left: 0; margin: auto; background: green; &#125; 3.flex布局123456789101112131415.box&#123; width: 400px; height: 200px; background: #f99; &#125; .box1&#123; width: 200px; height: 100px; background: green; &#125; .center&#123; display: flex; //开启弹性盒子 主轴侧轴交叉得到居中 justify-content: center;//实现水平居中 align-items: center;//实现垂直居中 &#125; 4.平移 定位+transform123456789101112131415.parent_box&#123; width: 400px; height: 200px; background: red; position: relative; &#125; .child_box&#123; width: 200px; height: 100px; background: green; position: absolute;//与第一个类似 但可以根据子元素的宽高自动居中 top: 50%; left: 50%; transform: translate( -50%,-50%);//平移相当于盒子margin(左,上)减半 &#125; 如何清除浮动清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。 父级添加overflow属性方法可以通过触发BFC的方式，可以实现清除浮动效果。 使用after伪元素清除浮动12345678.clearfix:after &#123; content: \"\"; display: block; height: 0; clear: both; visibility: hidden;&#125; .clearfix &#123;*zoom: 1;&#125; /* IE6、7 专有 */ 使用before和after双伪元素清除浮动12345678910.clearfix:before,.clearfix:after &#123; content:\"\"; display:table; /* 这句话可以触发BFC BFC可以清除浮动 */&#125;.clearfix:after &#123; clear:both;&#125;.clearfix &#123; *zoom:1;&#125; 浏览器查询Unicode编码 浏览器控制台输出 escape(‘查询字符串’)","categories":[{"name":"知识","slug":"知识","permalink":"http://wang-zhibiao.github.io/categories/知识/"}],"tags":[{"name":"debug","slug":"debug","permalink":"http://wang-zhibiao.github.io/tags/debug/"},{"name":"css","slug":"css","permalink":"http://wang-zhibiao.github.io/tags/css/"},{"name":"html","slug":"html","permalink":"http://wang-zhibiao.github.io/tags/html/"}],"keywords":[{"name":"知识","slug":"知识","permalink":"http://wang-zhibiao.github.io/categories/知识/"}]}]}