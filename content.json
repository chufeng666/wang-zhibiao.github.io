{"meta":{"title":"wang-zhibiao'blog","subtitle":"I am is a boy","description":"note","author":"wangzhibiao","url":"http://wang-zhibiao.github.io"},"pages":[{"title":"about","date":"2019-06-16T13:48:33.000Z","updated":"2019-06-16T13:48:34.047Z","comments":true,"path":"about/index.html","permalink":"http://wang-zhibiao.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"node开启服务器","slug":"node基本服务器创建","date":"2019-07-11T16:10:56.000Z","updated":"2019-08-10T12:35:40.235Z","comments":true,"path":"2019/07/12/node基本服务器创建/","link":"","permalink":"http://wang-zhibiao.github.io/2019/07/12/node基本服务器创建/","excerpt":"","text":"搭建一个nodejs服务器nodejs搭建服务器，需要4步： 1.引入http模块 1var http = require('http');// 语法就是 require(模块名称) 2.创建服务器对象 1var server = http.createServer(); 3.监听ip和端口 12345server.listen(端口,ip,回调函数);// 例如server.listen(8080,'127.0.0.1',function()&#123; 提示用户，可以通过什么地址访问服务器&#125;); 4.监听浏览器请求服务器的事件 123456server.on('request',function(req,res)&#123; // req - request - 请求对象，里面有请求所包含的数据 -请求头、请求体... // res - response - 响应对象，里面包含的是响应的数据 - 响应头、响应体... // 在事件处理程序里面把数据返回给浏览器 res.end(数据);&#125;) 12345678910111213141516var http = require('http');// 引入http模块,养成一个习惯，在node里面，要使用什么功能，就需要引入对应的模块// 接着创建服务器对象var server = http.createServer();// 接着为了可以 让浏览器找到我，监听ip和端口// server.listen(端口,ip,回调函数) // 其实ip和端口都是可以省略的，如果端口省略，默认是80，如果ip省略，默认是127.0.0.1server.listen(8080,'127.0.0.1',function()&#123; console.log('服务器已经开启，请通过 http://127.0.0.1:8080 访问');&#125;);// 开始监听浏览器的请求server.on('request',function(req,res)&#123; // 在请求事件的处理程序里面，返回数据给浏览器 setTimeout(function()&#123; res.end('hello world'); &#125;,3000);&#125;);","categories":[{"name":"node","slug":"node","permalink":"http://wang-zhibiao.github.io/categories/node/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"node","slug":"node","permalink":"http://wang-zhibiao.github.io/tags/node/"}],"keywords":[{"name":"node","slug":"node","permalink":"http://wang-zhibiao.github.io/categories/node/"}]},{"title":"高德地图与vue的使用","slug":"高德地图","date":"2019-06-26T02:00:56.000Z","updated":"2019-07-25T02:00:33.243Z","comments":true,"path":"2019/06/26/高德地图/","link":"","permalink":"http://wang-zhibiao.github.io/2019/06/26/高德地图/","excerpt":"","text":"首先介绍一下vue与高德 之间的联系vue与数据息息相关，而且，vue的数据使用是通过this来调用 也是把数据挂载到了vm实例身上，调用时，使用this调用vm实例上挂载的数据及其方便，所以在vue的使用时我们偶尔也会碰到this指向不明，指向的不是vm实例导致 数据输出undefined 高德的API使用简单，我们可以思考：与vue的this的挂载使用 初始化地图调用地图接口-同步1234&lt;script type=\"text/javascript\" src=\"https://webapi.amap.com/maps?v=1.4.15&amp;key=你个人的key，下面有高德与百度的链接\" &gt;&lt;/script&gt; 高德地图 百度地图 调用接口-异步12345678window.onLoad = function()&#123; var map = new AMap.Map('container');&#125;var url = 'https://webapi.amap.com/maps?v=1.4.15&amp;key=您申请的key值&amp;callback=onLoad';var jsapi = doc.createElement('script');jsapi.charset = 'utf-8';jsapi.src = url;document.head.appendChild(jsapi); 两者各有优缺，看场景使用 官方的使用12345var map = new AMap.Map('container', &#123; zoom:11,//级别 center: [116.397428, 39.90923],//中心点坐标 viewMode:'3D'//使用3D视图&#125;); 与vue结合使用1234567891011data()&#123; return &#123; map:null &#125;&#125;this.map = new AMap.Map(\"hotelMap\", &#123; zoom: 11, //级别 center: [116.397428, 39.90923], //中心点坐标 viewMode: \"3D\" //使用3D视图 &#125;); 两者的区别只是this与var的不同，但是实际上var 是定义一个全局的map变量让我们使用，我们在哪个函数都能使用map 因为他是全局的变量 this却是让map这个变量挂载到vm实例身上，所以你需要在data里初始化map 你的地图需要描点与打开信息窗体时123456789data() &#123; return &#123; MapData:[], // 后台数据初始化 map: null, //地图初始化 infoWindow // 信息窗体 markers: null, // 点的数据 center: [118.796623, 32.059352] // 地图中心点 &#125;; &#125;, 在vue调用地图时最好使用定时器调用，因为地图加载需要时间 123setTimeout(() =&gt; &#123; this.setMapInfo(); &#125;, 3000); 生成多个描点 需要后台返回经纬度信息，下面使用的数据已经是后台返回的带有经纬度信息location：{ longitude：经度 ，latitude：纬度} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546methods:&#123; setMapInfo() &#123; const &#123;location&#125; = this.MapData[3] //数据的第三条数据当地图中心 //设置地图中心点 this.center = [location.longitude,location.latitude] this.map = new AMap.Map(\"hotelMap\", &#123; //初始化地图 zoom: 10, //级别 center: this.center, //中心点坐标 viewMode: \"3D\" //使用3D视图 &#125;); //数据的循环 让点循环生成 this.MapData.forEach(v =&gt; &#123; //生成多个坐标点 this.setMarker(v.area, [v.location.longitude, v.location.latitude], v); //第一个v.area 是点的标识，第二个是一个经纬度数据，第三个是v 后台的其他信息 ==》可以直接写参数v 其他的在setMarker &#125;); &#125;, //添加点标记 setMarker(markers, position, data) &#123; //点的设置 this.markers = new AMap.Marker(&#123; //点的内容，也是你在地图中显示的点的样式 你可以是一张图片 可以是圆，多边形 content: `&lt;div style=\"width:20px;height:28px;text-align:center;\" class=\"el-icon-location\"&gt;&lt;/div&gt;`, //点的经纬度 也是位置 position: position, ///点也有偏移 offset: new AMap.Pixel(-17, -42), // 相对于基点的偏移位置 //地图一定要绑定在你想使用的地图上 也就是说在一个页面不一定只有一个地图 map: this.map //把点标记绑在前面初始化的 map_ 上，否则不显示 &#125;); //注册点的触发事件，触发信息窗体 this.markers.on(\"mousemove\", () =&gt; &#123; //定义信息窗体的div内容 this.content = `&lt;div&gt;&lt;img src=\"$&#123;data.photos&#125;\" style=\"width:100px; height:50px;margin:0 auto\"&gt; &lt;div&gt;&lt;b style=\"color:#666\"&gt;$&#123;data.name&#125;&lt;/b&gt;` //重新设置信息窗体 this.infoWindow = new AMap.InfoWindow(&#123; //信息窗体相对于基点=》也就是经纬度的点 偏移的xy轴量 offset: new AMap.Pixel(-5, -50), content: this.content //传入 dom 对象，或者 html 字符串 &#125;); //设置信息窗体需要打开 ，参数是 这个地图this.map 和 position 打开的位置 this.infoWindow.open(this.map, position); &#125;); &#125;,&#125; 实际效果 当你想要在地图外响应地图时123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;template&gt; &lt;div class=\"traffic\"&gt; &lt;ul&gt; &lt;li v-for=\"(item,index) in sceneryMapdata\" :key=\"index\" style=\"cursor:pointer;\" @mousemove=\"choose(item)\"&gt; &lt;span&gt;&#123;&#123;item.name&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;item.biz_ext.rating&#125;&#125;公里&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;data() &#123; return &#123; //地图的标签 activeName:\"first\", // 地图的数据 sceneryMapdata:null, //地图加载时间 loading:true, //地图窗体信息 content: \"高级酒店\", map: null, markers: null, infoWindow: null, center: [118.796623, 32.059352] &#125;; &#125;,methods: &#123; //触发地图的点 choose(data)&#123; let temp = data.location.split(\",\"); temp = [temp[0]-0,temp[1]-0] this.content = data.name this.infoWindow = new AMap.InfoWindow(&#123; offset: new AMap.Pixel(-5, -50), content: this.content //传入 dom 对象，或者 html 字符串 &#125;); this.infoWindow.open(this.map, temp); &#125;, //添加点标记 setMarker(markers, position, data) &#123; this.markers = new AMap.Marker(&#123; content: `&lt;div style=\"width:20px;height:28px;text-align:center;\" class=\"el-icon-location\"&gt;&lt;/div&gt;`, position: position, offset: new AMap.Pixel(-17, -42), // 相对于基点的偏移位置 map: this.map //把点标记绑在前面初始化的 map_ 上，否则不显示 &#125;); AMap.event.addListener(this.markers,\"mousemove\", ()=&gt;&#123; this.content = data.name; this.infoWindow = new AMap.InfoWindow(&#123; offset: new AMap.Pixel(-5, -50), content: this.content //传入 dom 对象，或者 html 字符串 &#125;); this.infoWindow.open(this.map, position); &#125;); &#125;, setMapInfo() &#123; const &#123;location&#125; = this.sceneryMapdata[3] //重新设置地图中心点 const temp = location.split(\",\"); this.center = [temp[0]-0,temp[1]-0] this.map = new AMap.Map(\"detailMap\", &#123; zoom: 14, //级别 center: this.center, //中心点坐标 viewMode: \"3D\" //使用3D视图 &#125;); this.sceneryMapdata.forEach(v =&gt; &#123; //生成多个坐标点 let str = v.location.split(\",\"); this.setMarker(v.name, [str[0]-0,str[1]-0], v); &#125;); &#125;, //请求数据 getMapdata()&#123; this.$axios(&#123; url:`https://restapi.amap.com/v3/place/text`, params:&#123; keyword:'', location:\"118.732841,32.077242\", city:\"南京市\", types:\"风景名胜\", output:'json', page:1, offset:10, key:'key私人定制' //=》 这个key是一个web服务 当你创建key可以选择 &#125; &#125;).then(res=&gt;&#123; this.sceneryMapdata = res.data.pois &#125;) &#125; &#125;, mounted() &#123; setTimeout(() =&gt; &#123; this.setMapInfo(); &#125;, 3000); //请求数据 this.getMapdata() &#125;&#125;;","categories":[{"name":"vue-高德地图","slug":"vue-高德地图","permalink":"http://wang-zhibiao.github.io/categories/vue-高德地图/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"vue高德地图","slug":"vue高德地图","permalink":"http://wang-zhibiao.github.io/tags/vue高德地图/"}],"keywords":[{"name":"vue-高德地图","slug":"vue-高德地图","permalink":"http://wang-zhibiao.github.io/categories/vue-高德地图/"}]},{"title":"JS执行上下文","slug":"js上下文执行","date":"2019-06-24T19:10:56.000Z","updated":"2019-07-24T09:55:58.262Z","comments":true,"path":"2019/06/25/js上下文执行/","link":"","permalink":"http://wang-zhibiao.github.io/2019/06/25/js上下文执行/","excerpt":"","text":"在开始说明JS上下文栈和作用域之前，我们先说明下JS上下文以及作用域的概念。执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。执行上下文类型分为：全局执行上下文函数执行上下文执行上下文创建过程中，需要做以下几件事:创建变量对象：首先初始化函数的参数arguments，提升函数声明和变量声明。创建作用域链（Scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。确定this的值，即 ResolveThisBinding作用域作用域负责收集和维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。—— 摘录自《你不知道的JavaScript》(上卷)作用域有两种工作模型：词法作用域和动态作用域，JS采用的是词法作用域工作模型，词法作用域意味着作用域是由书写代码时变量和函数声明的位置决定的。(with 和 eval 能够修改词法作用域，但是不推荐使用，对此不做特别说明)作用域分为：全局作用域函数作用域块级作用域JS执行上下文栈(后面简称执行栈)执行栈，也叫做调用栈，具有 LIFO (后进先出) 结构，用于存储在代码执行期间创建的所有执行上下文。规则如下：首次运行JavaScript代码的时候,会创建一个全局执行的上下文并Push到当前的执行栈中，每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push当前执行栈的栈顶。当栈顶的函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文的控制权将移动到当前执行栈的下一个执行上下文。 12345678910first()&#123; console.log('first')&#125;second()&#123; first()&#125;third()&#123; second()&#125;third()","categories":[{"name":"知识","slug":"知识","permalink":"http://wang-zhibiao.github.io/categories/知识/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"function","slug":"function","permalink":"http://wang-zhibiao.github.io/tags/function/"}],"keywords":[{"name":"知识","slug":"知识","permalink":"http://wang-zhibiao.github.io/categories/知识/"}]},{"title":"JS全局污染","slug":"JS全局污染","date":"2019-06-20T11:50:59.000Z","updated":"2019-07-01T01:20:12.648Z","comments":true,"path":"2019/06/20/JS全局污染/","link":"","permalink":"http://wang-zhibiao.github.io/2019/06/20/JS全局污染/","excerpt":"","text":"所谓全局变量污染 ：定义多个全局变量，函数，对象挂载在window上，如果重复使用则造成变量冲突 如果定义一个全局变量则会在window上挂载这个变量，所有的函数，对象，引用此js文件的都可以使用， 1234567891011&lt;script&gt; var a = 10; console.log(window);&lt;/script&gt;//输出Windowa: 10alert: ƒ alert()applicationCache: ApplicationCache &#123;status: 0, oncached: null, onchecking: null, ondownloading: null, onerror: null, …&#125;。。。。。。。 污染如同衣物沾上污渍，笔墨落入清水。 全局window是大家都能使用，如果在全局挂载变量太多，难免会调用重复的变量，改变其属性或值。 在开发中，多人共同开发，每个人的代码习惯不同，命名方法不同，如果其他人命名一个变量ID，那么，在调用ID时会改变上一个人的ID导致不是自己想要的ID。 123456789101112131415161718192021222324//developer_first.js&lt;script&gt; var ID = 10; console.log(ID);&lt;/script&gt;//developer_second.js&lt;script&gt; var ID = 2; console.log(ID);&lt;/script&gt;//developer_thirdly.js&lt;script&gt; var ID = 4; console.log(ID);&lt;/script&gt;//在主文件中调用&lt;head&gt;&lt;script src=\"developer_first.js\"&gt;&lt;/script&gt;&lt;script src=\"developer_second.js\"&gt;&lt;/script&gt; &lt;script src=\"developer_thirdly.js\"&gt;&lt;/script&gt; //最后的&lt;/head&gt;//=&gt;输出 4 4 4 ID会使用最后调用的js文件 为了避免全局污染，应慎重使用全局变量。了解模块化，或者let 定义的let不在window里 在script内有效 或者函数{}内有效，形成块级作用域","categories":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"}],"keywords":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}]},{"title":"js常见的继承方式","slug":"js的六种继承方式","date":"2019-06-20T01:10:56.000Z","updated":"2019-07-14T01:29:05.728Z","comments":true,"path":"2019/06/20/js的六种继承方式/","link":"","permalink":"http://wang-zhibiao.github.io/2019/06/20/js的六种继承方式/","excerpt":"","text":"js中的继承：在js中的继承只是属性和方法的继承 一般没有所谓的多态性，js的继承只是为了使代码的复用性更高。 js的继承是通过prototype来继承的1 原型链继承这种方式关键在于:**子类型的原型为父类型的一个实例对象。 12345678910111213141516171819 //父类型 function Person(name, age) &#123; this.name = name, this.age = age, this.play = [1, 2, 3] this.setName = function () &#123;&#125; &#125; Person.prototype.setAge = function () &#123;&#125; //子类型 function Student(price) &#123; this.price = price this.setScore = function () &#123;&#125; &#125;// Student.prototype.sayHello = function () &#123; &#125;//在这里写子类的原型方法和属性是无效的，//因为会改变原型的指向，所以应该放到重新指定之后 Student.prototype = new Person() // 子类型的原型为父类型的一个实例对象 var s1 = new Student(15000) var s2 = new Student(14000) console.log(s1,s2) 说明：定义一个Person父类型拥有对象和方法 Person.prototype.setAge = function () {} 这是一种在外部定义的一个在prototype原型上的方法 原理：每个function身上都有一个原型 在原型身上可以挂载方法和属性 Student.prototype = new Person() Student原型指向Person的实例对象，所以子类的实例就可以通过proto__访问到 Student.prototype 也就是Person的实例，这样就可以访问到父类的私有方法，然后再通过__proto指向父类的prototype就可以获得到父类原型上的方法。于是做到了将父类的私有、公有方法和属性都当做子类的公有属性 弊端：子类继承父类的属性和方法是将父类的私有属性和公有方法都作为自己的公有属性和方法 如果父类的私有属性有引用类型，子类继承的是这个父类的引用地址 如果子类操作父类的引用类型就会导致引用类型改变详情请看 js数据类型 我们需要在子类中添加新的方法或者是重写父类的方法时候，切记一定要放到替换原型的语句之后 2 借用构造函数继承这种方式关键在于:在子类型构造函数中通用call()调用父类型构造函数 12345678910111213function Person(name, age) &#123; this.name = name, this.age = age, this.setName = function () &#123;&#125;&#125;Person.prototype.setAge = function () &#123;&#125;function Student(name, age, price) &#123; Person.call(this, name, age) // 相当于: this.Person(name, age) /*this.name = name this.age = age*/ this.price = price&#125;var s1 = new Student('Tom', 20, 15000) 说明：在Student中构造Person的属性和方法，但是只是实现部分继承，如果父类的属性和方法太多，继承麻烦。但是解决了引用类型的问题因为这个构造函数是再次创建实例 弊端：子类的实例是根据父类的实例重新构造的，只能继承父类的实例属性和方法，不能继承原型属性和方法 代码复用性弱，每个子类都是父类的实例函数副本，影响性能 3 原型链+借用构造函数的组合继承这种方式关键在于:通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用 。 1234567891011121314151617181920212223function Person (name, age) &#123; this.name = name, this.age = age, this.setAge = function () &#123; &#125;&#125;Person.prototype.setAge = function () &#123; console.log(\"111\")&#125;function Student (name, age, price) &#123; //第一次调用构造函数 Person.call(this, name, age) this.price = price this.setScore = function () &#123; &#125;&#125;// 令Student的原型指向Person的实例Student.prototype = new Person()Student.prototype.constructor = Student//组合继承也是需要修复构造函数指向的Student.prototype.sayHello = function () &#123; &#125;var s1 = new Student('Tom', 20, 15000)var s2 = new Student('Jack', 22, 14000)console.log(s1)console.log(s1.constructor) //Studentconsole.log(p1.constructor) //Person 说明：在子类中调用构造函数生成实例对象但是只是包含属性，在子类的原型链上继承Person的实例，再次使用构造函数，是刚继承的实例构造成一个新的实例赋值 这个实例属于Student 构造函数（constructor） –字面意思，能构造一个实例的函数 弊端：无论如何都会调用两次构造函数，创建子类的原型和子类构造函数内部 4 组合继承的优化-原型指向这种方式关键在于 通过父类原型和子类原型指向同一对象，子类可以继承到父类的公有方法当做自己的公有方法，而且不会初始化两次实例方法/属性，避免的组合继承的缺点 12345678910111213141516171819function Person (name, age) &#123; this.name = name, this.age = age, this.setAge = function () &#123; &#125;&#125;Person.prototype.setAge = function () &#123; console.log(\"111\")&#125;function Student (name, age, price) &#123; //构造函数 Person.call(this, name, age) this.price = price this.setScore = function () &#123; &#125;&#125;//原型的赋值Student.prototype = Person.prototypeStudent.prototype.sayHello = function () &#123; &#125;var s1 = new Student('Tom', 20, 15000)console.log(s1) 说明：原型的赋值会让两个类指向同一个对象 ，与上面的区别在于一个是构造函数的赋值 这是原型的赋值，不会生成两次实例 弊端：父类指向不明，都是原型的赋值 同一个对象，没有父子关系，引用类型问题， 5 组合继承的优化-创建对象这种方式关键在于 借助原型可以基于已有的对象来创建对象，var B = Object.create(A)以A对象为原型，生成了B对象。B继承了A的所有属性和方法 12345678910111213141516171819function Person (name, age) &#123; this.name = name, this.age = age&#125;Person.prototype.setAge = function () &#123; console.log(\"111\")&#125;function Student (name, age, price) &#123; //构造函数 Person.call(this, name, age) this.price = price this.setScore = function () &#123; &#125;&#125;Student.prototype = Object.create(Person.prototype)//核心代码Student.prototype.constructor = Student//核心代码var s1 = new Student('Tom', 20, 15000)console.log(s1 instanceof Student, s1 instanceof Person) // true trueconsole.log(s1.constructor) //Studentconsole.log(s1) 说明：Student.prototype = Object.create(Person.prototype) 创建一个基于Person的的prototype创建一个新的对象给Student，继承Person 的所有的属性和方法 （Object.create）Object身上挂载create这个方法可以创建新的对象 目前来说，使用缺点都解决了，但是还未趋近完美 6 Es6的class继承ES6中引入了class关键字，class可以通过extends关键字实现继承，还可以通过static关键字定义类的静态方法,这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。 ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。 需要注意的是，class关键字只是原型的语法糖，JavaScript继承仍然是基于原型实现的。 12345678910111213141516171819202122232425262728class Person &#123; //调用类的构造方法 constructor(name, age) &#123; this.name = name this.age = age &#125; //定义一般的方法 showName () &#123; console.log(\"调用父类的方法\") console.log(this.name, this.age); &#125;&#125;let p1 = new Person('kobe', 39)console.log(p1)//定义一个子类class Student extends Person &#123; constructor(name, age, salary) &#123; super(name, age)//通过super调用父类的构造方法 this.salary = salary &#125; showName () &#123;//在子类自身定义方法 console.log(\"调用子类的方法\") console.log(this.name, this.age, this.salary); &#125;&#125;let s1 = new Student('wade', 38, 1000000000)console.log(s1)s1.showName() 说明：本质上原型和class没有区别，但是代码的整洁可读性更高 ，super相当于原型继承的 Person.call(this, name, age)","categories":[{"name":"js高级","slug":"js高级","permalink":"http://wang-zhibiao.github.io/categories/js高级/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"function","slug":"function","permalink":"http://wang-zhibiao.github.io/tags/function/"}],"keywords":[{"name":"js高级","slug":"js高级","permalink":"http://wang-zhibiao.github.io/categories/js高级/"}]},{"title":"vue组件传值","slug":"vue组件传值","date":"2019-06-15T04:10:56.000Z","updated":"2019-07-24T09:57:14.861Z","comments":true,"path":"2019/06/15/vue组件传值/","link":"","permalink":"http://wang-zhibiao.github.io/2019/06/15/vue组件传值/","excerpt":"","text":"1父传子通过父组件定义动态绑定一个数据来给子组件传递数据 ，子组件通过props来接受数据 1:data=\"data\" =&gt;&gt; props:&#123;data&#125; &gt;&gt;&gt;&gt;直接在template中使用data 具体例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;father&gt;&lt;/father&gt; &lt;/div&gt; &lt;template id='father'&gt; &lt;div class=\"father\"&gt; &lt;p&gt;我是父组件&#123;&#123;fname&#125;&#125;&lt;/p&gt; &lt;p&gt;我要告诉我儿子其实他是&#123;&#123;type&#125;&#125;&lt;/p&gt; &lt;son :mytype=\"type\"&gt;&lt;/son&gt; &lt;/div&gt; &lt;/template&gt; &lt;template id='son'&gt; &lt;div class=\"son\"&gt; &lt;p&gt;我是子组件&#123;&#123;sname&#125;&#125;&lt;/p&gt; &lt;p&gt;我的老爸告诉我我其实是&#123;&#123;mytype&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // 创建父组件 Vue.component('father', &#123; template: '#father', data() &#123; return &#123; fname:'老爸', type:'穷二代' &#125; &#125;, // 通过components来创建子组件,可以创建多个 components: &#123; 'son': &#123; template: '#son', props:['mytype'], data() &#123; return &#123; sname:'小明', // mytype:'??' &#125; &#125; &#125; &#125; &#125;) var vm = new Vue(&#123; el: '#app', data: &#123; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2子传父通过子组件发射（$emit）数据 父组件接受数据 1this.$emit(事件名称,你想传递的数据) =&gt;&gt;父组件监听这个事件（@/v-on） @事件名称=“方法（参数）” =&gt;&gt;这个方法默认参数就是传递的数据 具体例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;father&gt; &lt;/father&gt; &lt;/div&gt; &lt;template id='father'&gt; &lt;div class=\"father\" style='border:solid 1px'&gt; &lt;p&gt;我是父组件&#123;&#123;fname&#125;&#125;&lt;/p&gt; &lt;p&gt;我的儿子告诉我他的女朋友的名字叫&#123;&#123;erxifu&#125;&#125;&lt;/p&gt; &lt;!-- &lt;son v-on:getname='ok'&gt;&lt;/son&gt; --&gt; &lt;son @getname='ok'&gt;&lt;/son&gt; &lt;/div&gt; &lt;/template&gt; &lt;template id='son'&gt; &lt;div class=\"son\"&gt; &lt;p&gt;我是子组件&#123;&#123;sname&#125;&#125;&lt;/p&gt; &lt;button @click='tellname'&gt;点击告诉我老爸我的女朋友叫&#123;&#123;mygfname&#125;&#125;&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // 创建父组件 Vue.component('father', &#123; template: '#father', data() &#123; return &#123; fname:'老爸', erxifu:'??' &#125; &#125;, methods:&#123; // 这个事件处理函数默认有一个参数,这个参数就是之前事件传递的数据 ok(data)&#123; console.log(data) this.erxifu = data &#125; &#125;, // 通过components来创建子组件,可以创建多个 components: &#123; 'son': &#123; template: '#son', data() &#123; return &#123; sname:'小明', mygfname:'小红' &#125; &#125;, methods:&#123; tellname()&#123; // 发射一个事件 // this.$emit(事件名称,你想传递的数据) // 数据可以是任意数据 this.$emit('getname',this.mygfname) &#125; &#125; &#125; &#125; &#125;) var vm = new Vue(&#123; el: '#app', data: &#123; &#125;, mounted()&#123; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html 3子传子通过事件总线传值，子组件通过事件总线对象发射数据，父组件接受数据 123var bus = new Vue() = \"创建vue事件总线\" =&gt;&gt; 子组件通过bus.$emit(事件名称,你想传递的数据) ==&gt;&gt;兄弟组件通过bus.$on(事件名称,(传递过来的数据)=&gt;&#123; 处理逻辑&#125;) 具体例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;father&gt; &lt;/father&gt; &lt;/div&gt; &lt;template id='father'&gt; &lt;div class=\"father\" style='border:solid 1px'&gt; &lt;p&gt;我是父组件&#123;&#123;fname&#125;&#125;&lt;/p&gt; &lt;son&gt;&lt;/son&gt; &lt;dauther&gt;&lt;/dauther&gt; &lt;/div&gt; &lt;/template&gt; &lt;template id='son'&gt; &lt;div class=\"son\"&gt; &lt;p&gt;我是儿子组件&#123;&#123;sname&#125;&#125;&lt;/p&gt; &lt;p&gt;我的妹妹回来了,跟我说她的男朋友叫:&#123;&#123;meifu&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;template id='dauther'&gt; &lt;div class=\"dauther\"&gt; &lt;p&gt;我是女儿组件&#123;&#123;dname&#125;&#125;&lt;/p&gt; &lt;button @click='tellname'&gt;点击向我哥哥炫耀我的男朋友的名字叫&#123;&#123;mybfname&#125;&#125;&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // 创建一个事件总线 var bus = new Vue() // 创建父组件 Vue.component('father', &#123; template: '#father', data() &#123; return &#123; fname: '老爸' &#125; &#125;, // 通过components来创建子组件,可以创建多个 components: &#123; 'son': &#123; template: '#son', data() &#123; return &#123; sname: '小明', meifu:'??' &#125; &#125;, // 在mounTed钩子函数中进行事件的监听 mounted()&#123; // 通过事件总线的$on进行事件的监听 // 事件处理函数默认有一个参数,就是传递的数据 bus.$on('getname',(data) =&gt; &#123; console.log(data) this.meifu = data &#125;) &#125; &#125;, 'dauther': &#123; template: '#dauther', data() &#123; return &#123; dname: '小红', mybfname:'狗蛋' &#125; &#125;, methods:&#123; // 通过事件总线发射一个事件 tellname()&#123; bus.$emit('getname',this.mybfname) &#125; &#125; &#125; &#125; &#125;) var vm = new Vue(&#123; el: '#app', data: &#123; &#125;, mounted() &#123; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"vue基础","slug":"vue基础","permalink":"http://wang-zhibiao.github.io/categories/vue基础/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://wang-zhibiao.github.io/tags/vue/"}],"keywords":[{"name":"vue基础","slug":"vue基础","permalink":"http://wang-zhibiao.github.io/categories/vue基础/"}]},{"title":"来自平时的笔记","slug":"来自平时的笔记","date":"2019-06-11T16:00:00.000Z","updated":"2019-07-24T09:57:47.299Z","comments":true,"path":"2019/06/12/来自平时的笔记/","link":"","permalink":"http://wang-zhibiao.github.io/2019/06/12/来自平时的笔记/","excerpt":"","text":"隐藏元素：（1）visibility: hidden; 隐藏元素，占位置（2）display: none; 隐藏元素，不占位置（3）宽高设为0 显示元素： 与对应的隐藏属性用相同的属性，只不过值不同（1）visibility: visible 将隐藏的元素显示（2）display: block 将隐藏的元素显示，并能改变元素的显示方式 鼠标样式：cursor: pointer; /鼠标小手/ cursor: text; /文本光标/ cursor: move; /移动光标/ cursor: help; /鼠标小手/ 溢出文本处理overflow: hidden;overflow: visible;overflow: auto;overflow: scroll; 使用省略号替代溢出文本*必须让文本在一行显示，不能换行：white-space: nowrap;*溢出隐藏：overflow: hidden;*使用省略号替代文本：text-overflow: ellipsis; 设置文本间距：letter-spacing: 10px; 设置文字之间的间距word-spacing: 10px; 设置每个单词之间的间距 外轮廓线：outline(不占外边距位置)不影响盒子大小和距离outline: none;outline: 1px solid #fff; 防止文本域（textarea）拖拽改变大小：textarea { resize: none;} 垂直对齐方式：（只对行内元素和行内块级元素有效）verical-algin: middle; ***设置图片、input按钮与输入框等和文本的垂直对齐verical-algin: top; 设置顶线对齐 固定定位：*****注意:对于脱标的元素宽不会在和父元素一行宽，我们需要设置宽度或者有内容撑出来宽度 透明属性值：transparent Html5新增的标签：​ audio: 音频标签： ​ 属性值： controls控件，autoplay自动播放，loop循环播放可以设置循环次数 Html5中新增的标签属性：​ placeholder=””​ multiple​ required​ autofocus 自动聚焦，文本光标停留位置 Html5中新增的input属性的值：​ 搜索：type=”search” 移动端下面的键盘ENTER自动变成搜索​ 电话：type=”tel” 移动端下的键盘自动切换数字键盘​ 日期：type=”datetime”移动端显示日期滑动条 文字阴影属性：​ text-shadow:1px 2px 5px color； text-shadow:水平阴影，垂直阴影，阴影模糊度，阴影颜色​ 开发项目流程：​ 1.项目立项：产品的需求文档（产品经理）​ 2.产品原型图——UI针对其出设计稿​ ***我们这边会做项目结构搭建——开会：技术选型（确定项目中使用的主要技术点——项目的规范文档（例如：京东：jd_xxx）——项目任务分配——项目开发ing（多交流，多沟通）——测试（功能，代码）——上线——后期的维护，版本更新，迭代合资（外资企业）：​ 日资：​ 看着文档翻译​ 德资：​ 美资： 属性书写顺序：​ 1.布局定位属性：display / position / float / clear(建议display第一个写，毕竟关系到模式)​ 2.自身属性：​ 3.文本属性：​ 4.其他属性（CSS3）：content 引入外部样式顺序：兼容CSS——初始化CSS——公共CSS——当前页面CSS字体图标：一种字体类型（我们自己定义的）——主要针对于手机端 开发：让设计做一些这样的图标——前端开发将这样的图标通过工具生成一种字体——打包上传到服务器——下载现成字体图标网址：www.iconfont.cn 文本修饰：​ 水平位置设置： text-align： left center right 对于独占一行的元素，设置文本水平居中，将text-align属性设置给元素本身就行了​ 如果是一行可以显示多个的这样的元素，我们要设置文本水平居中，我们需要给这个元素的父元素设置text-align属性​ 垂直位置设置：行高 line-height: 300px; 当盒子高度等于行高的时候，盒子中的单行文本垂直居中​ 文本首行缩进： text-indent：​ 注意：em单位 相对长度单位。 相对的元素本身的字体大小​ 文本修饰线： text-decoration： none 去除默认的修饰线​ underline下划线 overline上划线 line-through中划线 修改定位元素的层级：​ 所有元素默认层级属性值是1​ z-index: 1;​ **1.层级只对非静态定位有效​ 2.如果都是非静态定位的元素，后面的元素的层级默认比前面的元素的层级高 做项目遵循单一性原则：​ 在项目中尽可能的让每一块的功能单一——为了程序的可拓展性和代码的复用； 在页面title处引入icon图标：icon图标:网页head里的title显示 截取网页的icon图标，在网页后面加上/favicon.ico 引入页面的title部分的icon图标： &lt;link rel=”shortcut icon” href=”./favicon.ico” 在线制作icon图标​ 网址：比特虫 www.bitbug.net 结构伪类选择器：​ ：nth-child（n）***n=odd基数 n=even偶数​ ：nth-child（-n+几） 前几个​ ：nth-last-child（-n+几）后几个 outline: 外边框线不占位置，商品hover时显示边框可用 p标签里面不能嵌套ul标签 怎么修改placeholder默认颜色？ input::placeholder{/\\ 去掉私有前缀，谷歌和火狐有效；IE和edge无效 */* color: orchid;opacity:1;font-size: 15px;} ****盒子模型分为几个部分：3个！！！！！！！外边距不算！！！ 1.旧的盒子模型——计算宽度 width = 边框 + 内边距 + 内容 2.新的盒子模型—— box-sizing:border-box;(内减模式) 改变边框和改变内边距都不会导致盒子的宽度发生改变 width = 边框 + 内边距 + 内容 内减模式——内容减少的模式 以后再写任何页面除非是ie8及以下， 都可以使用内减模式 * ***** { margin: 0; padding: 0; box-sizing: border-box; 快捷写法： bz } 3种改变元素坐标的技术有哪些：​ 1.定位——绝对定位——top left​ 2.外边距——margin​ 3.平移——translate*****区别：​ 1.margin和定位加的长度单位——px​ 2.margin和定位也可以用百分比单位——%​ 百分比相对于父元素的宽度计算​ 3.平移也可以用百分比单位——%​ 百分比相对于自身的宽度或者高度*****后期盒子中的盒子水平垂直居中显示可以用定位position的%和平移translate的%一起用来实现**布局的时候，属性的使用顺序：​ 1.大的布局，先用定位​ 2.微调的效果：（1）margin——挤压相邻的元素​ （2）平移——类似绝对定位，覆盖，不会挤压！不是脱标（导致父元素没有高度）。​ 3.平移的百分比单位——相对于自身的高度和宽度 容器开启3D效果： transform-style: preserve-3d; less:CSS预处理器注释： // 不会被编译到CSS /* 会被编译到CSS*/ ***换行和flex属性的有冲突，会重叠，如果想要前面的元素平分行，后面的元素换行显示，则可以用换行和width：百分比；来实现！！ 盒子透明度设置：opacity：.5；取值再0~1 合理设置版心宽度，使页面无论使用端的分辨率都不会出现横向滚动条 1.块级元素宽度默认100%； 2.当屏幕大于540px，块级元素的宽度最大就是540px； 3。当屏幕的宽小于540px时，块级元素的宽度=屏幕的宽度***max-width：540px； 在不同像素比的手机端显示不同倍清晰的图片： 1.市场上的手机全部都是高清晰度的手机2倍3倍 2.主流做法 美工只做一张高清的图片—2倍或者3倍 3.写代码的时候 直接使用这一张图片就OK，不用再去处理 不同屏幕不同的图片 弹性头部： flex:1，将父项除去其他定宽高的子顶剩余的宽度分成一等份，这一部分子项则可以随屏幕的变化来实现伸缩。 伪元素： 1.伪元素可以用来清除浮动：after 2.伪元素经常会被用来做字体图标或者小精灵图*****单标签不能加伪元素！！！ 设置a标签的样式可以继承父元素的样式： a{ color：inherit； } 颜色渐变：​ div{​ width: 200px;​ height: 200px;​ margin: 100px auto;​ border: 1px solid #000;​ /* ​ 1 渐变不是一种单纯的颜色 而是多种颜色​ 2 渐变要添加给标签的 background-image​ 3 线性渐变 radial 径向渐变 重复线性渐变 重复径向渐变​ / ​ / background-image: linear-gradient(to right,red,pink,yellow ,black,blue); / ​ / background-image: linear-gradient(0deg,red 20%,pink 50%,yellow ,black,blue); / ​ / background-image: radial-gradient(red,black); / ​ / background-image: repeating-linear-gradient() / ​ / css.chm 网上 都ok */​ } 两列的等高实现的方式：修改display属性值 1.父盒子 display：table-row； 2.子元素 display：table-cell；（cell单元格的意思） 清除浮动的写法2：​ display：table；​ content：“”； 相对长度单位： rem​ css3才有，相对于页面根标签html的字体大小 rem和px和em的区别 1.px绝对长度单位大小是固定 2.em是相对长度单位，相对于自身的字体大小 3.rem相对长度单位html标签的字体大小字体知识： 谷歌浏览器中默认字体大小是 16px； 谷歌浏览器中默认最小字体是 12px； 在普通的标签中字体大小会被继承——除h1~h6标签外 浮动：float​ float-left：给了元素此属性值，则若该元素的前面有向左浮动的元素则换行​ float-right：若该元素的前面的元素有向右浮动的元素则换行不关后面的元素事​ float-both***浮动BUG：1.给元素添加clear：both；清除浮动，强制换行；2.增加间距填补空间 内减模式：​ box-sizing: border-box;“给div 自己加宽度和高度，自己再增大padding的时候，不会增大盒子大小” js里面的事件派发： – js里面触发addEventListener注册的事件 – 使用的技术：事件派发 作用：让某个元素的事件被手动的触发 事件派发的三步:​ 1.先new一个事件对象 – 鼠标事件对象​ var 事件对象=new Event（事件的大类型） – 鼠标事件的大类型—MouseEvent​ var event=new Event(‘MouseEvents’)；​ 2.初始化事件对象​ 事件对象.initEvent（具体的事件类型，是否可以冒泡，是否可以阻止冒泡）​ event.initEvent(事件类型，是否冒泡，是否可以阻止)；​ 3.把事件对象派发除去​ 事件源.dispatchEvent（事件对象）；​ box.dispatchEvent（event）；​ ​","categories":[{"name":"基础","slug":"基础","permalink":"http://wang-zhibiao.github.io/categories/基础/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"function","slug":"function","permalink":"http://wang-zhibiao.github.io/tags/function/"}],"keywords":[{"name":"基础","slug":"基础","permalink":"http://wang-zhibiao.github.io/categories/基础/"}]},{"title":"JavaScript的变量以及数据类型","slug":"变量和js类型的理解","date":"2019-06-09T01:24:56.000Z","updated":"2019-08-03T11:41:48.344Z","comments":true,"path":"2019/06/09/变量和js类型的理解/","link":"","permalink":"http://wang-zhibiao.github.io/2019/06/09/变量和js类型的理解/","excerpt":"","text":"一、JavaScript数据类型ECMAScript标准规定了7种数据类型，其把这7种数据类型又分为两种：原始类型和对象类型。 原始类型 Null：只包含一个值：null Undefined：只包含一个值：undefined Boolean：包含两个值：true和false Number：整数或浮点数，还有一些特殊值（-Infinity、+Infinity、NaN） String：一串表示文本值的字符序列 Symbol：一种实例是唯一且不可改变的数据类型 (在es10中加入了第七种原始类型BigInt，现已被最新Chrome支持) 对象类型 Object：自己分一类丝毫不过分，除了常用的Object，Array、Function等都属于特殊的对象 区分原始类型和对象类型 - 不可变性 原始类型存放在栈空间中，而复杂类型存放在堆空间中 栈内存： 存储的值大小固定 空间较小 可以直接操作其保存的变量，运行效率高 由系统自动分配存储空间 堆内存： 存储的值大小不定，可动态调整 空间较大，运行效率低 无法直接操作其内部存储，使用引用地址读取 通过代码进行分配空间 字符串 具备不可变性不管是字符串的裁切splice 还是 toLowerCase 都是在原有的基础上产生新的字符串 JavaScript中的原始类型的值被直接存储在栈中，在变量定义时，栈就为其分配好了内存空间。 由于栈中的内存空间的大小是固定的，那么注定了存储在栈中的变量就是不可变的 对象 具备可变性引用类型的值实际存储在堆内存中，它在栈中只存储了一个固定长度的地址，这个地址指向堆内存中的值。 数组 是一个复杂（引用）类型 通过一些api可以改变数组 pop() 删除数组最后一个元素，如果数组为空，则不改变数组，返回undefined，改变原数组，返回被删除的元素 push()向数组末尾添加一个或多个元素，改变原数组，返回新数组的长度 shift()把数组的第一个元素删除，若空数组，不进行任何操作，返回undefined,改变原数组，返回第一个元素的值 unshift()向数组的开头添加一个或多个元素，改变原数组，返回新数组的长度 reverse()颠倒数组中元素的顺序，改变原数组，返回该数组 sort()对数组元素进行排序，改变原数组，返回该数组 splice()从数组中添加/删除项目，改变原数组，返回被删除的元素 当我们进行复制时两者有着本质的区别 这里涉及到浅拷贝和深拷贝—本质是复制时是否改变复制的对象的数值或属性或方法 原始类型12345var name = 'wang';var newName = name;newName = 'Mr.wang';console.log(name) // =&gt;wangconsole.log(newName) // =&gt;Mr.wang 内存中有一个变量name，值为wang。我们从变量name复制出一个变量newName，此时在内存中创建了一个块新的空间用于存储wang，虽然两者值是相同的，但是两者指向的内存空间完全不同，这两个变量参与任何操作都互不影响。 引用类型12345var obj = &#123;name:'wang'&#125;;var newObj = obj;newObj.name = 'Mr.wang';console.log(obj.name) //=&gt; Mr.wangconsole.log(newObj.name)//=&gt; Mr.wang 当我们复制引用类型的变量时，实际上复制的是栈中存储的地址，所以复制出来的newObj实际上和obj指向的堆中同一个对象。因此，我们改变其中任何一个变量的值，另一个变量都会受到影响，这就是为什么会有深拷贝和浅拷贝的原因。 原始类型和引用类型的比较原始类型，比较时会直接比较它们的值，如果值相等，即返回true。 引用类型，比较时会比较它们的引用地址，虽然两个变量在堆中存储的对象具有的属性值都是相等的，但是它们被存储在了不同的存储空间，因此比较值为false。 区分null和undefinednull 表示被赋值过的对象，刻意把一个对象赋值为null，故意表示其为空，不应有值。 所以对象的某个属性值为null是正常的，null转换为数值时值为0。 undefined 表示“缺少值”，即此处应有一个值，但还没有定义， 如果一个对象的某个属性值为undefined，这是不正常的，如obj.name=undefined，我们不应该这样写，应该直接delete obj.name。 undefined转为数值时为NaN(非数字值的特殊值) JavaScript是一门动态类型语言，成员除了表示存在的空值外，还有可能根本就不存在（因为存不存在只在运行期才知道），这就是undefined的意义所在。对于JAVA这种强类型语言，如果有&quot;undefined&quot;这种情况，就会直接编译失败，所以在它不需要一个这样的类型。 你想不到的0.1+0.2≠0.3 本质是：由于数字在js中的计算是先转换为二进制在进行计算的，然后以十进制输出 12345678910111213141516171819202122232425262728function judgeFloat(n, m) &#123; const binaryN = n.toString(2); const binaryM = m.toString(2); console.log(`$&#123;n&#125;的二进制是 $&#123;binaryN&#125;`); console.log(`$&#123;m&#125;的二进制是 $&#123;binaryM&#125;`); const MN = m + n; const accuracyMN = (m * 100 + n * 100) / 100; const binaryMN = MN.toString(2); const accuracyBinaryMN = accuracyMN.toString(2); console.log(`$&#123;n&#125;+$&#123;m&#125;的二进制是$&#123;binaryMN&#125;`); console.log(`$&#123;accuracyMN&#125;的二进制是 $&#123;accuracyBinaryMN&#125;`); console.log(`$&#123;n&#125;+$&#123;m&#125;的二进制再转成十进制是$&#123;to10(binaryMN)&#125;`); console.log(`$&#123;accuracyMN&#125;的二进制是再转成十进制是$&#123;to10(accuracyBinaryMN)&#125;`); console.log(`$&#123;n&#125;+$&#123;m&#125;在js中计算是$&#123;(to10(binaryMN) === to10(accuracyBinaryMN)) ? '' : '不'&#125;准确的`); &#125; function to10(n) &#123; const pre = (n.split('.')[0] - 0).toString(2); const arr = n.split('.')[1].split(''); let i = 0; let result = 0; while (i &lt; arr.length) &#123; result += arr[i] * Math.pow(2, -(i + 1)); i++; &#125; return result; &#125; judgeFloat(0.1, 0.2); judgeFloat(0.6, 0.7); 计算机中所有的数据都是以二进制存储的，所以在计算时计算机要把数据先转换成二进制进行计算，然后在把计算结果转换成十进制。 由上面的代码不难看出，在计算0.1+0.2时，二进制计算发生了精度丢失，导致再转换成十进制后和预计的结果不符。 隐式转换 if语句和逻辑语句在if语句和逻辑语句中，如果只有单个变量，会先将变量转换为Boolean值，只有下面几种情况会转换成false，其余被转换成true： 123456nullundefined&apos;&apos;NaN0false 各种运数学算符我们在对各种非Number类型运用数学运算符(- * /)时，会先将非Number类型转换为Number类型; 12341 - true // 01 - null // 11 * undefined // NaN2 * [&apos;5&apos;] // 10 注意+是个例外，执行+操作符时： 1.当一侧为String类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。 2.当一侧为Number类型，另一侧为原始类型，则将原始类型转换为Number类型。 3.当一侧为Number类型，另一侧为引用类型，将引用类型和Number类型转换成字符串后拼接。 1234123 + &apos;123&apos; // 123123 （规则1）123 + null // 123 （规则2）123 + true // 124 （规则2）123 + &#123;&#125; // 123[object Object] （规则3） == 运算符使用==时，若两侧类型相同，则比较结果和===相同，否则会发生隐式转换，使用==时发生的转换可以分为几种不同的情况（只考虑两侧类型不同）： 1.NaN NaN和其他任何类型比较永远返回false(包括和他自己)。 1NaN == NaN // false 2.Boolean Boolean和其他任何类型比较，Boolean首先被转换为Number类型。 1234true == 1 // true true == &apos;2&apos; // falsetrue == [&apos;1&apos;] // truetrue == [&apos;2&apos;] // false 这里注意一个可能会弄混的点：undefined、null和Boolean比较，虽然undefined、null和false都很容易被想象成假值，但是他们比较结果是false，原因是false首先被转换成0： 12undefined == false // falsenull == false // false 3.String和Number String和Number比较，先将String转换为Number类型。 12123 == &apos;123&apos; // true&apos;&apos; == 0 // true 4.null和undefined null == undefined比较结果是true，除此之外，null、undefined和其他任何结果的比较值都为false。 1234567null == undefined // truenull == &apos;&apos; // falsenull == 0 // falsenull == false // falseundefined == &apos;&apos; // falseundefined == 0 // falseundefined == false // false 5.原始类型和引用类型 当原始类型和引用类型做比较时，对象类型会依照ToPrimitive规则转换为原始类型: 12&apos;[object Object]&apos; == &#123;&#125; // true&apos;1,2,3&apos; == [1, 2, 3] // true 来看看下面这个比较： 1[] == ![] // true !的优先级高于==，![]首先会被转换为false，然后根据上面第三点，false转换成Number类型0，左侧[]转换为0，两侧比较相等。 12[null] == false // true[undefined] == false // true 根据数组的ToPrimitive规则，数组元素为null或undefined时，该元素被当做空字符串处理，所以[null]、[undefined]都会被转换为0。 原型链的规则 1.所有引用类型都具有对象特性，即可以自由扩展属性 2.所有引用类型都具有一个proto（隐式原型）属性，是一个普通对象 3.所有的函数都具有prototype（显式原型）属性，也是一个普通对象 4.所有引用类型proto值指向它构造函数的prototype 5.当试图得到一个对象的属性时，如果变量本身没有这个属性，则会去他的proto中去找 toString上面我们在拆箱操作中提到了toString函数，我们可以调用它实现从引用类型的转换。 每一个引用类型都有toString方法，默认情况下，toString()方法被每个Object对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 &quot;[object type]&quot;，其中type是对象的类型。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"}],"keywords":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}]},{"title":"this指向，call，apply，bind","slug":"this指向，apply，call,bind","date":"2019-06-02T01:10:56.000Z","updated":"2019-08-31T13:19:12.391Z","comments":true,"path":"2019/06/02/this指向，apply，call,bind/","link":"","permalink":"http://wang-zhibiao.github.io/2019/06/02/this指向，apply，call,bind/","excerpt":"","text":"如何理解This指向 this ：谁调用它 他就指向谁。（this 永远指向最后调用它的那个对象） 1.在浏览器：如果this是在函数外部则this指向window 2.在node环境：如果this在函数外部则指向{} ​ 如果有new绑定 则指向这个new的实例对象 ​ 函数是否通过 call,apply 调用，或者使用了 bind 绑定，如果是，那么this绑定的就是指定的对象【归结为显式绑定】。 ​ 这里同样需要注意一种特殊情况，如果 call,apply 或者 bind 传入的第一个参数值是 undefined 或者 null，严格模式下 this 的值为传入的值 null /undefined。非严格模式下，实际应用的默认绑定规则，this 指向全局对象(node环境为global，浏览器环境为window) 隐式绑定，函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的隐式调用为: xxx.fn() 箭头函数的情况：箭头函数没有自己的this，继承外层上下文绑定的this。 看看具体例子12345678var name = \"windowsName\";var a = &#123; // name: \"Cherry\", fn : function () &#123; console.log(this.name); //==》undefined &#125;&#125;window.a.fn(); 说明：这里有通过window调用a ，最后调用的是谁的呢？？ 其实是a最后调用了this=》》a里面没有那么这个属性，即使外面的window有name也不会调用==》》就像我们对于变量的调用一样，，函数内部的变量不可以使用其他的函数内部的变量，a和window是两个函数 即使window包括a但是调用的时候是使用this 指向了a 也就是标明 我一定要使用a里面的属性 再看看这个坑12345678910var name = \"windowsName\";var a = &#123; name : null, // name: \"Cherry\", fn : function () &#123; console.log(this.name); //==&gt; windowsName &#125;&#125;var f = a.fn;f(); 为什么和之前的调用差不多 this却是指向window 由上往下看，var f 的时候根本没有调用a.fn; 最后fn（） 是使用了window调用的 所以指向了外面的name this 的指向并不是在创建的时候就可以确定的 永远指向最后调用的它call和apply以及bind都与this有关 因为他们改变了this的指向先说说this改变的几种方法1.当你new一个对象时 this就指向创建的实例12let date = new Date()// 我们可以使用data创建时间 这是因为data的this在赋值当中已经指向实例new Date（） 12345new 的实现原理:创建一个空对象，构造函数中的this指向这个空对象这个新对象被执行 [[原型]] 连接执行构造函数方法，属性和方法被添加到this引用的对象中如果构造函数中没有返回其它对象，那么返回this，即创建的这个的新对象，否则，返回构造函数中返回的对象。 2.使用闭包解决，有两层函数可以再第一层使用_this= this改变指向123456789101112131415//在这里使用的是闭包的原理 也可以改变this的指向function()&#123; let _this = this function()&#123; console.log(_this) &#125;&#125;//可执行function fn() &#123; let _this = this return function () &#123; console.log(_this) &#125;() &#125; fn() 3.es6的箭头函数 指向外部的this，（）=&gt;{}箭头函数的 this 始终指向函数定义时的 this，而非执行时。 4.call apply bind call 123456789101112let Object = &#123; name: 'Mr.wang', first() &#123; console.log(this.name) &#125;, second() &#123; setTimeout(function () &#123; console.log(this.name); &#125;.call(Object)); &#125; &#125; Object.second() //==&gt; 输出为 Mr.wang apply 123456789101112let Object = &#123; name: 'Mr.wang', first() &#123; console.log(this.name) &#125;, second() &#123; setTimeout(function () &#123; console.log(this.name); &#125;.apply(Object)); &#125; &#125; Object.second() //==&gt; 输出为 Mr.wang bind 123456789101112let Object = &#123; name: 'Mr.wang', first() &#123; console.log(this.name) &#125;, second() &#123; setTimeout(function () &#123; console.log(this.name); &#125;.bind(Object)); &#125; &#125; Object.second() //==&gt; 输出为 Mr.wang apply 和 call 的区别他们之间的区别只是传入参数的区别 appll(this,[a,b,c])call(this,a,b,c)bind与apply和call有着大的区别 bind会生成新的函数，需要调用再次调用 setTimeout会自动调用","categories":[{"name":"Es6语法","slug":"Es6语法","permalink":"http://wang-zhibiao.github.io/categories/Es6语法/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"function","slug":"function","permalink":"http://wang-zhibiao.github.io/tags/function/"}],"keywords":[{"name":"Es6语法","slug":"Es6语法","permalink":"http://wang-zhibiao.github.io/categories/Es6语法/"}]},{"title":"Es6解构赋值","slug":"Es6变量的解构赋值","date":"2019-05-11T02:10:56.000Z","updated":"2019-07-14T01:28:26.270Z","comments":true,"path":"2019/05/11/Es6变量的解构赋值/","link":"","permalink":"http://wang-zhibiao.github.io/2019/05/11/Es6变量的解构赋值/","excerpt":"","text":"变量的解构赋值 数组的解构赋值 对象的解构赋值 字符串的解构赋值 数值和布尔值的解构赋值 函数参数的解构赋值 1数组的解构赋值12345let [a,b,c] = [1,2,3] // 为abc各自an规律赋值let [a,[b,[c]]] = [1,[2,[3]]] //如果为嵌套数组，可以用一样的嵌套数组赋值let [x,y] = [1,2,3] //如果赋值两边长度不一，，则部分赋值 部分未赋值为uddefinedlet [...arr] = [1,2,3] //扩展运算符可以直接把所有的数字赋值给arr arr=[1,2,3]let [first,...arrAll]=[1,2,3,4] //当第一个first赋值以后，其他的数字都会给arrAll包含 first =1 arrAll=[2,3,4] 结构赋值为何左右两边为数组？正常的赋值是一个一个赋值，解构赋值是吧需要赋值的解析重构，循环赋值 通过数组可遍历的特性就可以解构 解构赋值的默认值123let [a=11] = [] //a输出为11 在赋值之前就已经赋值 解构只是再次赋值 不会冲突 注意点 [] 数组里面无任何值，但是有undefined 所以才会解构成功 ，否则部分赋值也不会实现，以下情况请注意 null与undefined有本质的区别，两者不等，所以赋值时可以成功为null，解构赋值也严格遵守严格运算符（===）let [x = 1] = [undefined];//x = 1let [x = 1] = [null]; //x = null 2对象的解构赋值12345678910let &#123;a&#125;=&#123;a:'good',b:'nice'&#125; //a = good 对象里不同于数组，它是无序的集合 所以赋值要用见来赋值 两者的键要相同//如果没有对应的键则会返回undefined//对象的解构赋值可以对内置对象进行赋值let&#123;log,sin,cos&#125; = Mathlet &#123;log&#125; = console//当取得所对应的对象的方法时，可以直接调用log('hello word') //控制台输出hello wordsin(90) //输出为 1let &#123;a，&#123;b&#125;&#125; = &#123;a:11,&#123;b:22&#125;&#125; //对象一样支持嵌套赋值var &#123;x = 3&#125; = &#123;&#125;; //也支持默认值 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。 注意点12345678let x;&#123;x&#125; = &#123;x: 1&#125;; //已经声明的变量再解构赋值会报错 ，&#123;x&#125; 会被解析为代码块//解决方法(&#123;x&#125;=&#123;x:1&#125;); //括号包裹//解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。(&#123;&#125;=&#123;a:dd&#125;) //语法可行但毫无意义//数组也是一种特殊的对象 他是用索引值当键let &#123;0:first&#125; = [1,2,3] 3字符串的解构赋值12let [a,b,c,d,e] = 'hello' // a=h,b=e,c=l,d=l,e=o //这是将字符串转化为数组遍历在赋值let &#123;length : len&#125; = 'hello'; //len = 5 // 数组都有length这个键 表示长度 4数值和布尔值的解构赋值12345678let &#123;toString: s&#125; = 123;s === Number.prototype.toString // true//数字和布尔类型会转化为对象 所以在s的原型链与赋值的原型链相等 前面的键 toString 是转化为字符串的方法let &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true// 由于ndefined和null无法转为对象 所以不能进行赋值let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 5函数参数的解构赋值函数的解构赋值我们经常使用 当我们进行传参时 就会进行解构赋值 1234function fn(a,b)&#123; return a+b&#125;fn(2,3) //a和b都会在函数调用时传参解构赋值 函数参数的默认值 12345678function fn(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;fn(&#123;x: 3, y: 8&#125;); // [3, 8] fn(&#123;x: 3&#125;); // [3, 0]fn(&#123;&#125;); // [0, 0]fn(); // [0, 0]//如果有默认值,参数没有就使用默认值 另一种函数的默认值 123456789function fn(&#123;x, y&#125; = &#123;x:0,y:0&#125;) &#123; return [x, y];&#125;fn(&#123;x: 3, y: 8&#125;); // [3, 8] fn(&#123;x: 3&#125;); // [3, undefined]fn(&#123;&#125;); // [undefined, undefined]fn(); // [0, 0]//如果有默认值,参数没有就使用默认值//这种写法使用了对象的键值对赋值，不是之前的值传递，所以 当参数为&#123;&#125;时 传递的是undefined 圆括号圆括号是为了解决赋值时解析的无法辨别，但是要注意使用时机，否则会报错","categories":[{"name":"基础","slug":"基础","permalink":"http://wang-zhibiao.github.io/categories/基础/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"Es6","slug":"Es6","permalink":"http://wang-zhibiao.github.io/tags/Es6/"}],"keywords":[{"name":"基础","slug":"基础","permalink":"http://wang-zhibiao.github.io/categories/基础/"}]},{"title":"let var const三种定义方式及闭包","slug":"var let const三种定义方式及闭包","date":"2019-05-09T16:10:56.000Z","updated":"2019-07-14T01:27:55.718Z","comments":true,"path":"2019/05/10/var let const三种定义方式及闭包/","link":"","permalink":"http://wang-zhibiao.github.io/2019/05/10/var let const三种定义方式及闭包/","excerpt":"","text":"let var const 之间的区别varvar的作用域是根据函数作用域的， 他在函数内起作用 这里就引用到闭包和作用域链 12345678function out()&#123; var a = 000; //=&gt; 这个a的作用域作用在out内 而info函数在out函数内 所以可以调用 b=222 //=&gt; 报错err 因为b的作用域在info函数内 包裹他的out函数不可以调用它function info()&#123; var b=999; a= 111; &#125;&#125; var 的变量提升 12345678function ()&#123; var a=10; &#125;//变量提升 就是var定义的变量会在先声明再赋值 提升到函数顶部function()&#123; var a; a=10;&#125; letlet的作用域的块级作用域，不会变量提升 可以理解为在某块范围内作用 与var 的函数作用域不同在于 let的作用域会形成闭包 12345678910111213for (var i = 0; i &lt; 3; i++) &#123; setTimeout(function () &#123; console.log(i); &#125;, 1000)&#125;//输出 3 3 3for (let i = 0; i &lt; 3; i++) &#123; setTimeout(function () &#123; console.log(i); &#125;, 1000)&#125;//输出 0 1 2 12var会在全局声明 而setTimeout 是一个定时器 也是异步回调 会在同步执行完毕再执行异步 所以当for循环完毕 i=3时调用三次定时器 let 的作用范围会在for循环内 每循环一次 i会形成一次闭包 i会被setTimeout调用 constconst代表一个值的常量索引，常量的值在垃圾回收前永远不能改变，所以需要谨慎使用。 cosnt定义的值不能被改变 否则会报错 12Uncaught TypeError: Assignment to constant variable.未捕获的类型错误:赋值给常量变量。 闭包外部可以访问内部的私有变量 可以返回携带状态的函数，并且状态隐藏 可以做到变量的私有 123456function f1()&#123; var n=999; function f2()&#123; alert(n); // 999 &#125;&#125; 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！ 123456789function f1()&#123; var n=999; function f2()&#123; alert(n); &#125;return f2;&#125;var result=f1();result(); // 999 闭包就是能够读取其他函数内部变量的函数 要形成闭包 必须两层function函数作用域 123456789101112function f1()&#123; var n=999; Add=function()&#123;n+=1&#125; function f2()&#123; console.log(n)&#125;return f2;&#125;var result=f1();result(); // 999Add();result(); // 1000 这里形成闭包后，f1的局部变量n一直保存在内存中，并没有因为f1的重复调用而清除 原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 缺点由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 12345678910var name = \"The Window\";var object = &#123; name: \"My Object\", getNameFunc: function () &#123; return function () &#123; return this.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); 经典闭包题 个人理解 object.getNameFunc() 执行到这一步时 调用object内的函数 返回一个function（）{return this.name} 这时候 name还是My Object 当再次执行时object.getNameFunc()() 调用了外部的name 输出为The Window","categories":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"function","slug":"function","permalink":"http://wang-zhibiao.github.io/tags/function/"}],"keywords":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}]},{"title":"隐藏元素的方法","slug":"隐藏元素的方法","date":"2019-03-21T16:10:56.000Z","updated":"2019-07-13T02:29:27.392Z","comments":true,"path":"2019/03/22/隐藏元素的方法/","link":"","permalink":"http://wang-zhibiao.github.io/2019/03/22/隐藏元素的方法/","excerpt":"","text":"隐藏类型 屏幕并不是唯一的输出机制，比如说屏幕上看不见的元素（隐藏的元素），其中一些依然能够被读屏软件阅读出来（因为读屏软件依赖于可访问性树来阐述）。为了消除它们之间的歧义，我们将其归为三大类： 完全隐藏：元素从DOM树中消失，不占据空间。 视觉上的隐藏：屏幕中不可见，占据空间。 语义上的隐藏：读屏软件不可读，但正常占据空间。 完全隐藏 1.display 属性1display: none; 2.hidden 属性 HTML5 新增属性，相当于 display: none 12&lt;div hidden&gt;&lt;/div&gt; 视觉上的隐藏,在页面中还存在 3.利用 position 和 盒模型 将元素移出可视区范围 设置 posoition 为 absolute 或 fixed，\b通过设置 top、left 等值，将其移出可视区域。 12position:absolute;left: -999px; 设置 position 为 relative，通过设置 top、left 等值，将其移出可视区域。 12position: relative;left: -999px; 设置 margin 值，将其移出可视区域范围（可视区域占位）。 12margin-left: -99999px;height: 0; 3.利用 transfrom 缩放 12transform: scale(0);height: 0; 移动 translateX, translateY 12transform: translateX(-99999px);height: 0 旋转 rotate 1transform: rotateY(90deg) //直角在界面上形成线性视觉屏蔽 4.设置其大小为0 宽高为0，字体大小为0： 123height: 0;width: 0;font-size: 0; 宽高为0，超出隐藏: 123height: 0;width: 0;overflow: hidden; 5.设置透明度为01opacity: 0; 6.visibility属性1visibility: hidden; 7.层级覆盖，z-index 属性12position: relative;z-index: -999; 再设置一个层级较高的元素覆盖在此元素上。8.clip-path 裁剪1clip-path: polygon(0 0, 0 0, 0 0, 0 0); 语义上的隐藏","categories":[{"name":"基础","slug":"基础","permalink":"http://wang-zhibiao.github.io/categories/基础/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"function","slug":"function","permalink":"http://wang-zhibiao.github.io/tags/function/"}],"keywords":[{"name":"基础","slug":"基础","permalink":"http://wang-zhibiao.github.io/categories/基础/"}]},{"title":"简单轮播图原理解析","slug":"简单轮播图原理解析","date":"2019-03-11T16:10:56.000Z","updated":"2019-07-28T01:12:20.044Z","comments":true,"path":"2019/03/12/简单轮播图原理解析/","link":"","permalink":"http://wang-zhibiao.github.io/2019/03/12/简单轮播图原理解析/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212/** * 动画函数 animate 版本1 * @param element 动画元素 * @param target 动画目标值 * @param step 动画步长(可选参数) */function animate(element, target, step) &#123; step = step || 10; var current = element.offsetLeft; clearInterval(element.timer); element.timer = setInterval(function () &#123; current += current &lt; target ? step : -step; element.style.left = current + 'px'; if (Math.abs(target - current) &lt;= step) &#123; clearInterval(element.timer); element.style.left = target + 'px'; &#125; &#125;, 24);&#125;/** * 动画函数 animate 版本2 * @param element 动画元素 * @param target 动画目标值 */function animate_v2(element, target) &#123; clearInterval(element.timer); element.timer = setInterval(function () &#123; var current = element.offsetLeft; var step = (target - current) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); current += step; element.style.left = current + 'px'; if (target === current) &#123; clearInterval(element.timer); &#125; &#125;, 240);&#125;/** * 动画函数 animate 版本3 宽度动画 * @param element 动画元素 * @param target 动画目标值 */function animate_v3(element, target) &#123; clearInterval(element.timer); element.timer = setInterval(function () &#123; /* 改变 v3.1 →: 获取盒子宽度 */ var current = element.offsetWidth; var step = (target - current) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); current += step; /* 改变 v3.2 →: 设置宽度样式 */ element.style.width = current + 'px'; if (target === current) &#123; clearInterval(element.timer); &#125; &#125;, 24);&#125;/** * 动画函数 animate_v4 任意单位为px的属性能发生变化 * @param element 动画元素 * @param attr 动画属性 * @param target 动画目标 *//* 改变 v4.1 →: 多了一个 attr 参数代表属性 */function animate_v4(element, attr, target) &#123; clearInterval(element.timer); element.timer = setInterval(function () &#123; /* 改变 v4.2 →: 根据传进来的属性获取当前样式值 */ var current = parseFloat(getComputedStyle(element)[attr]); var step = (target - current) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); current += step; /* 改变 v4.3 →: 根据属性设置样式 */ element.style[attr] = current + 'px'; if (target === current) &#123; clearInterval(element.timer); &#125; &#125;, 24);&#125;/* 改变 v5.1 →: 参数变成样式对象 styleObj */function animate_v5(element, styleObj) &#123; clearInterval(element.timer); element.timer = setInterval(function () &#123; /* 1. 立 flag，假设要清除 */ var flag = true; /* 改变 v5.2 →: 遍历样式对象 */ for (var attr in styleObj) &#123; /* 改变 v5.3 →: 根据属性名，获取目标值 */ var target = styleObj[attr]; var current = parseFloat(getComputedStyle(element)[attr]); var step = (target - current) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); current += step; element.style[attr] = current + 'px'; /* 2. 改 flag，假设不成立，修改成 假 */ if (target !== current) &#123; flag = false; &#125; &#125; /* 3. 用 flag，循环结束后判断 flag 的值是真还是假 */ if (flag) &#123; clearInterval(element.timer); &#125; &#125;, 24);&#125;/** * v8 层级不做动画，透明度，px 有动画效果 * @param element * @param styleObj */function animate_v8(element, styleObj) &#123; clearInterval(element.timer); element.timer = setInterval(function () &#123; var flag = true; for (var attr in styleObj) &#123; if (attr === 'zIndex') &#123; var target = styleObj[attr]; element.style[attr] = target; &#125; else if (attr === 'opacity') &#123; /* v6.1 在数据的源头，把&lt;目标值&gt;和&lt;当前值&gt;乘 100 处理成&lt;整数&gt; */ var target = 100 * styleObj[attr]; var current = 100 * parseFloat(getComputedStyle(element)[attr]); var step = (target - current) / 10; /* 取整为什么会出问题？数据的源头是小数，直接处理数据源头 */ step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); current += step; /* v6.2 单位设置，不要 px 单位，除 100 变回小数 */ element.style[attr] = current / 100; if (target !== current) &#123; flag = false; &#125; &#125; else &#123; /* 改变 v5.3 →: 根据属性名，获取目标值 */ var target = styleObj[attr]; var current = parseFloat(getComputedStyle(element)[attr]); var step = (target - current) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); current += step; element.style[attr] = current + 'px'; /* 2. 改 flag，假设不成立，修改成 假 */ if (target !== current) &#123; flag = false; &#125; &#125; &#125; /* 3. 用 flag，循环结束后判断 flag 的值是真还是假 */ if (flag) &#123; clearInterval(element.timer); &#125; &#125;, 24);&#125;/* vX.1 开放新的参数：动画回调函数 fn */function animate_vX(element, styleObj, fn) &#123; clearInterval(element.timer); element.timer = setInterval(function () &#123; var flag = true; for (var attr in styleObj) &#123; if (attr === 'zIndex') &#123; var target = styleObj[attr]; element.style[attr] = target; &#125; else if (attr === 'opacity') &#123; /* v6.1 在数据的源头，把&lt;目标值&gt;和&lt;当前值&gt;乘 100 处理成&lt;整数&gt; */ var target = 100 * styleObj[attr]; var current = 100 * parseFloat(getComputedStyle(element)[attr]); var step = (target - current) / 10; /* 取整为什么会出问题？数据的源头是小数，直接处理数据源头 */ step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); current += step; /* v6.2 单位设置，不要 px 单位，除 100 变回小数 */ element.style[attr] = current / 100; if (target !== current) &#123; flag = false; &#125; &#125; else &#123; /* 改变 v5.3 →: 根据属性名，获取目标值 */ var target = styleObj[attr]; var current = parseFloat(getComputedStyle(element)[attr]); var step = (target - current) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); current += step; element.style[attr] = current + 'px'; /* 2. 改 flag，假设不成立，修改成 假 */ if (target !== current) &#123; flag = false; &#125; &#125; &#125; /* 3. 用 flag，循环结束后判断 flag 的值是真还是假 */ if (flag) &#123; clearInterval(element.timer); /* vX.2 动画结束后，调用函数 */ // if (fn) &#123; // fn(); // &#125; /** * || 找真，如果前面假，后面就是真，执行后面代码 * &amp;&amp; 找假，如果前面真，后面就是假，执行后面代码 **/ fn &amp;&amp; fn(); &#125; &#125;, 24);&#125;","categories":[{"name":"js封装","slug":"js封装","permalink":"http://wang-zhibiao.github.io/categories/js封装/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"analysis","slug":"analysis","permalink":"http://wang-zhibiao.github.io/tags/analysis/"}],"keywords":[{"name":"js封装","slug":"js封装","permalink":"http://wang-zhibiao.github.io/categories/js封装/"}]},{"title":"BFC协议","slug":"BFC协议","date":"2018-12-29T16:14:56.000Z","updated":"2019-07-14T01:29:51.152Z","comments":true,"path":"2018/12/30/BFC协议/","link":"","permalink":"http://wang-zhibiao.github.io/2018/12/30/BFC协议/","excerpt":"","text":"什么是BFC？BFC的布局规则是什么？如何创建BFC？查看解析 Box 是 CSS 布局的对象和基本单位，页面是由若干个Box组成的。 元素的类型 和 display 属性，决定了这个 Box 的类型。不同类型的 Box 会参与不同的 Formatting Context。 Formatting Context Formatting Context 是页面的一块渲染区域，并且有一套渲染规则，决定了其子元素将如何定位，以及和其它元素的关系和相互作用。 Formatting Context 有 BFC (Block formatting context)，IFC (Inline formatting context)，FFC (Flex formatting context) 和 GFC (Grid formatting context)。FFC 和 GFC 为 CC3 中新增。 BFC布局规则 BFC内，盒子依次垂直排列。 BFC内，两个盒子的垂直距离由 margin 属性决定。属于同一个BFC的两个相邻Box的margin会发生重叠【符合合并原则的margin合并后是使用大的margin】 BFC内，每个盒子的左外边缘接触内部盒子的左边缘（对于从右到左的格式，右边缘接触）。即使在存在浮动的情况下也是如此。除非创建新的BFC。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算。 如何创建BFC 根元素 浮动元素（float 属性不为 none） position 为 absolute 或 fixed overflow 不为 visible 的块元素 display 为 inline-block, table-cell, table-caption BFC 的应用 防止 margin 重叠 (同一个BFC内的两个两个相邻Box的 margin 会发生重叠，触发生成两个BFC，即不会重叠) 清除内部浮动 (创建一个新的 BFC，因为根据 BFC 的规则，计算 BFC 的高度时，浮动元素也参与计算) 自适应多栏布局 (BFC的区域不会与float box重叠。因此，可以触发生成一个新的BFC)","categories":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"function","slug":"function","permalink":"http://wang-zhibiao.github.io/tags/function/"}],"keywords":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}]},{"title":"盒子居中的方法","slug":"盒子居中的方法","date":"2018-12-20T11:50:59.000Z","updated":"2019-07-14T01:29:23.856Z","comments":true,"path":"2018/12/20/盒子居中的方法/","link":"","permalink":"http://wang-zhibiao.github.io/2018/12/20/盒子居中的方法/","excerpt":"","text":"HTML盒子居中的方法：1.宽度和高度已知的。思路： 父元素相对定位 子元素绝对定位 子元素{ left: 50%;top: 50%;margin-left: 减去子元素的宽度一半。margin-top: 减去子元素的高度一半； } 1234567891011121314151617&lt;style type=\"text/css\"&gt; #box&#123; width: 400px; height: 200px; position: relative; background: red; //方便观看 &#125; #box1&#123; width: 200px; height: 100px; position: absolute; top: 50%; left: 50%; margin-left: -100px; //定位后偏移值超过子元素的宽度一半需减去 margin-top: -50px; //定位后偏移值超过子元素的高度一半需减去 background: green; &#125; 2.宽度和高度可以随意改变思路： 父元素相对定位 子元素绝对定位 子元素{ left: 0;top: 0; bottom:0;right:0; margin:auto; } 1234567891011121314151617#box&#123; width: 800px; height: 400px; position: relative; background: red; &#125;#box1&#123; width: 100px; height: 50px; position: absolute;//四个方位定义盒子所在的位置 当所有为0&amp;&amp;margin:auto时,盒子居中 top: 0; right: 0; bottom: 0; left: 0; margin: auto; background: green; &#125; 3.flex布局123456789101112131415.box&#123; width: 400px; height: 200px; background: #f99; &#125; .box1&#123; width: 200px; height: 100px; background: green; &#125; .center&#123; display: flex; //开启弹性盒子 主轴侧轴交叉得到居中 justify-content: center;//实现水平居中 align-items: center;//实现垂直居中 &#125; 4.平移 定位+transform123456789101112131415.parent_box&#123; width: 400px; height: 200px; background: red; position: relative; &#125; .child_box&#123; width: 200px; height: 100px; background: green; position: absolute;//与第一个类似 但可以根据子元素的宽高自动居中 top: 50%; left: 50%; transform: translate( -50%,-50%);//平移相当于盒子margin(左,上)减半 &#125; 如何清除浮动清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。 父级添加overflow属性方法可以通过触发BFC的方式，可以实现清除浮动效果。 使用after伪元素清除浮动12345678.clearfix:after &#123; content: \"\"; display: block; height: 0; clear: both; visibility: hidden;&#125; .clearfix &#123;*zoom: 1;&#125; /* IE6、7 专有 */ 使用before和after双伪元素清除浮动12345678910.clearfix:before,.clearfix:after &#123; content:\"\"; display:table; /* 这句话可以触发BFC BFC可以清除浮动 */&#125;.clearfix:after &#123; clear:both;&#125;.clearfix &#123; *zoom:1;&#125; 浏览器查询Unicode编码 浏览器控制台输出 escape(‘查询字符串’)","categories":[{"name":"知识","slug":"知识","permalink":"http://wang-zhibiao.github.io/categories/知识/"}],"tags":[{"name":"debug","slug":"debug","permalink":"http://wang-zhibiao.github.io/tags/debug/"},{"name":"css","slug":"css","permalink":"http://wang-zhibiao.github.io/tags/css/"},{"name":"html","slug":"html","permalink":"http://wang-zhibiao.github.io/tags/html/"}],"keywords":[{"name":"知识","slug":"知识","permalink":"http://wang-zhibiao.github.io/categories/知识/"}]},{"title":"csss实用技巧持续更新","slug":"实用css技巧","date":"2018-08-07T16:10:56.000Z","updated":"2019-08-03T11:50:39.363Z","comments":true,"path":"2018/08/08/实用css技巧/","link":"","permalink":"http://wang-zhibiao.github.io/2018/08/08/实用css技巧/","excerpt":"","text":"lessless中的变量12345678910111213/*如何定义@变量名=变量值如何使用在样式中属性:变量名例子定义*/@color=#f00；/*使用*/a&#123;color:color;background:color;&#125; less的循环 ，使用递归123456789101112.box1&#123; border-bottom:10px solid #ccc;&#125;.box2&#123; border-bottom:20px solid #ccc;&#125;.box3&#123; border-bottom:30px solid #ccc;&#125;.box4&#123; border-bottom:40px solid #ccc;&#125; 1234567.loop(@cout)when(@cout&gt;0)&#123; .loop((@cout-1)) .box@&#123;cout&#125;&#123; border-bottom:@cout+0px solid #ccc; &#125;&#125;.loop(3) 原生css的声明变量1234567891011121314151617/*声明变量 使用 -- 关键字调用变量 使用 var() 函数*/a&#123; --color: red; /* 使用变量 必须放在var函数内 */ background-color: var(--color);&#125;var(--变量名,参数) div &#123; height: 500px; /* 默认参数 200px */ padding-top: var(--padding-top,200px); /* 默认参数 10px solid red */ border: var(--border, 10px solid red); /* 默认参数 linear-gradient(yellow,red) */ background-image: var(--img,linear-gradient(yellow,red)); &#125; css的计算（calc）123div&#123; height:calc(100px*90)&#125; 将超出的文本以…的方式缩减123456789.line2 &#123; display: -webkit-box; overflow: hidden; white-space: normal!important; text-overflow: ellipsis; word-wrap: break-word; -webkit-line-clamp: 2; -webkit-box-orient: vertical&#125; flex弹性布局子元素居中12345div&#123; display:flex; justify-content:center; align-content:center;&#125; 使用:not()选择器123ul&gt;li:not(last-child)&#123; border-right: 1px solid #666;&#125; not()是可以令最后一项li不加右边框，表示否定 使用伪类+content+position+transform实现文字或者图形的样式 1234567891011121314/*文字实现 ° 度数单位*/ div &#123; width: 150px; height: 30px; border: 1px solid #000; position: relative; &#125;div::after &#123; content: '°'; position: absolute; top: 0; right: 10px; &#125; bing.com搜索的国际版按钮的布局1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;style&gt;span &#123; width: 82px; height: 36px; display: block; position: relative; margin-right: 8px; cursor: pointer;&#125;span i &#123; position: absolute; z-index: 2; display: block; width: 100%; height: 100%; line-height: 30px; text-align: center; color: #fff;&#125;span::after &#123; position: absolute; left: 0; top: 0; display: block; content: \"\"; width: 100%; height: 100%; border: 1px rgba(255, 255, 255, 0.2) solid; border-bottom: none; transform: scale(1.1, 1.3) perspective(0.7em) rotateX(2.2deg); /*重点*/ transform-origin: bottom left; background: rgba(0, 0, 0, 0.5); border-radius: 1px 2px 0 0; box-sizing: border-box;&#125;&lt;/style&gt;&lt;body&gt; &lt;span&gt; &lt;i&gt;国际版&lt;/i&gt; &lt;/span&gt;&lt;/body&gt; 清除浮动123456789101112131415161718192021222324.clearfix&#123; zoom: 1; /*IE6*/&#125;.clearfix:after&#123; content: \".\"; height: 0; clear: both; display: block; visibility: hidden;&#125;// 全浏览器通用的clearfix方案【推荐】// 引入了zoom以支持IE6/7// 同时加入:before以解决现代浏览器上边距折叠的问题.clearfix:before,.clearfix:after &#123; display: table; content: \" \";&#125;.clearfix:after &#123; clear: both;&#125;.clearfix&#123; *zoom: 1;&#125;","categories":[{"name":"css","slug":"css","permalink":"http://wang-zhibiao.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://wang-zhibiao.github.io/tags/css/"},{"name":"实用","slug":"实用","permalink":"http://wang-zhibiao.github.io/tags/实用/"}],"keywords":[{"name":"css","slug":"css","permalink":"http://wang-zhibiao.github.io/categories/css/"}]},{"title":"简历","slug":"个人简历","date":"2017-12-31T16:10:56.000Z","updated":"2019-08-22T08:44:56.381Z","comments":true,"path":"2018/01/01/个人简历/","link":"","permalink":"http://wang-zhibiao.github.io/2018/01/01/个人简历/","excerpt":"","text":"个人信息 ​ 性别：男 年龄：23 手机：132-4275-8485 ​ 邮箱：wangxx599@163.com 个人博客地址 https://wang-zhibiao.github.io/ 基本技能 掌握HTML/CSS/Javascript 等前端技术，熟悉HTML5/CSS3技术，能快速写出符合 W3C 标准、兼容主流浏览器的代码，对表现与数据分离、Web语义化等有深刻理解； ； 熟练掌握javascript语言，熟练运用jQuery库、bootstrap能够实现网页的动态效果与页面交互； 熟悉原生js闭包，作用域，原型链，js面向对象等基础知识； 熟练运用Vue，vue-cli、webpack打包工具来制作pc端的单页面应用； 熟练运用自定义组件、路由等微信小程序相关技术，来制作微信小程序相关应用； 熟练掌握Ajax+Promise技术及使用Navicat对数据库进行简单操作； 熟练掌握less、scss预处理器、ECharts、git、swiper、qrcode、等有关功能插件的运用； 使用Git版本管理工具，能够用Git和Github进行配合管理项目版本；","categories":[{"name":"简历","slug":"简历","permalink":"http://wang-zhibiao.github.io/categories/简历/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://wang-zhibiao.github.io/tags/vue/"}],"keywords":[{"name":"简历","slug":"简历","permalink":"http://wang-zhibiao.github.io/categories/简历/"}]}]}