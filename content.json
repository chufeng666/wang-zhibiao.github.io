{"meta":{"title":"wang-zhibiao'blog","subtitle":"I am is a boy","description":"note","author":"wangzhibiao","url":"http://wang-zhibiao.github.io"},"pages":[{"title":"about","date":"2019-06-16T13:48:33.000Z","updated":"2019-06-16T13:48:34.047Z","comments":true,"path":"about/index.html","permalink":"http://wang-zhibiao.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"JS全局污染","slug":"JS全局污染","date":"2019-06-20T11:50:59.000Z","updated":"2019-07-01T01:20:12.648Z","comments":true,"path":"2019/06/20/JS全局污染/","link":"","permalink":"http://wang-zhibiao.github.io/2019/06/20/JS全局污染/","excerpt":"","text":"所谓全局变量污染 ：定义多个全局变量，函数，对象挂载在window上，如果重复使用则造成变量冲突 如果定义一个全局变量则会在window上挂载这个变量，所有的函数，对象，引用此js文件的都可以使用， 1234567891011&lt;script&gt; var a = 10; console.log(window);&lt;/script&gt;//输出Windowa: 10alert: ƒ alert()applicationCache: ApplicationCache &#123;status: 0, oncached: null, onchecking: null, ondownloading: null, onerror: null, …&#125;。。。。。。。 污染如同衣物沾上污渍，笔墨落入清水。 全局window是大家都能使用，如果在全局挂载变量太多，难免会调用重复的变量，改变其属性或值。 在开发中，多人共同开发，每个人的代码习惯不同，命名方法不同，如果其他人命名一个变量ID，那么，在调用ID时会改变上一个人的ID导致不是自己想要的ID。 123456789101112131415161718192021222324//developer_first.js&lt;script&gt; var ID = 10; console.log(ID);&lt;/script&gt;//developer_second.js&lt;script&gt; var ID = 2; console.log(ID);&lt;/script&gt;//developer_thirdly.js&lt;script&gt; var ID = 4; console.log(ID);&lt;/script&gt;//在主文件中调用&lt;head&gt;&lt;script src=\"developer_first.js\"&gt;&lt;/script&gt;&lt;script src=\"developer_second.js\"&gt;&lt;/script&gt; &lt;script src=\"developer_thirdly.js\"&gt;&lt;/script&gt; //最后的&lt;/head&gt;//=&gt;输出 4 4 4 ID会使用最后调用的js文件 为了避免全局污染，应慎重使用全局变量。了解模块化，或者let 定义的let不在window里 在script内有效 或者函数{}内有效，形成块级作用域","categories":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"}],"keywords":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}]},{"title":"隐藏元素的方法","slug":"隐藏元素的方法","date":"2019-06-11T16:10:56.000Z","updated":"2019-06-29T07:50:17.857Z","comments":true,"path":"2019/06/12/隐藏元素的方法/","link":"","permalink":"http://wang-zhibiao.github.io/2019/06/12/隐藏元素的方法/","excerpt":"","text":"隐藏类型 屏幕并不是唯一的输出机制，比如说屏幕上看不见的元素（隐藏的元素），其中一些依然能够被读屏软件阅读出来（因为读屏软件依赖于可访问性树来阐述）。为了消除它们之间的歧义，我们将其归为三大类： 完全隐藏：元素从DOM树中消失，不占据空间。 视觉上的隐藏：屏幕中不可见，占据空间。 语义上的隐藏：读屏软件不可读，但正常占据空间。 完全隐藏 1.display 属性1display: none; 2.hidden 属性 HTML5 新增属性，相当于 display: none 12&lt;div hidden&gt;&lt;/div&gt; 视觉上的隐藏,在页面中还存在 3.利用 position 和 盒模型 将元素移出可视区范围 设置 posoition 为 absolute 或 fixed，\b通过设置 top、left 等值，将其移出可视区域。 12position:absolute;left: -999px; 设置 position 为 relative，通过设置 top、left 等值，将其移出可视区域。 12position: relative;left: -999px; 设置 margin 值，将其移出可视区域范围（可视区域占位）。 12margin-left: -99999px;height: 0; 3.利用 transfrom 缩放 12transform: scale(0);height: 0; 移动 translateX, translateY 12transform: translateX(-99999px);height: 0 旋转 rotate 1transform: rotateY(90deg) //直角在界面上形成线性视觉屏蔽 4.设置其大小为0 宽高为0，字体大小为0： 123height: 0;width: 0;font-size: 0; 宽高为0，超出隐藏: 123height: 0;width: 0;overflow: hidden; 5.设置透明度为01opacity: 0; 6.visibility属性1visibility: hidden; 7.层级覆盖，z-index 属性12position: relative;z-index: -999; 再设置一个层级较高的元素覆盖在此元素上。8.clip-path 裁剪1clip-path: polygon(0 0, 0 0, 0 0, 0 0); 语义上的隐藏","categories":[{"name":"基础","slug":"基础","permalink":"http://wang-zhibiao.github.io/categories/基础/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"function","slug":"function","permalink":"http://wang-zhibiao.github.io/tags/function/"}],"keywords":[{"name":"基础","slug":"基础","permalink":"http://wang-zhibiao.github.io/categories/基础/"}]},{"title":"BFC协议","slug":"BFC协议","date":"2019-06-11T16:10:56.000Z","updated":"2019-06-29T07:50:29.866Z","comments":true,"path":"2019/06/12/BFC协议/","link":"","permalink":"http://wang-zhibiao.github.io/2019/06/12/BFC协议/","excerpt":"","text":"什么是BFC？BFC的布局规则是什么？如何创建BFC？查看解析 Box 是 CSS 布局的对象和基本单位，页面是由若干个Box组成的。 元素的类型 和 display 属性，决定了这个 Box 的类型。不同类型的 Box 会参与不同的 Formatting Context。 Formatting Context Formatting Context 是页面的一块渲染区域，并且有一套渲染规则，决定了其子元素将如何定位，以及和其它元素的关系和相互作用。 Formatting Context 有 BFC (Block formatting context)，IFC (Inline formatting context)，FFC (Flex formatting context) 和 GFC (Grid formatting context)。FFC 和 GFC 为 CC3 中新增。 BFC布局规则 BFC内，盒子依次垂直排列。 BFC内，两个盒子的垂直距离由 margin 属性决定。属于同一个BFC的两个相邻Box的margin会发生重叠【符合合并原则的margin合并后是使用大的margin】 BFC内，每个盒子的左外边缘接触内部盒子的左边缘（对于从右到左的格式，右边缘接触）。即使在存在浮动的情况下也是如此。除非创建新的BFC。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算。 如何创建BFC 根元素 浮动元素（float 属性不为 none） position 为 absolute 或 fixed overflow 不为 visible 的块元素 display 为 inline-block, table-cell, table-caption BFC 的应用 防止 margin 重叠 (同一个BFC内的两个两个相邻Box的 margin 会发生重叠，触发生成两个BFC，即不会重叠) 清除内部浮动 (创建一个新的 BFC，因为根据 BFC 的规则，计算 BFC 的高度时，浮动元素也参与计算) 自适应多栏布局 (BFC的区域不会与float box重叠。因此，可以触发生成一个新的BFC)","categories":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"function","slug":"function","permalink":"http://wang-zhibiao.github.io/tags/function/"}],"keywords":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}]},{"title":"let var const三种定义方式及闭包","slug":"var let const三种定义方式及闭包","date":"2019-06-11T16:10:56.000Z","updated":"2019-06-29T03:24:17.522Z","comments":true,"path":"2019/06/12/var let const三种定义方式及闭包/","link":"","permalink":"http://wang-zhibiao.github.io/2019/06/12/var let const三种定义方式及闭包/","excerpt":"","text":"let var const 之间的区别varvar的作用域是根据函数作用域的， 他在函数内起作用 这里就引用到闭包和作用域链 12345678function out()&#123; var a = 000; //=&gt; 这个a的作用域作用在out内 而info函数在out函数内 所以可以调用 b=222 //=&gt; 报错err 因为b的作用域在info函数内 包裹他的out函数不可以调用它function info()&#123; var b=999; a= 111; &#125;&#125; var 的变量提升 12345678function ()&#123; var a=10; &#125;//变量提升 就是var定义的变量会在先声明再赋值 提升到函数顶部function()&#123; var a; a=10;&#125; letlet的作用域的块级作用域，不会变量提升 可以理解为在某块范围内作用 与var 的函数作用域不同在于 let的作用域会形成闭包 12345678910111213for (var i = 0; i &lt; 3; i++) &#123; setTimeout(function () &#123; console.log(i); &#125;, 1000)&#125;//输出 3 3 3for (let i = 0; i &lt; 3; i++) &#123; setTimeout(function () &#123; console.log(i); &#125;, 1000)&#125;//输出 0 1 2 12var会在全局声明 而setTimeout 是一个定时器 也是异步回调 会在同步执行完毕再执行异步 所以当for循环完毕 i=3时调用三次定时器 let 的作用范围会在for循环内 每循环一次 i会形成一次闭包 i会被setTimeout调用 constconst代表一个值的常量索引，常量的值在垃圾回收前永远不能改变，所以需要谨慎使用。 cosnt定义的值不能被改变 否则会报错 12Uncaught TypeError: Assignment to constant variable.未捕获的类型错误:赋值给常量变量。 闭包外部可以访问内部的私有变量 可以返回携带状态的函数，并且状态隐藏 可以做到变量的私有 123456function f1()&#123; var n=999; function f2()&#123; alert(n); // 999 &#125;&#125; 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！ 123456789function f1()&#123; var n=999; function f2()&#123; alert(n); &#125;return f2;&#125;var result=f1();result(); // 999 闭包就是能够读取其他函数内部变量的函数 要形成闭包 必须两层function函数作用域 123456789101112function f1()&#123; var n=999; Add=function()&#123;n+=1&#125; function f2()&#123; console.log(n)&#125;return f2;&#125;var result=f1();result(); // 999Add();result(); // 1000 这里形成闭包后，f1的局部变量n一直保存在内存中，并没有因为f1的重复调用而清除 原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 缺点由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 12345678910var name = \"The Window\";var object = &#123; name: \"My Object\", getNameFunc: function () &#123; return function () &#123; return this.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); 经典闭包题 个人理解 object.getNameFunc() 执行到这一步时 调用object内的函数 返回一个function（）{return this.name} 这时候 name还是My Object 当再次执行时object.getNameFunc()() 调用了外部的name 输出为The Window","categories":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"function","slug":"function","permalink":"http://wang-zhibiao.github.io/tags/function/"}],"keywords":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}]},{"title":"JavaScript的变量以及数据类型","slug":"变量和js类型的理解","date":"2019-06-09T01:24:56.000Z","updated":"2019-06-24T03:30:23.445Z","comments":true,"path":"2019/06/09/变量和js类型的理解/","link":"","permalink":"http://wang-zhibiao.github.io/2019/06/09/变量和js类型的理解/","excerpt":"","text":"一、JavaScript数据类型ECMAScript标准规定了7种数据类型，其把这7种数据类型又分为两种：原始类型和对象类型。 原始类型 Null：只包含一个值：null Undefined：只包含一个值：undefined Boolean：包含两个值：true和false Number：整数或浮点数，还有一些特殊值（-Infinity、+Infinity、NaN） String：一串表示文本值的字符序列 Symbol：一种实例是唯一且不可改变的数据类型 (在es10中加入了第七种原始类型BigInt，现已被最新Chrome支持) 对象类型 Object：自己分一类丝毫不过分，除了常用的Object，Array、Function等都属于特殊的对象 区分原始类型和对象类型 - 不可变性 原始类型存放在栈空间中，而复杂类型存放在堆空间中 栈内存： 存储的值大小固定 空间较小 可以直接操作其保存的变量，运行效率高 由系统自动分配存储空间 堆内存： 存储的值大小不定，可动态调整 空间较大，运行效率低 无法直接操作其内部存储，使用引用地址读取 通过代码进行分配空间 字符串 具备不可变性不管是字符串的裁切splice 还是 toLowerCase 都是在原有的基础上产生新的字符串 JavaScript中的原始类型的值被直接存储在栈中，在变量定义时，栈就为其分配好了内存空间。 由于栈中的内存空间的大小是固定的，那么注定了存储在栈中的变量就是不可变的 对象 具备可变性引用类型的值实际存储在堆内存中，它在栈中只存储了一个固定长度的地址，这个地址指向堆内存中的值。 数组 是一个复杂（引用）类型 通过一些api可以改变数组 pop() 删除数组最后一个元素，如果数组为空，则不改变数组，返回undefined，改变原数组，返回被删除的元素 push()向数组末尾添加一个或多个元素，改变原数组，返回新数组的长度 shift()把数组的第一个元素删除，若空数组，不进行任何操作，返回undefined,改变原数组，返回第一个元素的值 unshift()向数组的开头添加一个或多个元素，改变原数组，返回新数组的长度 reverse()颠倒数组中元素的顺序，改变原数组，返回该数组 sort()对数组元素进行排序，改变原数组，返回该数组 splice()从数组中添加/删除项目，改变原数组，返回被删除的元素 当我们进行复制时两者有着本质的区别 这里涉及到浅拷贝和深拷贝—本质是复制时是否改变复制的对象的数值或属性或方法 原始类型12345var name = 'wang';var newName = name;newName = 'Mr.wang';console.log(name) // =&gt;wangconsole.log(newName) // =&gt;Mr.wang 内存中有一个变量name，值为wang。我们从变量name复制出一个变量newName，此时在内存中创建了一个块新的空间用于存储wang，虽然两者值是相同的，但是两者指向的内存空间完全不同，这两个变量参与任何操作都互不影响。 引用类型12345var obj = &#123;name:'wang'&#125;;var newObj = obj;newObj.name = 'Mr.wang';console.log(obj.name) //=&gt; Mr.wangconsole.log(newObj.name)//=&gt; Mr.wang 当我们复制引用类型的变量时，实际上复制的是栈中存储的地址，所以复制出来的newObj实际上和obj指向的堆中同一个对象。因此，我们改变其中任何一个变量的值，另一个变量都会受到影响，这就是为什么会有深拷贝和浅拷贝的原因。 原始类型和引用类型的比较原始类型，比较时会直接比较它们的值，如果值相等，即返回true。 引用类型，比较时会比较它们的引用地址，虽然两个变量在堆中存储的对象具有的属性值都是相等的，但是它们被存储在了不同的存储空间，因此比较值为false。 区分null和undefinednull 表示被赋值过的对象，刻意把一个对象赋值为null，故意表示其为空，不应有值。 所以对象的某个属性值为null是正常的，null转换为数值时值为0。 undefined 表示“缺少值”，即此处应有一个值，但还没有定义， 如果一个对象的某个属性值为undefined，这是不正常的，如obj.name=undefined，我们不应该这样写，应该直接delete obj.name。 undefined转为数值时为NaN(非数字值的特殊值) JavaScript是一门动态类型语言，成员除了表示存在的空值外，还有可能根本就不存在（因为存不存在只在运行期才知道），这就是undefined的意义所在。对于JAVA这种强类型语言，如果有&quot;undefined&quot;这种情况，就会直接编译失败，所以在它不需要一个这样的类型。 你想不到的0.1+0.2≠0.3 本质是：由于数字在js中的计算是先转换为二进制在进行计算的，然后以十进制输出 12345678910111213141516171819202122232425262728function judgeFloat(n, m) &#123; const binaryN = n.toString(2); const binaryM = m.toString(2); console.log(`$&#123;n&#125;的二进制是 $&#123;binaryN&#125;`); console.log(`$&#123;m&#125;的二进制是 $&#123;binaryM&#125;`); const MN = m + n; const accuracyMN = (m * 100 + n * 100) / 100; const binaryMN = MN.toString(2); const accuracyBinaryMN = accuracyMN.toString(2); console.log(`$&#123;n&#125;+$&#123;m&#125;的二进制是$&#123;binaryMN&#125;`); console.log(`$&#123;accuracyMN&#125;的二进制是 $&#123;accuracyBinaryMN&#125;`); console.log(`$&#123;n&#125;+$&#123;m&#125;的二进制再转成十进制是$&#123;to10(binaryMN)&#125;`); console.log(`$&#123;accuracyMN&#125;的二进制是再转成十进制是$&#123;to10(accuracyBinaryMN)&#125;`); console.log(`$&#123;n&#125;+$&#123;m&#125;在js中计算是$&#123;(to10(binaryMN) === to10(accuracyBinaryMN)) ? '' : '不'&#125;准确的`); &#125; function to10(n) &#123; const pre = (n.split('.')[0] - 0).toString(2); const arr = n.split('.')[1].split(''); let i = 0; let result = 0; while (i &lt; arr.length) &#123; result += arr[i] * Math.pow(2, -(i + 1)); i++; &#125; return result; &#125; judgeFloat(0.1, 0.2); judgeFloat(0.6, 0.7); 计算机中所有的数据都是以二进制存储的，所以在计算时计算机要把数据先转换成二进制进行计算，然后在把计算结果转换成十进制。 由上面的代码不难看出，在计算0.1+0.2时，二进制计算发生了精度丢失，导致再转换成十进制后和预计的结果不符。 隐式转换 if语句和逻辑语句在if语句和逻辑语句中，如果只有单个变量，会先将变量转换为Boolean值，只有下面几种情况会转换成false，其余被转换成true： 123456nullundefined&apos;&apos;NaN0false 各种运数学算符我们在对各种非Number类型运用数学运算符(- * /)时，会先将非Number类型转换为Number类型; 12341 - true // 01 - null // 11 * undefined // NaN2 * [&apos;5&apos;] // 10 注意+是个例外，执行+操作符时： 1.当一侧为String类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。 2.当一侧为Number类型，另一侧为原始类型，则将原始类型转换为Number类型。 3.当一侧为Number类型，另一侧为引用类型，将引用类型和Number类型转换成字符串后拼接。 1234123 + &apos;123&apos; // 123123 （规则1）123 + null // 123 （规则2）123 + true // 124 （规则2）123 + &#123;&#125; // 123[object Object] （规则3） == 运算符使用==时，若两侧类型相同，则比较结果和===相同，否则会发生隐式转换，使用==时发生的转换可以分为几种不同的情况（只考虑两侧类型不同）： 1.NaN NaN和其他任何类型比较永远返回false(包括和他自己)。 1NaN == NaN // false 2.Boolean Boolean和其他任何类型比较，Boolean首先被转换为Number类型。 1234true == 1 // true true == &apos;2&apos; // falsetrue == [&apos;1&apos;] // truetrue == [&apos;2&apos;] // false 这里注意一个可能会弄混的点：undefined、null和Boolean比较，虽然undefined、null和false都很容易被想象成假值，但是他们比较结果是false，原因是false首先被转换成0： 12undefined == false // falsenull == false // false 3.String和Number String和Number比较，先将String转换为Number类型。 12123 == &apos;123&apos; // true&apos;&apos; == 0 // true 4.null和undefined null == undefined比较结果是true，除此之外，null、undefined和其他任何结果的比较值都为false。 1234567null == undefined // truenull == &apos;&apos; // falsenull == 0 // falsenull == false // falseundefined == &apos;&apos; // falseundefined == 0 // falseundefined == false // false 5.原始类型和引用类型 当原始类型和引用类型做比较时，对象类型会依照ToPrimitive规则转换为原始类型: 12&apos;[object Object]&apos; == &#123;&#125; // true&apos;1,2,3&apos; == [1, 2, 3] // true 来看看下面这个比较： 1[] == ![] // true !的优先级高于==，![]首先会被转换为false，然后根据上面第三点，false转换成Number类型0，左侧[]转换为0，两侧比较相等。 12[null] == false // true[undefined] == false // true 根据数组的ToPrimitive规则，数组元素为null或undefined时，该元素被当做空字符串处理，所以[null]、[undefined]都会被转换为0。 原型链的规则 1.所有引用类型都具有对象特性，即可以自由扩展属性 2.所有引用类型都具有一个proto（隐式原型）属性，是一个普通对象 3.所有的函数都具有prototype（显式原型）属性，也是一个普通对象 4.所有引用类型proto值指向它构造函数的prototype 5.当试图得到一个对象的属性时，如果变量本身没有这个属性，则会去他的proto中去找 toString上面我们在拆箱操作中提到了toString函数，我们可以调用它实现从引用类型的转换。 每一个引用类型都有toString方法，默认情况下，toString()方法被每个Object对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 &quot;[object type]&quot;，其中type是对象的类型。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"}],"keywords":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}]}]}